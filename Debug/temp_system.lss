
temp_system.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004384  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001a0  00800060  00004384  00004418  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000015  00800200  00800200  000045b8  2**0
                  ALLOC
  3 .stab         00005490  00000000  00000000  000045b8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001c66  00000000  00000000  00009a48  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000b6ae  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000b7ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000b95e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0000d5a7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0000e492  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0000f240  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0000f3a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0000f62d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000fdfb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 16 0b 	jmp	0x162c	; 0x162c <__vector_1>
       8:	0c 94 49 0b 	jmp	0x1692	; 0x1692 <__vector_2>
       c:	0c 94 7c 0b 	jmp	0x16f8	; 0x16f8 <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 c8 07 	jmp	0xf90	; 0xf90 <__vector_10>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 ae 06 	jmp	0xd5c	; 0xd5c <__vector_13>
      38:	0c 94 db 06 	jmp	0xdb6	; 0xdb6 <__vector_14>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 23 0f 	jmp	0x1e46	; 0x1e46 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	12 e0       	ldi	r17, 0x02	; 2
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e8       	ldi	r30, 0x84	; 132
      68:	f3 e4       	ldi	r31, 0x43	; 67
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 30       	cpi	r26, 0x00	; 0
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	12 e0       	ldi	r17, 0x02	; 2
      78:	a0 e0       	ldi	r26, 0x00	; 0
      7a:	b2 e0       	ldi	r27, 0x02	; 2
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 31       	cpi	r26, 0x15	; 21
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 73 20 	call	0x40e6	; 0x40e6 <main>
      8a:	0c 94 c0 21 	jmp	0x4380	; 0x4380 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 89 21 	jmp	0x4312	; 0x4312 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ae ed       	ldi	r26, 0xDE	; 222
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 a5 21 	jmp	0x434a	; 0x434a <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 95 21 	jmp	0x432a	; 0x432a <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 b1 21 	jmp	0x4362	; 0x4362 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 95 21 	jmp	0x432a	; 0x432a <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 b1 21 	jmp	0x4362	; 0x4362 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 89 21 	jmp	0x4312	; 0x4312 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8e ed       	ldi	r24, 0xDE	; 222
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 a5 21 	jmp	0x434a	; 0x434a <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 95 21 	jmp	0x432a	; 0x432a <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 b1 21 	jmp	0x4362	; 0x4362 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 95 21 	jmp	0x432a	; 0x432a <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 b1 21 	jmp	0x4362	; 0x4362 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 95 21 	jmp	0x432a	; 0x432a <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 b1 21 	jmp	0x4362	; 0x4362 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 99 21 	jmp	0x4332	; 0x4332 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 b5 21 	jmp	0x436a	; 0x436a <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <UART_void_SetCBReceive>:
void (*CallBackReceive) (void) ;
void (*CallBackSend) (void) ;


void UART_void_SetCBReceive( void (*ptr) (void) )
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <UART_void_SetCBReceive+0x6>
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	9a 83       	std	Y+2, r25	; 0x02
     b52:	89 83       	std	Y+1, r24	; 0x01
	CallBackReceive = ptr ;
     b54:	89 81       	ldd	r24, Y+1	; 0x01
     b56:	9a 81       	ldd	r25, Y+2	; 0x02
     b58:	90 93 12 02 	sts	0x0212, r25
     b5c:	80 93 11 02 	sts	0x0211, r24
}
     b60:	0f 90       	pop	r0
     b62:	0f 90       	pop	r0
     b64:	cf 91       	pop	r28
     b66:	df 91       	pop	r29
     b68:	08 95       	ret

00000b6a <UART_void_SetCBSend>:

void UART_void_SetCBSend( void (*ptr) (void) )
{
     b6a:	df 93       	push	r29
     b6c:	cf 93       	push	r28
     b6e:	00 d0       	rcall	.+0      	; 0xb70 <UART_void_SetCBSend+0x6>
     b70:	cd b7       	in	r28, 0x3d	; 61
     b72:	de b7       	in	r29, 0x3e	; 62
     b74:	9a 83       	std	Y+2, r25	; 0x02
     b76:	89 83       	std	Y+1, r24	; 0x01
	CallBackSend = ptr ;
     b78:	89 81       	ldd	r24, Y+1	; 0x01
     b7a:	9a 81       	ldd	r25, Y+2	; 0x02
     b7c:	90 93 14 02 	sts	0x0214, r25
     b80:	80 93 13 02 	sts	0x0213, r24
}
     b84:	0f 90       	pop	r0
     b86:	0f 90       	pop	r0
     b88:	cf 91       	pop	r28
     b8a:	df 91       	pop	r29
     b8c:	08 95       	ret

00000b8e <UART_u8_ReturnUDRValue>:

u8 UART_u8_ReturnUDRValue(void)
{
     b8e:	df 93       	push	r29
     b90:	cf 93       	push	r28
     b92:	cd b7       	in	r28, 0x3d	; 61
     b94:	de b7       	in	r29, 0x3e	; 62
	return UDR ;
     b96:	ec e2       	ldi	r30, 0x2C	; 44
     b98:	f0 e0       	ldi	r31, 0x00	; 0
     b9a:	80 81       	ld	r24, Z
}
     b9c:	cf 91       	pop	r28
     b9e:	df 91       	pop	r29
     ba0:	08 95       	ret

00000ba2 <UART_voidInit>:


void UART_voidInit(void)
{
     ba2:	df 93       	push	r29
     ba4:	cf 93       	push	r28
     ba6:	0f 92       	push	r0
     ba8:	cd b7       	in	r28, 0x3d	; 61
     baa:	de b7       	in	r29, 0x3e	; 62
	u8 Local_u8uCSRCVal=0;
     bac:	19 82       	std	Y+1, r1	; 0x01
	/*set bit 7 for UCsRC register select*/
	SET_BIT(Local_u8uCSRCVal,UCSRC_URSEL);
     bae:	89 81       	ldd	r24, Y+1	; 0x01
     bb0:	80 68       	ori	r24, 0x80	; 128
     bb2:	89 83       	std	Y+1, r24	; 0x01
	/*Select 8-bit data frame*/
	CLR_BIT(UCSRB , UCSRB_UCSZ2) ;
     bb4:	aa e2       	ldi	r26, 0x2A	; 42
     bb6:	b0 e0       	ldi	r27, 0x00	; 0
     bb8:	ea e2       	ldi	r30, 0x2A	; 42
     bba:	f0 e0       	ldi	r31, 0x00	; 0
     bbc:	80 81       	ld	r24, Z
     bbe:	8b 7f       	andi	r24, 0xFB	; 251
     bc0:	8c 93       	st	X, r24
	SET_BIT(Local_u8uCSRCVal ,UCSRC_UCSZ1) ;
     bc2:	89 81       	ldd	r24, Y+1	; 0x01
     bc4:	84 60       	ori	r24, 0x04	; 4
     bc6:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(Local_u8uCSRCVal ,UCSRC_UCSZ0) ;
     bc8:	89 81       	ldd	r24, Y+1	; 0x01
     bca:	82 60       	ori	r24, 0x02	; 2
     bcc:	89 83       	std	Y+1, r24	; 0x01
	/*Select asynchronous mode*/
	CLR_BIT(Local_u8uCSRCVal , UCSRC_UMSEL);
     bce:	89 81       	ldd	r24, Y+1	; 0x01
     bd0:	8f 7b       	andi	r24, 0xBF	; 191
     bd2:	89 83       	std	Y+1, r24	; 0x01
	/*disable parity bit*/
	CLR_BIT(Local_u8uCSRCVal,UCSRC_UPM1);
     bd4:	89 81       	ldd	r24, Y+1	; 0x01
     bd6:	8f 7d       	andi	r24, 0xDF	; 223
     bd8:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(Local_u8uCSRCVal,UCSRC_UPM0);
     bda:	89 81       	ldd	r24, Y+1	; 0x01
     bdc:	8f 7e       	andi	r24, 0xEF	; 239
     bde:	89 83       	std	Y+1, r24	; 0x01
	/*Choose one stop bit */
	CLR_BIT(Local_u8uCSRCVal , UCSRC_USBS);
     be0:	89 81       	ldd	r24, Y+1	; 0x01
     be2:	87 7f       	andi	r24, 0xF7	; 247
     be4:	89 83       	std	Y+1, r24	; 0x01
	/*CLR clock polarity */
	CLR_BIT(Local_u8uCSRCVal , UCSRC_UCPOL);
     be6:	89 81       	ldd	r24, Y+1	; 0x01
     be8:	8e 7f       	andi	r24, 0xFE	; 254
     bea:	89 83       	std	Y+1, r24	; 0x01
	UCSRC=Local_u8uCSRCVal;
     bec:	e0 e4       	ldi	r30, 0x40	; 64
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	89 81       	ldd	r24, Y+1	; 0x01
     bf2:	80 83       	st	Z, r24
	/* select 9600 baud rate 16 Mhz*/
	UBRRH = 0 ; // write zero on the last bit to choose UBRRH
     bf4:	e0 e4       	ldi	r30, 0x40	; 64
     bf6:	f0 e0       	ldi	r31, 0x00	; 0
     bf8:	10 82       	st	Z, r1
	UBRRL = B_9600 ;
     bfa:	e9 e2       	ldi	r30, 0x29	; 41
     bfc:	f0 e0       	ldi	r31, 0x00	; 0
     bfe:	87 e6       	ldi	r24, 0x67	; 103
     c00:	80 83       	st	Z, r24
	
	/*Enable rx and tx*/
	SET_BIT(UCSRB , UCSRB_RXEN) ;
     c02:	aa e2       	ldi	r26, 0x2A	; 42
     c04:	b0 e0       	ldi	r27, 0x00	; 0
     c06:	ea e2       	ldi	r30, 0x2A	; 42
     c08:	f0 e0       	ldi	r31, 0x00	; 0
     c0a:	80 81       	ld	r24, Z
     c0c:	80 61       	ori	r24, 0x10	; 16
     c0e:	8c 93       	st	X, r24
	SET_BIT(UCSRB , UCSRB_TXEN) ;
     c10:	aa e2       	ldi	r26, 0x2A	; 42
     c12:	b0 e0       	ldi	r27, 0x00	; 0
     c14:	ea e2       	ldi	r30, 0x2A	; 42
     c16:	f0 e0       	ldi	r31, 0x00	; 0
     c18:	80 81       	ld	r24, Z
     c1a:	88 60       	ori	r24, 0x08	; 8
     c1c:	8c 93       	st	X, r24
	/*disable interrupt*/
	CLR_BIT(UCSRB , UCSRB_RXCIE);
     c1e:	aa e2       	ldi	r26, 0x2A	; 42
     c20:	b0 e0       	ldi	r27, 0x00	; 0
     c22:	ea e2       	ldi	r30, 0x2A	; 42
     c24:	f0 e0       	ldi	r31, 0x00	; 0
     c26:	80 81       	ld	r24, Z
     c28:	8f 77       	andi	r24, 0x7F	; 127
     c2a:	8c 93       	st	X, r24
	CLR_BIT(UCSRB , UCSRB_UDRIE);
     c2c:	aa e2       	ldi	r26, 0x2A	; 42
     c2e:	b0 e0       	ldi	r27, 0x00	; 0
     c30:	ea e2       	ldi	r30, 0x2A	; 42
     c32:	f0 e0       	ldi	r31, 0x00	; 0
     c34:	80 81       	ld	r24, Z
     c36:	8f 7d       	andi	r24, 0xDF	; 223
     c38:	8c 93       	st	X, r24

}
     c3a:	0f 90       	pop	r0
     c3c:	cf 91       	pop	r28
     c3e:	df 91       	pop	r29
     c40:	08 95       	ret

00000c42 <UART_voidSendByte>:

void UART_voidSendByte(u8 Byte)
{
     c42:	df 93       	push	r29
     c44:	cf 93       	push	r28
     c46:	0f 92       	push	r0
     c48:	cd b7       	in	r28, 0x3d	; 61
     c4a:	de b7       	in	r29, 0x3e	; 62
     c4c:	89 83       	std	Y+1, r24	; 0x01
	while(GET_BIT(UCSRA , UCSRA_UDRE) == 0); // stuck here to check if flag is one to sure the UDR is empty
     c4e:	eb e2       	ldi	r30, 0x2B	; 43
     c50:	f0 e0       	ldi	r31, 0x00	; 0
     c52:	80 81       	ld	r24, Z
     c54:	82 95       	swap	r24
     c56:	86 95       	lsr	r24
     c58:	87 70       	andi	r24, 0x07	; 7
     c5a:	88 2f       	mov	r24, r24
     c5c:	90 e0       	ldi	r25, 0x00	; 0
     c5e:	81 70       	andi	r24, 0x01	; 1
     c60:	90 70       	andi	r25, 0x00	; 0
     c62:	00 97       	sbiw	r24, 0x00	; 0
     c64:	a1 f3       	breq	.-24     	; 0xc4e <UART_voidSendByte+0xc>
	UDR = Byte ;
     c66:	ec e2       	ldi	r30, 0x2C	; 44
     c68:	f0 e0       	ldi	r31, 0x00	; 0
     c6a:	89 81       	ldd	r24, Y+1	; 0x01
     c6c:	80 83       	st	Z, r24

}
     c6e:	0f 90       	pop	r0
     c70:	cf 91       	pop	r28
     c72:	df 91       	pop	r29
     c74:	08 95       	ret

00000c76 <UART_voidWriteNewLine>:
void UART_voidWriteNewLine(void)
{
     c76:	df 93       	push	r29
     c78:	cf 93       	push	r28
     c7a:	cd b7       	in	r28, 0x3d	; 61
     c7c:	de b7       	in	r29, 0x3e	; 62
	UART_voidSendByte(NEW_LINE);
     c7e:	8d e0       	ldi	r24, 0x0D	; 13
     c80:	0e 94 21 06 	call	0xc42	; 0xc42 <UART_voidSendByte>
}
     c84:	cf 91       	pop	r28
     c86:	df 91       	pop	r29
     c88:	08 95       	ret

00000c8a <UART_voidSendString>:
void UART_voidSendString(char Copy_u8Str[])
{
     c8a:	df 93       	push	r29
     c8c:	cf 93       	push	r28
     c8e:	00 d0       	rcall	.+0      	; 0xc90 <UART_voidSendString+0x6>
     c90:	0f 92       	push	r0
     c92:	cd b7       	in	r28, 0x3d	; 61
     c94:	de b7       	in	r29, 0x3e	; 62
     c96:	9b 83       	std	Y+3, r25	; 0x03
     c98:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8Iteration = 0;
     c9a:	19 82       	std	Y+1, r1	; 0x01
     c9c:	0e c0       	rjmp	.+28     	; 0xcba <UART_voidSendString+0x30>
	while (Copy_u8Str[Local_u8Iteration] != '\0')
	{
		UART_voidSendByte(Copy_u8Str[Local_u8Iteration]);
     c9e:	89 81       	ldd	r24, Y+1	; 0x01
     ca0:	28 2f       	mov	r18, r24
     ca2:	30 e0       	ldi	r19, 0x00	; 0
     ca4:	8a 81       	ldd	r24, Y+2	; 0x02
     ca6:	9b 81       	ldd	r25, Y+3	; 0x03
     ca8:	fc 01       	movw	r30, r24
     caa:	e2 0f       	add	r30, r18
     cac:	f3 1f       	adc	r31, r19
     cae:	80 81       	ld	r24, Z
     cb0:	0e 94 21 06 	call	0xc42	; 0xc42 <UART_voidSendByte>
		
		Local_u8Iteration++;
     cb4:	89 81       	ldd	r24, Y+1	; 0x01
     cb6:	8f 5f       	subi	r24, 0xFF	; 255
     cb8:	89 83       	std	Y+1, r24	; 0x01
	UART_voidSendByte(NEW_LINE);
}
void UART_voidSendString(char Copy_u8Str[])
{
	u8 Local_u8Iteration = 0;
	while (Copy_u8Str[Local_u8Iteration] != '\0')
     cba:	89 81       	ldd	r24, Y+1	; 0x01
     cbc:	28 2f       	mov	r18, r24
     cbe:	30 e0       	ldi	r19, 0x00	; 0
     cc0:	8a 81       	ldd	r24, Y+2	; 0x02
     cc2:	9b 81       	ldd	r25, Y+3	; 0x03
     cc4:	fc 01       	movw	r30, r24
     cc6:	e2 0f       	add	r30, r18
     cc8:	f3 1f       	adc	r31, r19
     cca:	80 81       	ld	r24, Z
     ccc:	88 23       	and	r24, r24
     cce:	39 f7       	brne	.-50     	; 0xc9e <UART_voidSendString+0x14>
	{
		UART_voidSendByte(Copy_u8Str[Local_u8Iteration]);
		
		Local_u8Iteration++;
	}
}
     cd0:	0f 90       	pop	r0
     cd2:	0f 90       	pop	r0
     cd4:	0f 90       	pop	r0
     cd6:	cf 91       	pop	r28
     cd8:	df 91       	pop	r29
     cda:	08 95       	ret

00000cdc <UART_u8ReceiveByte>:

u8 UART_u8ReceiveByte(void)
{
     cdc:	df 93       	push	r29
     cde:	cf 93       	push	r28
     ce0:	cd b7       	in	r28, 0x3d	; 61
     ce2:	de b7       	in	r29, 0x3e	; 62

	while(GET_BIT(UCSRA , UCSRA_RXC) == 0);
     ce4:	eb e2       	ldi	r30, 0x2B	; 43
     ce6:	f0 e0       	ldi	r31, 0x00	; 0
     ce8:	80 81       	ld	r24, Z
     cea:	88 23       	and	r24, r24
     cec:	dc f7       	brge	.-10     	; 0xce4 <UART_u8ReceiveByte+0x8>
	return UDR ;
     cee:	ec e2       	ldi	r30, 0x2C	; 44
     cf0:	f0 e0       	ldi	r31, 0x00	; 0
     cf2:	80 81       	ld	r24, Z

}
     cf4:	cf 91       	pop	r28
     cf6:	df 91       	pop	r29
     cf8:	08 95       	ret

00000cfa <UART_voidReceiveString>:
void UART_voidReceiveString(u8 Copy_u8Str[],u8 Copy_u8Size)
{
     cfa:	df 93       	push	r29
     cfc:	cf 93       	push	r28
     cfe:	00 d0       	rcall	.+0      	; 0xd00 <UART_voidReceiveString+0x6>
     d00:	00 d0       	rcall	.+0      	; 0xd02 <UART_voidReceiveString+0x8>
     d02:	cd b7       	in	r28, 0x3d	; 61
     d04:	de b7       	in	r29, 0x3e	; 62
     d06:	9b 83       	std	Y+3, r25	; 0x03
     d08:	8a 83       	std	Y+2, r24	; 0x02
     d0a:	6c 83       	std	Y+4, r22	; 0x04
	u8 Local_u8Iteration = 0;
     d0c:	19 82       	std	Y+1, r1	; 0x01
    for (Local_u8Iteration=0;Local_u8Iteration<Copy_u8Size-1;Local_u8Iteration++)
     d0e:	19 82       	std	Y+1, r1	; 0x01
     d10:	14 c0       	rjmp	.+40     	; 0xd3a <UART_voidReceiveString+0x40>
    {
		while(GET_BIT(UCSRA , UCSRA_RXC) == 0);
     d12:	eb e2       	ldi	r30, 0x2B	; 43
     d14:	f0 e0       	ldi	r31, 0x00	; 0
     d16:	80 81       	ld	r24, Z
     d18:	88 23       	and	r24, r24
     d1a:	dc f7       	brge	.-10     	; 0xd12 <UART_voidReceiveString+0x18>
		Copy_u8Str[Local_u8Iteration] = UDR ;
     d1c:	89 81       	ldd	r24, Y+1	; 0x01
     d1e:	28 2f       	mov	r18, r24
     d20:	30 e0       	ldi	r19, 0x00	; 0
     d22:	8a 81       	ldd	r24, Y+2	; 0x02
     d24:	9b 81       	ldd	r25, Y+3	; 0x03
     d26:	dc 01       	movw	r26, r24
     d28:	a2 0f       	add	r26, r18
     d2a:	b3 1f       	adc	r27, r19
     d2c:	ec e2       	ldi	r30, 0x2C	; 44
     d2e:	f0 e0       	ldi	r31, 0x00	; 0
     d30:	80 81       	ld	r24, Z
     d32:	8c 93       	st	X, r24

}
void UART_voidReceiveString(u8 Copy_u8Str[],u8 Copy_u8Size)
{
	u8 Local_u8Iteration = 0;
    for (Local_u8Iteration=0;Local_u8Iteration<Copy_u8Size-1;Local_u8Iteration++)
     d34:	89 81       	ldd	r24, Y+1	; 0x01
     d36:	8f 5f       	subi	r24, 0xFF	; 255
     d38:	89 83       	std	Y+1, r24	; 0x01
     d3a:	89 81       	ldd	r24, Y+1	; 0x01
     d3c:	28 2f       	mov	r18, r24
     d3e:	30 e0       	ldi	r19, 0x00	; 0
     d40:	8c 81       	ldd	r24, Y+4	; 0x04
     d42:	88 2f       	mov	r24, r24
     d44:	90 e0       	ldi	r25, 0x00	; 0
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	28 17       	cp	r18, r24
     d4a:	39 07       	cpc	r19, r25
     d4c:	14 f3       	brlt	.-60     	; 0xd12 <UART_voidReceiveString+0x18>
    {
		while(GET_BIT(UCSRA , UCSRA_RXC) == 0);
		Copy_u8Str[Local_u8Iteration] = UDR ;
    }
	
}
     d4e:	0f 90       	pop	r0
     d50:	0f 90       	pop	r0
     d52:	0f 90       	pop	r0
     d54:	0f 90       	pop	r0
     d56:	cf 91       	pop	r28
     d58:	df 91       	pop	r29
     d5a:	08 95       	ret

00000d5c <__vector_13>:

void __vector_13(void) __attribute__((signal , used));
void __vector_13(void)
{
     d5c:	1f 92       	push	r1
     d5e:	0f 92       	push	r0
     d60:	0f b6       	in	r0, 0x3f	; 63
     d62:	0f 92       	push	r0
     d64:	11 24       	eor	r1, r1
     d66:	2f 93       	push	r18
     d68:	3f 93       	push	r19
     d6a:	4f 93       	push	r20
     d6c:	5f 93       	push	r21
     d6e:	6f 93       	push	r22
     d70:	7f 93       	push	r23
     d72:	8f 93       	push	r24
     d74:	9f 93       	push	r25
     d76:	af 93       	push	r26
     d78:	bf 93       	push	r27
     d7a:	ef 93       	push	r30
     d7c:	ff 93       	push	r31
     d7e:	df 93       	push	r29
     d80:	cf 93       	push	r28
     d82:	cd b7       	in	r28, 0x3d	; 61
     d84:	de b7       	in	r29, 0x3e	; 62
	CallBackReceive();
     d86:	e0 91 11 02 	lds	r30, 0x0211
     d8a:	f0 91 12 02 	lds	r31, 0x0212
     d8e:	09 95       	icall
}
     d90:	cf 91       	pop	r28
     d92:	df 91       	pop	r29
     d94:	ff 91       	pop	r31
     d96:	ef 91       	pop	r30
     d98:	bf 91       	pop	r27
     d9a:	af 91       	pop	r26
     d9c:	9f 91       	pop	r25
     d9e:	8f 91       	pop	r24
     da0:	7f 91       	pop	r23
     da2:	6f 91       	pop	r22
     da4:	5f 91       	pop	r21
     da6:	4f 91       	pop	r20
     da8:	3f 91       	pop	r19
     daa:	2f 91       	pop	r18
     dac:	0f 90       	pop	r0
     dae:	0f be       	out	0x3f, r0	; 63
     db0:	0f 90       	pop	r0
     db2:	1f 90       	pop	r1
     db4:	18 95       	reti

00000db6 <__vector_14>:

void __vector_14(void) __attribute__((signal , used));
void __vector_14(void)
{
     db6:	1f 92       	push	r1
     db8:	0f 92       	push	r0
     dba:	0f b6       	in	r0, 0x3f	; 63
     dbc:	0f 92       	push	r0
     dbe:	11 24       	eor	r1, r1
     dc0:	2f 93       	push	r18
     dc2:	3f 93       	push	r19
     dc4:	4f 93       	push	r20
     dc6:	5f 93       	push	r21
     dc8:	6f 93       	push	r22
     dca:	7f 93       	push	r23
     dcc:	8f 93       	push	r24
     dce:	9f 93       	push	r25
     dd0:	af 93       	push	r26
     dd2:	bf 93       	push	r27
     dd4:	ef 93       	push	r30
     dd6:	ff 93       	push	r31
     dd8:	df 93       	push	r29
     dda:	cf 93       	push	r28
     ddc:	cd b7       	in	r28, 0x3d	; 61
     dde:	de b7       	in	r29, 0x3e	; 62
	CallBackSend();
     de0:	e0 91 13 02 	lds	r30, 0x0213
     de4:	f0 91 14 02 	lds	r31, 0x0214
     de8:	09 95       	icall
}
     dea:	cf 91       	pop	r28
     dec:	df 91       	pop	r29
     dee:	ff 91       	pop	r31
     df0:	ef 91       	pop	r30
     df2:	bf 91       	pop	r27
     df4:	af 91       	pop	r26
     df6:	9f 91       	pop	r25
     df8:	8f 91       	pop	r24
     dfa:	7f 91       	pop	r23
     dfc:	6f 91       	pop	r22
     dfe:	5f 91       	pop	r21
     e00:	4f 91       	pop	r20
     e02:	3f 91       	pop	r19
     e04:	2f 91       	pop	r18
     e06:	0f 90       	pop	r0
     e08:	0f be       	out	0x3f, r0	; 63
     e0a:	0f 90       	pop	r0
     e0c:	1f 90       	pop	r1
     e0e:	18 95       	reti

00000e10 <TIMER0_vidInit>:

/*static pointer to function */
static void (*TIMER0_pvCallBackFunc)(void)=NULL ; 

void TIMER0_vidInit(void)
{
     e10:	df 93       	push	r29
     e12:	cf 93       	push	r28
     e14:	cd b7       	in	r28, 0x3d	; 61
     e16:	de b7       	in	r29, 0x3e	; 62
// 	/*choose CTC mode*/
// 	CLR_BIT(TCCR0,TCCR0_WGM00);
// 	SET_BIT(TCCR0,TCCR0_WGM01);
    
	/*choose fast PWM mode*/
	 SET_BIT(TCCR0,TCCR0_WGM00);
     e18:	a3 e5       	ldi	r26, 0x53	; 83
     e1a:	b0 e0       	ldi	r27, 0x00	; 0
     e1c:	e3 e5       	ldi	r30, 0x53	; 83
     e1e:	f0 e0       	ldi	r31, 0x00	; 0
     e20:	80 81       	ld	r24, Z
     e22:	80 64       	ori	r24, 0x40	; 64
     e24:	8c 93       	st	X, r24
	 SET_BIT(TCCR0,TCCR0_WGM01);
     e26:	a3 e5       	ldi	r26, 0x53	; 83
     e28:	b0 e0       	ldi	r27, 0x00	; 0
     e2a:	e3 e5       	ldi	r30, 0x53	; 83
     e2c:	f0 e0       	ldi	r31, 0x00	; 0
     e2e:	80 81       	ld	r24, Z
     e30:	88 60       	ori	r24, 0x08	; 8
     e32:	8c 93       	st	X, r24
	
	
	/*choose non inverted mode oc0 mode to
	                      set on top
						  clear on compare*/                 
	SET_BIT(TCCR0,TCCR0_COM01); 
     e34:	a3 e5       	ldi	r26, 0x53	; 83
     e36:	b0 e0       	ldi	r27, 0x00	; 0
     e38:	e3 e5       	ldi	r30, 0x53	; 83
     e3a:	f0 e0       	ldi	r31, 0x00	; 0
     e3c:	80 81       	ld	r24, Z
     e3e:	80 62       	ori	r24, 0x20	; 32
     e40:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,TCCR0_COM00);
     e42:	a3 e5       	ldi	r26, 0x53	; 83
     e44:	b0 e0       	ldi	r27, 0x00	; 0
     e46:	e3 e5       	ldi	r30, 0x53	; 83
     e48:	f0 e0       	ldi	r31, 0x00	; 0
     e4a:	80 81       	ld	r24, Z
     e4c:	8f 7e       	andi	r24, 0xEF	; 239
     e4e:	8c 93       	st	X, r24
	
	
	/*select prescaler division by 8 for duty cycle 25%*/
	CLR_BIT(TCCR0,TCCR0_CS00);
     e50:	a3 e5       	ldi	r26, 0x53	; 83
     e52:	b0 e0       	ldi	r27, 0x00	; 0
     e54:	e3 e5       	ldi	r30, 0x53	; 83
     e56:	f0 e0       	ldi	r31, 0x00	; 0
     e58:	80 81       	ld	r24, Z
     e5a:	8e 7f       	andi	r24, 0xFE	; 254
     e5c:	8c 93       	st	X, r24
	SET_BIT(TCCR0,TCCR0_CS01);
     e5e:	a3 e5       	ldi	r26, 0x53	; 83
     e60:	b0 e0       	ldi	r27, 0x00	; 0
     e62:	e3 e5       	ldi	r30, 0x53	; 83
     e64:	f0 e0       	ldi	r31, 0x00	; 0
     e66:	80 81       	ld	r24, Z
     e68:	82 60       	ori	r24, 0x02	; 2
     e6a:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,TCCR0_CS02);
     e6c:	a3 e5       	ldi	r26, 0x53	; 83
     e6e:	b0 e0       	ldi	r27, 0x00	; 0
     e70:	e3 e5       	ldi	r30, 0x53	; 83
     e72:	f0 e0       	ldi	r31, 0x00	; 0
     e74:	80 81       	ld	r24, Z
     e76:	8b 7f       	andi	r24, 0xFB	; 251
     e78:	8c 93       	st	X, r24
}
     e7a:	cf 91       	pop	r28
     e7c:	df 91       	pop	r29
     e7e:	08 95       	ret

00000e80 <TIMER0_vidSetCompMatchValue>:

void TIMER0_vidSetCompMatchValue(u8 copy_u8Value)
{
     e80:	df 93       	push	r29
     e82:	cf 93       	push	r28
     e84:	0f 92       	push	r0
     e86:	cd b7       	in	r28, 0x3d	; 61
     e88:	de b7       	in	r29, 0x3e	; 62
     e8a:	89 83       	std	Y+1, r24	; 0x01
	OCR0=copy_u8Value ;
     e8c:	ec e5       	ldi	r30, 0x5C	; 92
     e8e:	f0 e0       	ldi	r31, 0x00	; 0
     e90:	89 81       	ldd	r24, Y+1	; 0x01
     e92:	80 83       	st	Z, r24
}
     e94:	0f 90       	pop	r0
     e96:	cf 91       	pop	r28
     e98:	df 91       	pop	r29
     e9a:	08 95       	ret

00000e9c <TIMER_u8SetCallBack>:

u8 TIMER_u8SetCallBack(void (*copy_CallBackFunc)(void))
{
     e9c:	df 93       	push	r29
     e9e:	cf 93       	push	r28
     ea0:	00 d0       	rcall	.+0      	; 0xea2 <TIMER_u8SetCallBack+0x6>
     ea2:	0f 92       	push	r0
     ea4:	cd b7       	in	r28, 0x3d	; 61
     ea6:	de b7       	in	r29, 0x3e	; 62
     ea8:	9b 83       	std	Y+3, r25	; 0x03
     eaa:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErrorStaus= 0 ;
     eac:	19 82       	std	Y+1, r1	; 0x01
	if (copy_CallBackFunc!=NULL)
     eae:	8a 81       	ldd	r24, Y+2	; 0x02
     eb0:	9b 81       	ldd	r25, Y+3	; 0x03
     eb2:	00 97       	sbiw	r24, 0x00	; 0
     eb4:	39 f0       	breq	.+14     	; 0xec4 <TIMER_u8SetCallBack+0x28>
	{
		TIMER0_pvCallBackFunc= copy_CallBackFunc ; 
     eb6:	8a 81       	ldd	r24, Y+2	; 0x02
     eb8:	9b 81       	ldd	r25, Y+3	; 0x03
     eba:	90 93 01 02 	sts	0x0201, r25
     ebe:	80 93 00 02 	sts	0x0200, r24
     ec2:	02 c0       	rjmp	.+4      	; 0xec8 <TIMER_u8SetCallBack+0x2c>
	}
	else
	{
		Local_u8ErrorStaus = 1 ; 
     ec4:	81 e0       	ldi	r24, 0x01	; 1
     ec6:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorStaus ;
     ec8:	89 81       	ldd	r24, Y+1	; 0x01
}
     eca:	0f 90       	pop	r0
     ecc:	0f 90       	pop	r0
     ece:	0f 90       	pop	r0
     ed0:	cf 91       	pop	r28
     ed2:	df 91       	pop	r29
     ed4:	08 95       	ret

00000ed6 <TIMER1_vidInit>:


/*TIMER1 INITIALIZE*/
void TIMER1_vidInit(void)
{
     ed6:	df 93       	push	r29
     ed8:	cf 93       	push	r28
     eda:	cd b7       	in	r28, 0x3d	; 61
     edc:	de b7       	in	r29, 0x3e	; 62
	
	
   /*select normal mode,prescaler timer1 divide by 8 */
    CLR_BIT(TCCR1B,TCCR1B_CS10);
     ede:	ae e4       	ldi	r26, 0x4E	; 78
     ee0:	b0 e0       	ldi	r27, 0x00	; 0
     ee2:	ee e4       	ldi	r30, 0x4E	; 78
     ee4:	f0 e0       	ldi	r31, 0x00	; 0
     ee6:	80 81       	ld	r24, Z
     ee8:	8e 7f       	andi	r24, 0xFE	; 254
     eea:	8c 93       	st	X, r24
   	SET_BIT(TCCR1B,TCCR1B_CS11);
     eec:	ae e4       	ldi	r26, 0x4E	; 78
     eee:	b0 e0       	ldi	r27, 0x00	; 0
     ef0:	ee e4       	ldi	r30, 0x4E	; 78
     ef2:	f0 e0       	ldi	r31, 0x00	; 0
     ef4:	80 81       	ld	r24, Z
     ef6:	82 60       	ori	r24, 0x02	; 2
     ef8:	8c 93       	st	X, r24
    CLR_BIT(TCCR1B,TCCR1B_CS12);
     efa:	ae e4       	ldi	r26, 0x4E	; 78
     efc:	b0 e0       	ldi	r27, 0x00	; 0
     efe:	ee e4       	ldi	r30, 0x4E	; 78
     f00:	f0 e0       	ldi	r31, 0x00	; 0
     f02:	80 81       	ld	r24, Z
     f04:	8b 7f       	andi	r24, 0xFB	; 251
     f06:	8c 93       	st	X, r24
// 	select prescaler divided by 8	CLR_BIT(TCCR1B,TCCR1B_CS10);
// 	SET_BIT(TCCR1B,TCCR1B_CS11);
// 	CLR_BIT(TCCR1B,TCCR1B_CS12); 
	

}
     f08:	cf 91       	pop	r28
     f0a:	df 91       	pop	r29
     f0c:	08 95       	ret

00000f0e <TIMER1_vidSetChannel_A_CompMatchValue>:

/*TIMER1 set COMPARE MAtCH REGISTER*/
void TIMER1_vidSetChannel_A_CompMatchValue(u16 Copy_u16ComValue)
{
     f0e:	df 93       	push	r29
     f10:	cf 93       	push	r28
     f12:	00 d0       	rcall	.+0      	; 0xf14 <TIMER1_vidSetChannel_A_CompMatchValue+0x6>
     f14:	cd b7       	in	r28, 0x3d	; 61
     f16:	de b7       	in	r29, 0x3e	; 62
     f18:	9a 83       	std	Y+2, r25	; 0x02
     f1a:	89 83       	std	Y+1, r24	; 0x01
	OCR1A=(u16)Copy_u16ComValue ; 
     f1c:	ea e4       	ldi	r30, 0x4A	; 74
     f1e:	f0 e0       	ldi	r31, 0x00	; 0
     f20:	89 81       	ldd	r24, Y+1	; 0x01
     f22:	9a 81       	ldd	r25, Y+2	; 0x02
     f24:	91 83       	std	Z+1, r25	; 0x01
     f26:	80 83       	st	Z, r24
}
     f28:	0f 90       	pop	r0
     f2a:	0f 90       	pop	r0
     f2c:	cf 91       	pop	r28
     f2e:	df 91       	pop	r29
     f30:	08 95       	ret

00000f32 <TIMER1_vidSetInputCaptureValue>:

/*TIMER1 SET ICR1 INPUTCAPTURE REGISTER */
void TIMER1_vidSetInputCaptureValue(u16 copy_u16TopValue)
{
     f32:	df 93       	push	r29
     f34:	cf 93       	push	r28
     f36:	00 d0       	rcall	.+0      	; 0xf38 <TIMER1_vidSetInputCaptureValue+0x6>
     f38:	cd b7       	in	r28, 0x3d	; 61
     f3a:	de b7       	in	r29, 0x3e	; 62
     f3c:	9a 83       	std	Y+2, r25	; 0x02
     f3e:	89 83       	std	Y+1, r24	; 0x01
	ICR1 = (u16)copy_u16TopValue ; 
     f40:	e6 e4       	ldi	r30, 0x46	; 70
     f42:	f0 e0       	ldi	r31, 0x00	; 0
     f44:	89 81       	ldd	r24, Y+1	; 0x01
     f46:	9a 81       	ldd	r25, Y+2	; 0x02
     f48:	91 83       	std	Z+1, r25	; 0x01
     f4a:	80 83       	st	Z, r24
}
     f4c:	0f 90       	pop	r0
     f4e:	0f 90       	pop	r0
     f50:	cf 91       	pop	r28
     f52:	df 91       	pop	r29
     f54:	08 95       	ret

00000f56 <TIMER1_vidSetTimerValue>:

void TIMER1_vidSetTimerValue(u16 copy_TimerValue)
{
     f56:	df 93       	push	r29
     f58:	cf 93       	push	r28
     f5a:	00 d0       	rcall	.+0      	; 0xf5c <TIMER1_vidSetTimerValue+0x6>
     f5c:	cd b7       	in	r28, 0x3d	; 61
     f5e:	de b7       	in	r29, 0x3e	; 62
     f60:	9a 83       	std	Y+2, r25	; 0x02
     f62:	89 83       	std	Y+1, r24	; 0x01
	TCNT1= copy_TimerValue; 
     f64:	ec e4       	ldi	r30, 0x4C	; 76
     f66:	f0 e0       	ldi	r31, 0x00	; 0
     f68:	89 81       	ldd	r24, Y+1	; 0x01
     f6a:	9a 81       	ldd	r25, Y+2	; 0x02
     f6c:	91 83       	std	Z+1, r25	; 0x01
     f6e:	80 83       	st	Z, r24
}
     f70:	0f 90       	pop	r0
     f72:	0f 90       	pop	r0
     f74:	cf 91       	pop	r28
     f76:	df 91       	pop	r29
     f78:	08 95       	ret

00000f7a <TIMER1_u16ReadTimerValue>:

u16 TIMER1_u16ReadTimerValue(void)
{
     f7a:	df 93       	push	r29
     f7c:	cf 93       	push	r28
     f7e:	cd b7       	in	r28, 0x3d	; 61
     f80:	de b7       	in	r29, 0x3e	; 62
	return TCNT1 ;
     f82:	ec e4       	ldi	r30, 0x4C	; 76
     f84:	f0 e0       	ldi	r31, 0x00	; 0
     f86:	80 81       	ld	r24, Z
     f88:	91 81       	ldd	r25, Z+1	; 0x01
}
     f8a:	cf 91       	pop	r28
     f8c:	df 91       	pop	r29
     f8e:	08 95       	ret

00000f90 <__vector_10>:


void __vector_10(void) __attribute__((signal)); 
void __vector_10(void) 
{
     f90:	1f 92       	push	r1
     f92:	0f 92       	push	r0
     f94:	0f b6       	in	r0, 0x3f	; 63
     f96:	0f 92       	push	r0
     f98:	11 24       	eor	r1, r1
     f9a:	2f 93       	push	r18
     f9c:	3f 93       	push	r19
     f9e:	4f 93       	push	r20
     fa0:	5f 93       	push	r21
     fa2:	6f 93       	push	r22
     fa4:	7f 93       	push	r23
     fa6:	8f 93       	push	r24
     fa8:	9f 93       	push	r25
     faa:	af 93       	push	r26
     fac:	bf 93       	push	r27
     fae:	ef 93       	push	r30
     fb0:	ff 93       	push	r31
     fb2:	df 93       	push	r29
     fb4:	cf 93       	push	r28
     fb6:	cd b7       	in	r28, 0x3d	; 61
     fb8:	de b7       	in	r29, 0x3e	; 62
	if (TIMER0_pvCallBackFunc!=NULL)
     fba:	80 91 00 02 	lds	r24, 0x0200
     fbe:	90 91 01 02 	lds	r25, 0x0201
     fc2:	00 97       	sbiw	r24, 0x00	; 0
     fc4:	29 f0       	breq	.+10     	; 0xfd0 <__vector_10+0x40>
	{
		TIMER0_pvCallBackFunc(); 
     fc6:	e0 91 00 02 	lds	r30, 0x0200
     fca:	f0 91 01 02 	lds	r31, 0x0201
     fce:	09 95       	icall
	}
}
     fd0:	cf 91       	pop	r28
     fd2:	df 91       	pop	r29
     fd4:	ff 91       	pop	r31
     fd6:	ef 91       	pop	r30
     fd8:	bf 91       	pop	r27
     fda:	af 91       	pop	r26
     fdc:	9f 91       	pop	r25
     fde:	8f 91       	pop	r24
     fe0:	7f 91       	pop	r23
     fe2:	6f 91       	pop	r22
     fe4:	5f 91       	pop	r21
     fe6:	4f 91       	pop	r20
     fe8:	3f 91       	pop	r19
     fea:	2f 91       	pop	r18
     fec:	0f 90       	pop	r0
     fee:	0f be       	out	0x3f, r0	; 63
     ff0:	0f 90       	pop	r0
     ff2:	1f 90       	pop	r1
     ff4:	18 95       	reti

00000ff6 <PORT_vidInit>:
#include "PORT_register.h"
#include "PORT_config.h"
#include "PORT_private.h"

void PORT_vidInit(void)
{
     ff6:	df 93       	push	r29
     ff8:	cf 93       	push	r28
     ffa:	cd b7       	in	r28, 0x3d	; 61
     ffc:	de b7       	in	r29, 0x3e	; 62
	/*set direction of all ports INPUT or OUTPUT*/
	 DDRA=PORTA_DIR;
     ffe:	ea e3       	ldi	r30, 0x3A	; 58
    1000:	f0 e0       	ldi	r31, 0x00	; 0
    1002:	82 ef       	ldi	r24, 0xF2	; 242
    1004:	80 83       	st	Z, r24
	 
	 DDRB=PORTB_DIR;
    1006:	e7 e3       	ldi	r30, 0x37	; 55
    1008:	f0 e0       	ldi	r31, 0x00	; 0
    100a:	8f ef       	ldi	r24, 0xFF	; 255
    100c:	80 83       	st	Z, r24
	 
	 DDRC=PORTC_DIR;
    100e:	e4 e3       	ldi	r30, 0x34	; 52
    1010:	f0 e0       	ldi	r31, 0x00	; 0
    1012:	8b ef       	ldi	r24, 0xFB	; 251
    1014:	80 83       	st	Z, r24
	 
	 DDRD=PORTD_DIR;
    1016:	e1 e3       	ldi	r30, 0x31	; 49
    1018:	f0 e0       	ldi	r31, 0x00	; 0
    101a:	82 e0       	ldi	r24, 0x02	; 2
    101c:	80 83       	st	Z, r24
	 
	 /*set value of all ports HIGH or LOW*/
	 PORTA=PORTA_INITIAL_VALUE;
    101e:	eb e3       	ldi	r30, 0x3B	; 59
    1020:	f0 e0       	ldi	r31, 0x00	; 0
    1022:	82 e0       	ldi	r24, 0x02	; 2
    1024:	80 83       	st	Z, r24
	 
	 PORTB=PORTB_INITIAL_VALUE;
    1026:	e8 e3       	ldi	r30, 0x38	; 56
    1028:	f0 e0       	ldi	r31, 0x00	; 0
    102a:	10 82       	st	Z, r1
	 
	 PORTC=PORTC_INITIAL_VALUE;
    102c:	e5 e3       	ldi	r30, 0x35	; 53
    102e:	f0 e0       	ldi	r31, 0x00	; 0
    1030:	10 82       	st	Z, r1
	 
	 PORTD=PORTD_INITIAL_VALUE;
    1032:	e2 e3       	ldi	r30, 0x32	; 50
    1034:	f0 e0       	ldi	r31, 0x00	; 0
    1036:	84 ef       	ldi	r24, 0xF4	; 244
    1038:	80 83       	st	Z, r24
	
    103a:	cf 91       	pop	r28
    103c:	df 91       	pop	r29
    103e:	08 95       	ret

00001040 <i2c_init>:

#include "i2c_MT.h"


void i2c_init(void)
{
    1040:	df 93       	push	r29
    1042:	cf 93       	push	r28
    1044:	cd b7       	in	r28, 0x3d	; 61
    1046:	de b7       	in	r29, 0x3e	; 62
	TWSR = 0x00;         // make prescaler =1
    1048:	e1 e2       	ldi	r30, 0x21	; 33
    104a:	f0 e0       	ldi	r31, 0x00	; 0
    104c:	10 82       	st	Z, r1
	TWBR = (uint8_t)I2C_TWBR_VAL;         
    104e:	e0 e2       	ldi	r30, 0x20	; 32
    1050:	f0 e0       	ldi	r31, 0x00	; 0
    1052:	88 e0       	ldi	r24, 0x08	; 8
    1054:	80 83       	st	Z, r24
	TWCR = (1<<TWEN);     // Enable I2C Module
    1056:	e6 e5       	ldi	r30, 0x56	; 86
    1058:	f0 e0       	ldi	r31, 0x00	; 0
    105a:	84 e0       	ldi	r24, 0x04	; 4
    105c:	80 83       	st	Z, r24
}
    105e:	cf 91       	pop	r28
    1060:	df 91       	pop	r29
    1062:	08 95       	ret

00001064 <i2c_start>:

void i2c_start(void)
{
    1064:	df 93       	push	r29
    1066:	cf 93       	push	r28
    1068:	cd b7       	in	r28, 0x3d	; 61
    106a:	de b7       	in	r29, 0x3e	; 62
	/*
	 * clear interrupt flag,start condition bit and enable module i2c
	 */
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    106c:	e6 e5       	ldi	r30, 0x56	; 86
    106e:	f0 e0       	ldi	r31, 0x00	; 0
    1070:	84 ea       	ldi	r24, 0xA4	; 164
    1072:	80 83       	st	Z, r24
	/*
	 * Waiting until the start condition is transmitted
	 */
	while ((TWCR&(1<<TWINT))==0);
    1074:	e6 e5       	ldi	r30, 0x56	; 86
    1076:	f0 e0       	ldi	r31, 0x00	; 0
    1078:	80 81       	ld	r24, Z
    107a:	88 23       	and	r24, r24
    107c:	dc f7       	brge	.-10     	; 0x1074 <i2c_start+0x10>
}
    107e:	cf 91       	pop	r28
    1080:	df 91       	pop	r29
    1082:	08 95       	ret

00001084 <i2c_stop>:


void i2c_stop(void)
{
    1084:	df 93       	push	r29
    1086:	cf 93       	push	r28
    1088:	cd b7       	in	r28, 0x3d	; 61
    108a:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Enable stop bit
	 */
	TWCR = (1<< TWINT) | (1<< TWEN) | (1<<TWSTO);
    108c:	e6 e5       	ldi	r30, 0x56	; 86
    108e:	f0 e0       	ldi	r31, 0x00	; 0
    1090:	84 e9       	ldi	r24, 0x94	; 148
    1092:	80 83       	st	Z, r24
	/*
	 * Waiting until the start condition is transmitted
	 */
	//while ((TWCR&(1<<TWINT))==0);

}
    1094:	cf 91       	pop	r28
    1096:	df 91       	pop	r29
    1098:	08 95       	ret

0000109a <i2c_write>:

void i2c_write (unsigned char data)
{
    109a:	df 93       	push	r29
    109c:	cf 93       	push	r28
    109e:	0f 92       	push	r0
    10a0:	cd b7       	in	r28, 0x3d	; 61
    10a2:	de b7       	in	r29, 0x3e	; 62
    10a4:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * Put the data in TW data register
	 */
	TWDR = data;
    10a6:	e3 e2       	ldi	r30, 0x23	; 35
    10a8:	f0 e0       	ldi	r31, 0x00	; 0
    10aa:	89 81       	ldd	r24, Y+1	; 0x01
    10ac:	80 83       	st	Z, r24
	/*
	 * To start sending Byte
	 */
	TWCR = (1<<TWINT) | (1<< TWEN);
    10ae:	e6 e5       	ldi	r30, 0x56	; 86
    10b0:	f0 e0       	ldi	r31, 0x00	; 0
    10b2:	84 e8       	ldi	r24, 0x84	; 132
    10b4:	80 83       	st	Z, r24
	/*
	 *waiting until the byte is transmitted completely
	 */
	while ((TWCR & (1<< TWINT)) == 0);
    10b6:	e6 e5       	ldi	r30, 0x56	; 86
    10b8:	f0 e0       	ldi	r31, 0x00	; 0
    10ba:	80 81       	ld	r24, Z
    10bc:	88 23       	and	r24, r24
    10be:	dc f7       	brge	.-10     	; 0x10b6 <i2c_write+0x1c>
}
    10c0:	0f 90       	pop	r0
    10c2:	cf 91       	pop	r28
    10c4:	df 91       	pop	r29
    10c6:	08 95       	ret

000010c8 <i2c_read>:



unsigned char i2c_read(unsigned char ACK)
{
    10c8:	df 93       	push	r29
    10ca:	cf 93       	push	r28
    10cc:	0f 92       	push	r0
    10ce:	cd b7       	in	r28, 0x3d	; 61
    10d0:	de b7       	in	r29, 0x3e	; 62
    10d2:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * To start receiving Byte
	 */
	TWCR = (1<< TWINT) | (1<< TWEN) | (ACK<< TWEA);
    10d4:	e6 e5       	ldi	r30, 0x56	; 86
    10d6:	f0 e0       	ldi	r31, 0x00	; 0
    10d8:	89 81       	ldd	r24, Y+1	; 0x01
    10da:	88 2f       	mov	r24, r24
    10dc:	90 e0       	ldi	r25, 0x00	; 0
    10de:	00 24       	eor	r0, r0
    10e0:	96 95       	lsr	r25
    10e2:	87 95       	ror	r24
    10e4:	07 94       	ror	r0
    10e6:	96 95       	lsr	r25
    10e8:	87 95       	ror	r24
    10ea:	07 94       	ror	r0
    10ec:	98 2f       	mov	r25, r24
    10ee:	80 2d       	mov	r24, r0
    10f0:	84 68       	ori	r24, 0x84	; 132
    10f2:	80 83       	st	Z, r24
	/*
	 *waiting until the byte is transmitted completely
	 */
	while ((TWCR & (1<< TWINT)) == 0);
    10f4:	e6 e5       	ldi	r30, 0x56	; 86
    10f6:	f0 e0       	ldi	r31, 0x00	; 0
    10f8:	80 81       	ld	r24, Z
    10fa:	88 23       	and	r24, r24
    10fc:	dc f7       	brge	.-10     	; 0x10f4 <i2c_read+0x2c>
	/*
	 * Return the data read
	 */
	
	return TWDR;
    10fe:	e3 e2       	ldi	r30, 0x23	; 35
    1100:	f0 e0       	ldi	r31, 0x00	; 0
    1102:	80 81       	ld	r24, Z
	
}
    1104:	0f 90       	pop	r0
    1106:	cf 91       	pop	r28
    1108:	df 91       	pop	r29
    110a:	08 95       	ret

0000110c <i2c_slave_init>:


void i2c_slave_init(unsigned char My_Address)
{
    110c:	df 93       	push	r29
    110e:	cf 93       	push	r28
    1110:	0f 92       	push	r0
    1112:	cd b7       	in	r28, 0x3d	; 61
    1114:	de b7       	in	r29, 0x3e	; 62
    1116:	89 83       	std	Y+1, r24	; 0x01
	/* initiate the slave address */ 
	TWAR = My_Address;
    1118:	e2 e2       	ldi	r30, 0x22	; 34
    111a:	f0 e0       	ldi	r31, 0x00	; 0
    111c:	89 81       	ldd	r24, Y+1	; 0x01
    111e:	80 83       	st	Z, r24
	/* clear interrupt flag,start condition bit and enable module i2c */ 
	TWCR = (1<<TWEA) | (1<<TWINT) | (1<<TWEN);
    1120:	e6 e5       	ldi	r30, 0x56	; 86
    1122:	f0 e0       	ldi	r31, 0x00	; 0
    1124:	84 ec       	ldi	r24, 0xC4	; 196
    1126:	80 83       	st	Z, r24
}
    1128:	0f 90       	pop	r0
    112a:	cf 91       	pop	r28
    112c:	df 91       	pop	r29
    112e:	08 95       	ret

00001130 <i2c_slave_available>:

unsigned char i2c_slave_available()
{
    1130:	df 93       	push	r29
    1132:	cf 93       	push	r28
    1134:	cd b7       	in	r28, 0x3d	; 61
    1136:	de b7       	in	r29, 0x3e	; 62
	TWCR |= (1<<TWINT) | (1<<TWEN)| (1<<TWEA);
    1138:	a6 e5       	ldi	r26, 0x56	; 86
    113a:	b0 e0       	ldi	r27, 0x00	; 0
    113c:	e6 e5       	ldi	r30, 0x56	; 86
    113e:	f0 e0       	ldi	r31, 0x00	; 0
    1140:	80 81       	ld	r24, Z
    1142:	84 6c       	ori	r24, 0xC4	; 196
    1144:	8c 93       	st	X, r24
	while (!(TWCR & (1<<TWINT)));
    1146:	e6 e5       	ldi	r30, 0x56	; 86
    1148:	f0 e0       	ldi	r31, 0x00	; 0
    114a:	80 81       	ld	r24, Z
    114c:	88 23       	and	r24, r24
    114e:	dc f7       	brge	.-10     	; 0x1146 <i2c_slave_available+0x16>
	return ((TWSR & 0xF8));
    1150:	e1 e2       	ldi	r30, 0x21	; 33
    1152:	f0 e0       	ldi	r31, 0x00	; 0
    1154:	80 81       	ld	r24, Z
    1156:	88 7f       	andi	r24, 0xF8	; 248
}
    1158:	cf 91       	pop	r28
    115a:	df 91       	pop	r29
    115c:	08 95       	ret

0000115e <i2c_get_status>:

uint8_t i2c_get_status()
{
    115e:	df 93       	push	r29
    1160:	cf 93       	push	r28
    1162:	cd b7       	in	r28, 0x3d	; 61
    1164:	de b7       	in	r29, 0x3e	; 62
	while (!(TWCR & (1<<TWINT)));
    1166:	e6 e5       	ldi	r30, 0x56	; 86
    1168:	f0 e0       	ldi	r31, 0x00	; 0
    116a:	80 81       	ld	r24, Z
    116c:	88 23       	and	r24, r24
    116e:	dc f7       	brge	.-10     	; 0x1166 <i2c_get_status+0x8>
	return ((TWSR & 0xF8));
    1170:	e1 e2       	ldi	r30, 0x21	; 33
    1172:	f0 e0       	ldi	r31, 0x00	; 0
    1174:	80 81       	ld	r24, Z
    1176:	88 7f       	andi	r24, 0xF8	; 248
    1178:	cf 91       	pop	r28
    117a:	df 91       	pop	r29
    117c:	08 95       	ret

0000117e <GIE_vidEnable>:

#include "GIE_interface.h"
#include "GIE_register.h"

void GIE_vidEnable(void)
{
    117e:	df 93       	push	r29
    1180:	cf 93       	push	r28
    1182:	cd b7       	in	r28, 0x3d	; 61
    1184:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,SREG_I);
    1186:	af e5       	ldi	r26, 0x5F	; 95
    1188:	b0 e0       	ldi	r27, 0x00	; 0
    118a:	ef e5       	ldi	r30, 0x5F	; 95
    118c:	f0 e0       	ldi	r31, 0x00	; 0
    118e:	80 81       	ld	r24, Z
    1190:	80 68       	ori	r24, 0x80	; 128
    1192:	8c 93       	st	X, r24
}
    1194:	cf 91       	pop	r28
    1196:	df 91       	pop	r29
    1198:	08 95       	ret

0000119a <GIE_vidDisable>:

void GIE_vidDisable(void)
{
    119a:	df 93       	push	r29
    119c:	cf 93       	push	r28
    119e:	cd b7       	in	r28, 0x3d	; 61
    11a0:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,SREG_I);
    11a2:	af e5       	ldi	r26, 0x5F	; 95
    11a4:	b0 e0       	ldi	r27, 0x00	; 0
    11a6:	ef e5       	ldi	r30, 0x5F	; 95
    11a8:	f0 e0       	ldi	r31, 0x00	; 0
    11aa:	80 81       	ld	r24, Z
    11ac:	8f 77       	andi	r24, 0x7F	; 127
    11ae:	8c 93       	st	X, r24
}
    11b0:	cf 91       	pop	r28
    11b2:	df 91       	pop	r29
    11b4:	08 95       	ret

000011b6 <EXTI_vidInt0Init>:
void(*EXTI_pvINT2func)(void)= NULL ;/*global pointer to function to hold INT2 ISR address*/


/*function to initiate interrupt INT0  */
void EXTI_vidInt0Init(void)
{
    11b6:	df 93       	push	r29
    11b8:	cf 93       	push	r28
    11ba:	cd b7       	in	r28, 0x3d	; 61
    11bc:	de b7       	in	r29, 0x3e	; 62
	#elif INT0_SENSE == ON_CHANGE
		SET_BIT(MCUCR,MCUCR_ISC00);
		CLR_BIT(MCUCR,MCUCR_ISC01);
		
	#elif INT0_SENSE == FALLING_EDGE
		CLR_BIT(MCUCR,MCUCR_ISC00);
    11be:	a5 e5       	ldi	r26, 0x55	; 85
    11c0:	b0 e0       	ldi	r27, 0x00	; 0
    11c2:	e5 e5       	ldi	r30, 0x55	; 85
    11c4:	f0 e0       	ldi	r31, 0x00	; 0
    11c6:	80 81       	ld	r24, Z
    11c8:	8e 7f       	andi	r24, 0xFE	; 254
    11ca:	8c 93       	st	X, r24
		SET_BIT(MCUCR,MCUCR_ISC01);
    11cc:	a5 e5       	ldi	r26, 0x55	; 85
    11ce:	b0 e0       	ldi	r27, 0x00	; 0
    11d0:	e5 e5       	ldi	r30, 0x55	; 85
    11d2:	f0 e0       	ldi	r31, 0x00	; 0
    11d4:	80 81       	ld	r24, Z
    11d6:	82 60       	ori	r24, 0x02	; 2
    11d8:	8c 93       	st	X, r24
		#error "Wrong INT0_SENSE configuration option"
	
	#endif
	/*2-check peripheral interrupt enable initial state */	
	#if INT0_INITIAL_STATE == ENABLED
		SET_BIT(GICR,GICR_INT0);
    11da:	ab e5       	ldi	r26, 0x5B	; 91
    11dc:	b0 e0       	ldi	r27, 0x00	; 0
    11de:	eb e5       	ldi	r30, 0x5B	; 91
    11e0:	f0 e0       	ldi	r31, 0x00	; 0
    11e2:	80 81       	ld	r24, Z
    11e4:	80 64       	ori	r24, 0x40	; 64
    11e6:	8c 93       	st	X, r24
		CLR_BIT(GICR,GICR_INT0);
	#else
		#error "Wrong INT0_INITIAL_STATE configuration"
	#endif
		
}
    11e8:	cf 91       	pop	r28
    11ea:	df 91       	pop	r29
    11ec:	08 95       	ret

000011ee <EXTI_vidInt1Init>:



/*function to initiate interrupt INT1 */
void EXTI_vidInt1Init(void)
{
    11ee:	df 93       	push	r29
    11f0:	cf 93       	push	r28
    11f2:	cd b7       	in	r28, 0x3d	; 61
    11f4:	de b7       	in	r29, 0x3e	; 62
	#elif INT1_SENSE == ON_CHANGE
		  SET_BIT(MCUCR,MCUCR_ISC10);
		  CLR_BIT(MCUCR,MCUCR_ISC11);
		  
	#elif INT1_SENSE == FALLING_EDGE
		  CLR_BIT(MCUCR,MCUCR_ISC10);
    11f6:	a5 e5       	ldi	r26, 0x55	; 85
    11f8:	b0 e0       	ldi	r27, 0x00	; 0
    11fa:	e5 e5       	ldi	r30, 0x55	; 85
    11fc:	f0 e0       	ldi	r31, 0x00	; 0
    11fe:	80 81       	ld	r24, Z
    1200:	8b 7f       	andi	r24, 0xFB	; 251
    1202:	8c 93       	st	X, r24
		  SET_BIT(MCUCR,MCUCR_ISC11);
    1204:	a5 e5       	ldi	r26, 0x55	; 85
    1206:	b0 e0       	ldi	r27, 0x00	; 0
    1208:	e5 e5       	ldi	r30, 0x55	; 85
    120a:	f0 e0       	ldi	r31, 0x00	; 0
    120c:	80 81       	ld	r24, Z
    120e:	88 60       	ori	r24, 0x08	; 8
    1210:	8c 93       	st	X, r24
	
	/*2-check peripheral interrupt enable initial state */	
	#if INT1_INITIAL_STATE == ENABLED 
		SET_BIT(GICR,GICR_INT1); 
	#elif INT1_INITIAL_STATE == DISABLED
		CLR_BIT(GICR,GICR_INT1);
    1212:	ab e5       	ldi	r26, 0x5B	; 91
    1214:	b0 e0       	ldi	r27, 0x00	; 0
    1216:	eb e5       	ldi	r30, 0x5B	; 91
    1218:	f0 e0       	ldi	r31, 0x00	; 0
    121a:	80 81       	ld	r24, Z
    121c:	8f 77       	andi	r24, 0x7F	; 127
    121e:	8c 93       	st	X, r24
	#else 
		#error "wrong INT1_INITIAL_STATE configuration"
	#endif
}
    1220:	cf 91       	pop	r28
    1222:	df 91       	pop	r29
    1224:	08 95       	ret

00001226 <EXTI_vidInt2Init>:



/*function to initiate interrupt INT2 */
void EXTI_vidInt2Init(void)
{
    1226:	df 93       	push	r29
    1228:	cf 93       	push	r28
    122a:	cd b7       	in	r28, 0x3d	; 61
    122c:	de b7       	in	r29, 0x3e	; 62
	/*1- check INT2 sense control*/
	#if INT2_SENSE == RISING_EDGE 
		SET_BIT(MCUCSR,MCUCSR_ISC2);
	#elif INT2_SENSE == FALLING_EDGE
        CLR_BIT(MCUCSR,MCUCSR_ISC2);
    122e:	a4 e5       	ldi	r26, 0x54	; 84
    1230:	b0 e0       	ldi	r27, 0x00	; 0
    1232:	e4 e5       	ldi	r30, 0x54	; 84
    1234:	f0 e0       	ldi	r31, 0x00	; 0
    1236:	80 81       	ld	r24, Z
    1238:	8f 7b       	andi	r24, 0xBF	; 191
    123a:	8c 93       	st	X, r24
	
	/*2-check peripheral interrupt enable initial state */
	#if INT2_INITIAL_STATE == ENABLED
		SET_BIT(GICR,GICR_INT2);
	#elif INT2_INITIAL_STATE == DISABLED 
		CLR_BIT(GICR,GICR_INT2);
    123c:	ab e5       	ldi	r26, 0x5B	; 91
    123e:	b0 e0       	ldi	r27, 0x00	; 0
    1240:	eb e5       	ldi	r30, 0x5B	; 91
    1242:	f0 e0       	ldi	r31, 0x00	; 0
    1244:	80 81       	ld	r24, Z
    1246:	8f 7d       	andi	r24, 0xDF	; 223
    1248:	8c 93       	st	X, r24
	#else 
		#error "worng INT2_INITIAL_STATE configuration "
	#endif
}
    124a:	cf 91       	pop	r28
    124c:	df 91       	pop	r29
    124e:	08 95       	ret

00001250 <EXTI_u8Int0SetSenseControl>:


u8 EXTI_u8Int0SetSenseControl(u8 copy_u8Int0Sense)
{
    1250:	df 93       	push	r29
    1252:	cf 93       	push	r28
    1254:	00 d0       	rcall	.+0      	; 0x1256 <EXTI_u8Int0SetSenseControl+0x6>
    1256:	00 d0       	rcall	.+0      	; 0x1258 <EXTI_u8Int0SetSenseControl+0x8>
    1258:	cd b7       	in	r28, 0x3d	; 61
    125a:	de b7       	in	r29, 0x3e	; 62
    125c:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErrorState = Ok ;
    125e:	19 82       	std	Y+1, r1	; 0x01
	 switch(copy_u8Int0Sense)
    1260:	8a 81       	ldd	r24, Y+2	; 0x02
    1262:	28 2f       	mov	r18, r24
    1264:	30 e0       	ldi	r19, 0x00	; 0
    1266:	3c 83       	std	Y+4, r19	; 0x04
    1268:	2b 83       	std	Y+3, r18	; 0x03
    126a:	8b 81       	ldd	r24, Y+3	; 0x03
    126c:	9c 81       	ldd	r25, Y+4	; 0x04
    126e:	82 30       	cpi	r24, 0x02	; 2
    1270:	91 05       	cpc	r25, r1
    1272:	29 f1       	breq	.+74     	; 0x12be <EXTI_u8Int0SetSenseControl+0x6e>
    1274:	2b 81       	ldd	r18, Y+3	; 0x03
    1276:	3c 81       	ldd	r19, Y+4	; 0x04
    1278:	23 30       	cpi	r18, 0x03	; 3
    127a:	31 05       	cpc	r19, r1
    127c:	34 f4       	brge	.+12     	; 0x128a <EXTI_u8Int0SetSenseControl+0x3a>
    127e:	8b 81       	ldd	r24, Y+3	; 0x03
    1280:	9c 81       	ldd	r25, Y+4	; 0x04
    1282:	81 30       	cpi	r24, 0x01	; 1
    1284:	91 05       	cpc	r25, r1
    1286:	61 f0       	breq	.+24     	; 0x12a0 <EXTI_u8Int0SetSenseControl+0x50>
    1288:	47 c0       	rjmp	.+142    	; 0x1318 <EXTI_u8Int0SetSenseControl+0xc8>
    128a:	2b 81       	ldd	r18, Y+3	; 0x03
    128c:	3c 81       	ldd	r19, Y+4	; 0x04
    128e:	23 30       	cpi	r18, 0x03	; 3
    1290:	31 05       	cpc	r19, r1
    1292:	21 f1       	breq	.+72     	; 0x12dc <EXTI_u8Int0SetSenseControl+0x8c>
    1294:	8b 81       	ldd	r24, Y+3	; 0x03
    1296:	9c 81       	ldd	r25, Y+4	; 0x04
    1298:	84 30       	cpi	r24, 0x04	; 4
    129a:	91 05       	cpc	r25, r1
    129c:	71 f1       	breq	.+92     	; 0x12fa <EXTI_u8Int0SetSenseControl+0xaa>
    129e:	3c c0       	rjmp	.+120    	; 0x1318 <EXTI_u8Int0SetSenseControl+0xc8>
	 {
		 case  LOW_LEVEL: CLR_BIT(MCUCR,MCUCR_ISC00);CLR_BIT(MCUCR,MCUCR_ISC01);break; 
    12a0:	a5 e5       	ldi	r26, 0x55	; 85
    12a2:	b0 e0       	ldi	r27, 0x00	; 0
    12a4:	e5 e5       	ldi	r30, 0x55	; 85
    12a6:	f0 e0       	ldi	r31, 0x00	; 0
    12a8:	80 81       	ld	r24, Z
    12aa:	8e 7f       	andi	r24, 0xFE	; 254
    12ac:	8c 93       	st	X, r24
    12ae:	a5 e5       	ldi	r26, 0x55	; 85
    12b0:	b0 e0       	ldi	r27, 0x00	; 0
    12b2:	e5 e5       	ldi	r30, 0x55	; 85
    12b4:	f0 e0       	ldi	r31, 0x00	; 0
    12b6:	80 81       	ld	r24, Z
    12b8:	8d 7f       	andi	r24, 0xFD	; 253
    12ba:	8c 93       	st	X, r24
    12bc:	2f c0       	rjmp	.+94     	; 0x131c <EXTI_u8Int0SetSenseControl+0xcc>
		 case  ON_CHANGE: SET_BIT(MCUCR,MCUCR_ISC00);CLR_BIT(MCUCR,MCUCR_ISC01);break;
    12be:	a5 e5       	ldi	r26, 0x55	; 85
    12c0:	b0 e0       	ldi	r27, 0x00	; 0
    12c2:	e5 e5       	ldi	r30, 0x55	; 85
    12c4:	f0 e0       	ldi	r31, 0x00	; 0
    12c6:	80 81       	ld	r24, Z
    12c8:	81 60       	ori	r24, 0x01	; 1
    12ca:	8c 93       	st	X, r24
    12cc:	a5 e5       	ldi	r26, 0x55	; 85
    12ce:	b0 e0       	ldi	r27, 0x00	; 0
    12d0:	e5 e5       	ldi	r30, 0x55	; 85
    12d2:	f0 e0       	ldi	r31, 0x00	; 0
    12d4:	80 81       	ld	r24, Z
    12d6:	8d 7f       	andi	r24, 0xFD	; 253
    12d8:	8c 93       	st	X, r24
    12da:	20 c0       	rjmp	.+64     	; 0x131c <EXTI_u8Int0SetSenseControl+0xcc>
		 case  FALLING_EDGE:CLR_BIT(MCUCR,MCUCR_ISC00);SET_BIT(MCUCR,MCUCR_ISC01);break;
    12dc:	a5 e5       	ldi	r26, 0x55	; 85
    12de:	b0 e0       	ldi	r27, 0x00	; 0
    12e0:	e5 e5       	ldi	r30, 0x55	; 85
    12e2:	f0 e0       	ldi	r31, 0x00	; 0
    12e4:	80 81       	ld	r24, Z
    12e6:	8e 7f       	andi	r24, 0xFE	; 254
    12e8:	8c 93       	st	X, r24
    12ea:	a5 e5       	ldi	r26, 0x55	; 85
    12ec:	b0 e0       	ldi	r27, 0x00	; 0
    12ee:	e5 e5       	ldi	r30, 0x55	; 85
    12f0:	f0 e0       	ldi	r31, 0x00	; 0
    12f2:	80 81       	ld	r24, Z
    12f4:	82 60       	ori	r24, 0x02	; 2
    12f6:	8c 93       	st	X, r24
    12f8:	11 c0       	rjmp	.+34     	; 0x131c <EXTI_u8Int0SetSenseControl+0xcc>
		 case  RISING_EDGE: SET_BIT(MCUCR,MCUCR_ISC00);SET_BIT(MCUCR,MCUCR_ISC01);break;
    12fa:	a5 e5       	ldi	r26, 0x55	; 85
    12fc:	b0 e0       	ldi	r27, 0x00	; 0
    12fe:	e5 e5       	ldi	r30, 0x55	; 85
    1300:	f0 e0       	ldi	r31, 0x00	; 0
    1302:	80 81       	ld	r24, Z
    1304:	81 60       	ori	r24, 0x01	; 1
    1306:	8c 93       	st	X, r24
    1308:	a5 e5       	ldi	r26, 0x55	; 85
    130a:	b0 e0       	ldi	r27, 0x00	; 0
    130c:	e5 e5       	ldi	r30, 0x55	; 85
    130e:	f0 e0       	ldi	r31, 0x00	; 0
    1310:	80 81       	ld	r24, Z
    1312:	82 60       	ori	r24, 0x02	; 2
    1314:	8c 93       	st	X, r24
    1316:	02 c0       	rjmp	.+4      	; 0x131c <EXTI_u8Int0SetSenseControl+0xcc>
		 default:Local_u8ErrorState = NOT_OK ; 	 
    1318:	81 e0       	ldi	r24, 0x01	; 1
    131a:	89 83       	std	Y+1, r24	; 0x01
	 }
	 
	 return Local_u8ErrorState ; 
    131c:	89 81       	ldd	r24, Y+1	; 0x01
}
    131e:	0f 90       	pop	r0
    1320:	0f 90       	pop	r0
    1322:	0f 90       	pop	r0
    1324:	0f 90       	pop	r0
    1326:	cf 91       	pop	r28
    1328:	df 91       	pop	r29
    132a:	08 95       	ret

0000132c <EXTI_u8Int1SetSenseControl>:

u8 EXTI_u8Int1SetSenseControl(u8 copy_u8Int1Sense)
{
    132c:	df 93       	push	r29
    132e:	cf 93       	push	r28
    1330:	00 d0       	rcall	.+0      	; 0x1332 <EXTI_u8Int1SetSenseControl+0x6>
    1332:	00 d0       	rcall	.+0      	; 0x1334 <EXTI_u8Int1SetSenseControl+0x8>
    1334:	cd b7       	in	r28, 0x3d	; 61
    1336:	de b7       	in	r29, 0x3e	; 62
    1338:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErrorState = Ok ; 
    133a:	19 82       	std	Y+1, r1	; 0x01
	switch(copy_u8Int1Sense)
    133c:	8a 81       	ldd	r24, Y+2	; 0x02
    133e:	28 2f       	mov	r18, r24
    1340:	30 e0       	ldi	r19, 0x00	; 0
    1342:	3c 83       	std	Y+4, r19	; 0x04
    1344:	2b 83       	std	Y+3, r18	; 0x03
    1346:	8b 81       	ldd	r24, Y+3	; 0x03
    1348:	9c 81       	ldd	r25, Y+4	; 0x04
    134a:	82 30       	cpi	r24, 0x02	; 2
    134c:	91 05       	cpc	r25, r1
    134e:	29 f1       	breq	.+74     	; 0x139a <EXTI_u8Int1SetSenseControl+0x6e>
    1350:	2b 81       	ldd	r18, Y+3	; 0x03
    1352:	3c 81       	ldd	r19, Y+4	; 0x04
    1354:	23 30       	cpi	r18, 0x03	; 3
    1356:	31 05       	cpc	r19, r1
    1358:	34 f4       	brge	.+12     	; 0x1366 <EXTI_u8Int1SetSenseControl+0x3a>
    135a:	8b 81       	ldd	r24, Y+3	; 0x03
    135c:	9c 81       	ldd	r25, Y+4	; 0x04
    135e:	81 30       	cpi	r24, 0x01	; 1
    1360:	91 05       	cpc	r25, r1
    1362:	61 f0       	breq	.+24     	; 0x137c <EXTI_u8Int1SetSenseControl+0x50>
    1364:	47 c0       	rjmp	.+142    	; 0x13f4 <EXTI_u8Int1SetSenseControl+0xc8>
    1366:	2b 81       	ldd	r18, Y+3	; 0x03
    1368:	3c 81       	ldd	r19, Y+4	; 0x04
    136a:	23 30       	cpi	r18, 0x03	; 3
    136c:	31 05       	cpc	r19, r1
    136e:	21 f1       	breq	.+72     	; 0x13b8 <EXTI_u8Int1SetSenseControl+0x8c>
    1370:	8b 81       	ldd	r24, Y+3	; 0x03
    1372:	9c 81       	ldd	r25, Y+4	; 0x04
    1374:	84 30       	cpi	r24, 0x04	; 4
    1376:	91 05       	cpc	r25, r1
    1378:	71 f1       	breq	.+92     	; 0x13d6 <EXTI_u8Int1SetSenseControl+0xaa>
    137a:	3c c0       	rjmp	.+120    	; 0x13f4 <EXTI_u8Int1SetSenseControl+0xc8>
	{
		case  LOW_LEVEL: CLR_BIT(MCUCR,MCUCR_ISC10);CLR_BIT(MCUCR,MCUCR_ISC11); break; 
    137c:	a5 e5       	ldi	r26, 0x55	; 85
    137e:	b0 e0       	ldi	r27, 0x00	; 0
    1380:	e5 e5       	ldi	r30, 0x55	; 85
    1382:	f0 e0       	ldi	r31, 0x00	; 0
    1384:	80 81       	ld	r24, Z
    1386:	8b 7f       	andi	r24, 0xFB	; 251
    1388:	8c 93       	st	X, r24
    138a:	a5 e5       	ldi	r26, 0x55	; 85
    138c:	b0 e0       	ldi	r27, 0x00	; 0
    138e:	e5 e5       	ldi	r30, 0x55	; 85
    1390:	f0 e0       	ldi	r31, 0x00	; 0
    1392:	80 81       	ld	r24, Z
    1394:	87 7f       	andi	r24, 0xF7	; 247
    1396:	8c 93       	st	X, r24
    1398:	2f c0       	rjmp	.+94     	; 0x13f8 <EXTI_u8Int1SetSenseControl+0xcc>
		case  ON_CHANGE: SET_BIT(MCUCR,MCUCR_ISC10);CLR_BIT(MCUCR,MCUCR_ISC11); break;
    139a:	a5 e5       	ldi	r26, 0x55	; 85
    139c:	b0 e0       	ldi	r27, 0x00	; 0
    139e:	e5 e5       	ldi	r30, 0x55	; 85
    13a0:	f0 e0       	ldi	r31, 0x00	; 0
    13a2:	80 81       	ld	r24, Z
    13a4:	84 60       	ori	r24, 0x04	; 4
    13a6:	8c 93       	st	X, r24
    13a8:	a5 e5       	ldi	r26, 0x55	; 85
    13aa:	b0 e0       	ldi	r27, 0x00	; 0
    13ac:	e5 e5       	ldi	r30, 0x55	; 85
    13ae:	f0 e0       	ldi	r31, 0x00	; 0
    13b0:	80 81       	ld	r24, Z
    13b2:	87 7f       	andi	r24, 0xF7	; 247
    13b4:	8c 93       	st	X, r24
    13b6:	20 c0       	rjmp	.+64     	; 0x13f8 <EXTI_u8Int1SetSenseControl+0xcc>
		case  FALLING_EDGE:CLR_BIT(MCUCR,MCUCR_ISC10);SET_BIT(MCUCR,MCUCR_ISC11);break;
    13b8:	a5 e5       	ldi	r26, 0x55	; 85
    13ba:	b0 e0       	ldi	r27, 0x00	; 0
    13bc:	e5 e5       	ldi	r30, 0x55	; 85
    13be:	f0 e0       	ldi	r31, 0x00	; 0
    13c0:	80 81       	ld	r24, Z
    13c2:	8b 7f       	andi	r24, 0xFB	; 251
    13c4:	8c 93       	st	X, r24
    13c6:	a5 e5       	ldi	r26, 0x55	; 85
    13c8:	b0 e0       	ldi	r27, 0x00	; 0
    13ca:	e5 e5       	ldi	r30, 0x55	; 85
    13cc:	f0 e0       	ldi	r31, 0x00	; 0
    13ce:	80 81       	ld	r24, Z
    13d0:	88 60       	ori	r24, 0x08	; 8
    13d2:	8c 93       	st	X, r24
    13d4:	11 c0       	rjmp	.+34     	; 0x13f8 <EXTI_u8Int1SetSenseControl+0xcc>
		case  RISING_EDGE:SET_BIT(MCUCR,MCUCR_ISC10);SET_BIT(MCUCR,MCUCR_ISC11); break;
    13d6:	a5 e5       	ldi	r26, 0x55	; 85
    13d8:	b0 e0       	ldi	r27, 0x00	; 0
    13da:	e5 e5       	ldi	r30, 0x55	; 85
    13dc:	f0 e0       	ldi	r31, 0x00	; 0
    13de:	80 81       	ld	r24, Z
    13e0:	84 60       	ori	r24, 0x04	; 4
    13e2:	8c 93       	st	X, r24
    13e4:	a5 e5       	ldi	r26, 0x55	; 85
    13e6:	b0 e0       	ldi	r27, 0x00	; 0
    13e8:	e5 e5       	ldi	r30, 0x55	; 85
    13ea:	f0 e0       	ldi	r31, 0x00	; 0
    13ec:	80 81       	ld	r24, Z
    13ee:	88 60       	ori	r24, 0x08	; 8
    13f0:	8c 93       	st	X, r24
    13f2:	02 c0       	rjmp	.+4      	; 0x13f8 <EXTI_u8Int1SetSenseControl+0xcc>
		default: Local_u8ErrorState = NOT_OK ;
    13f4:	81 e0       	ldi	r24, 0x01	; 1
    13f6:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState; 
    13f8:	89 81       	ldd	r24, Y+1	; 0x01
}
    13fa:	0f 90       	pop	r0
    13fc:	0f 90       	pop	r0
    13fe:	0f 90       	pop	r0
    1400:	0f 90       	pop	r0
    1402:	cf 91       	pop	r28
    1404:	df 91       	pop	r29
    1406:	08 95       	ret

00001408 <EXTI_u8Int2SetSenseControl>:

u8 EXTI_u8Int2SetSenseControl(u8 copy_u8Inte2Sense)
{
    1408:	df 93       	push	r29
    140a:	cf 93       	push	r28
    140c:	00 d0       	rcall	.+0      	; 0x140e <EXTI_u8Int2SetSenseControl+0x6>
    140e:	00 d0       	rcall	.+0      	; 0x1410 <EXTI_u8Int2SetSenseControl+0x8>
    1410:	cd b7       	in	r28, 0x3d	; 61
    1412:	de b7       	in	r29, 0x3e	; 62
    1414:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErrorState = Ok ;
    1416:	19 82       	std	Y+1, r1	; 0x01
	switch(copy_u8Inte2Sense)
    1418:	8a 81       	ldd	r24, Y+2	; 0x02
    141a:	28 2f       	mov	r18, r24
    141c:	30 e0       	ldi	r19, 0x00	; 0
    141e:	3c 83       	std	Y+4, r19	; 0x04
    1420:	2b 83       	std	Y+3, r18	; 0x03
    1422:	8b 81       	ldd	r24, Y+3	; 0x03
    1424:	9c 81       	ldd	r25, Y+4	; 0x04
    1426:	83 30       	cpi	r24, 0x03	; 3
    1428:	91 05       	cpc	r25, r1
    142a:	31 f0       	breq	.+12     	; 0x1438 <EXTI_u8Int2SetSenseControl+0x30>
    142c:	2b 81       	ldd	r18, Y+3	; 0x03
    142e:	3c 81       	ldd	r19, Y+4	; 0x04
    1430:	24 30       	cpi	r18, 0x04	; 4
    1432:	31 05       	cpc	r19, r1
    1434:	49 f0       	breq	.+18     	; 0x1448 <EXTI_u8Int2SetSenseControl+0x40>
    1436:	10 c0       	rjmp	.+32     	; 0x1458 <EXTI_u8Int2SetSenseControl+0x50>
	{
		case  FALLING_EDGE:CLR_BIT(MCUCSR,MCUCSR_ISC2);break ;
    1438:	a4 e5       	ldi	r26, 0x54	; 84
    143a:	b0 e0       	ldi	r27, 0x00	; 0
    143c:	e4 e5       	ldi	r30, 0x54	; 84
    143e:	f0 e0       	ldi	r31, 0x00	; 0
    1440:	80 81       	ld	r24, Z
    1442:	8f 7b       	andi	r24, 0xBF	; 191
    1444:	8c 93       	st	X, r24
    1446:	0a c0       	rjmp	.+20     	; 0x145c <EXTI_u8Int2SetSenseControl+0x54>
		case  RISING_EDGE:SET_BIT(MCUCSR,MCUCSR_ISC2);break ; 
    1448:	a4 e5       	ldi	r26, 0x54	; 84
    144a:	b0 e0       	ldi	r27, 0x00	; 0
    144c:	e4 e5       	ldi	r30, 0x54	; 84
    144e:	f0 e0       	ldi	r31, 0x00	; 0
    1450:	80 81       	ld	r24, Z
    1452:	80 64       	ori	r24, 0x40	; 64
    1454:	8c 93       	st	X, r24
    1456:	02 c0       	rjmp	.+4      	; 0x145c <EXTI_u8Int2SetSenseControl+0x54>
		default: Local_u8ErrorState = NOT_OK;
    1458:	81 e0       	ldi	r24, 0x01	; 1
    145a:	89 83       	std	Y+1, r24	; 0x01
	}
	
	return Local_u8ErrorState ; 
    145c:	89 81       	ldd	r24, Y+1	; 0x01
}
    145e:	0f 90       	pop	r0
    1460:	0f 90       	pop	r0
    1462:	0f 90       	pop	r0
    1464:	0f 90       	pop	r0
    1466:	cf 91       	pop	r28
    1468:	df 91       	pop	r29
    146a:	08 95       	ret

0000146c <EXTI_u8IntEnable>:

u8 EXTI_u8IntEnable(u8 copy_u8INT )
{
    146c:	df 93       	push	r29
    146e:	cf 93       	push	r28
    1470:	00 d0       	rcall	.+0      	; 0x1472 <EXTI_u8IntEnable+0x6>
    1472:	00 d0       	rcall	.+0      	; 0x1474 <EXTI_u8IntEnable+0x8>
    1474:	cd b7       	in	r28, 0x3d	; 61
    1476:	de b7       	in	r29, 0x3e	; 62
    1478:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErrorState = Ok ; 
    147a:	19 82       	std	Y+1, r1	; 0x01
	switch(copy_u8INT)
    147c:	8a 81       	ldd	r24, Y+2	; 0x02
    147e:	28 2f       	mov	r18, r24
    1480:	30 e0       	ldi	r19, 0x00	; 0
    1482:	3c 83       	std	Y+4, r19	; 0x04
    1484:	2b 83       	std	Y+3, r18	; 0x03
    1486:	8b 81       	ldd	r24, Y+3	; 0x03
    1488:	9c 81       	ldd	r25, Y+4	; 0x04
    148a:	81 30       	cpi	r24, 0x01	; 1
    148c:	91 05       	cpc	r25, r1
    148e:	89 f0       	breq	.+34     	; 0x14b2 <EXTI_u8IntEnable+0x46>
    1490:	2b 81       	ldd	r18, Y+3	; 0x03
    1492:	3c 81       	ldd	r19, Y+4	; 0x04
    1494:	22 30       	cpi	r18, 0x02	; 2
    1496:	31 05       	cpc	r19, r1
    1498:	a1 f0       	breq	.+40     	; 0x14c2 <EXTI_u8IntEnable+0x56>
    149a:	8b 81       	ldd	r24, Y+3	; 0x03
    149c:	9c 81       	ldd	r25, Y+4	; 0x04
    149e:	00 97       	sbiw	r24, 0x00	; 0
    14a0:	c1 f4       	brne	.+48     	; 0x14d2 <EXTI_u8IntEnable+0x66>
	{
		case INT0:SET_BIT(GICR,GICR_INT0);break; 
    14a2:	ab e5       	ldi	r26, 0x5B	; 91
    14a4:	b0 e0       	ldi	r27, 0x00	; 0
    14a6:	eb e5       	ldi	r30, 0x5B	; 91
    14a8:	f0 e0       	ldi	r31, 0x00	; 0
    14aa:	80 81       	ld	r24, Z
    14ac:	80 64       	ori	r24, 0x40	; 64
    14ae:	8c 93       	st	X, r24
    14b0:	12 c0       	rjmp	.+36     	; 0x14d6 <EXTI_u8IntEnable+0x6a>
		case INT1:SET_BIT(GICR,GICR_INT1);break; 
    14b2:	ab e5       	ldi	r26, 0x5B	; 91
    14b4:	b0 e0       	ldi	r27, 0x00	; 0
    14b6:	eb e5       	ldi	r30, 0x5B	; 91
    14b8:	f0 e0       	ldi	r31, 0x00	; 0
    14ba:	80 81       	ld	r24, Z
    14bc:	80 68       	ori	r24, 0x80	; 128
    14be:	8c 93       	st	X, r24
    14c0:	0a c0       	rjmp	.+20     	; 0x14d6 <EXTI_u8IntEnable+0x6a>
		case INT2:SET_BIT(GICR,GICR_INT2);break; 
    14c2:	ab e5       	ldi	r26, 0x5B	; 91
    14c4:	b0 e0       	ldi	r27, 0x00	; 0
    14c6:	eb e5       	ldi	r30, 0x5B	; 91
    14c8:	f0 e0       	ldi	r31, 0x00	; 0
    14ca:	80 81       	ld	r24, Z
    14cc:	80 62       	ori	r24, 0x20	; 32
    14ce:	8c 93       	st	X, r24
    14d0:	02 c0       	rjmp	.+4      	; 0x14d6 <EXTI_u8IntEnable+0x6a>
		default:Local_u8ErrorState = NOT_OK ;  	 
    14d2:	81 e0       	ldi	r24, 0x01	; 1
    14d4:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState ; 
    14d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    14d8:	0f 90       	pop	r0
    14da:	0f 90       	pop	r0
    14dc:	0f 90       	pop	r0
    14de:	0f 90       	pop	r0
    14e0:	cf 91       	pop	r28
    14e2:	df 91       	pop	r29
    14e4:	08 95       	ret

000014e6 <EXTI_u8IntDisable>:
u8 EXTI_u8IntDisable(u8 copy_u8INT )
{
    14e6:	df 93       	push	r29
    14e8:	cf 93       	push	r28
    14ea:	00 d0       	rcall	.+0      	; 0x14ec <EXTI_u8IntDisable+0x6>
    14ec:	00 d0       	rcall	.+0      	; 0x14ee <EXTI_u8IntDisable+0x8>
    14ee:	cd b7       	in	r28, 0x3d	; 61
    14f0:	de b7       	in	r29, 0x3e	; 62
    14f2:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErrorState = Ok ;
    14f4:	19 82       	std	Y+1, r1	; 0x01
	switch(copy_u8INT)
    14f6:	8a 81       	ldd	r24, Y+2	; 0x02
    14f8:	28 2f       	mov	r18, r24
    14fa:	30 e0       	ldi	r19, 0x00	; 0
    14fc:	3c 83       	std	Y+4, r19	; 0x04
    14fe:	2b 83       	std	Y+3, r18	; 0x03
    1500:	8b 81       	ldd	r24, Y+3	; 0x03
    1502:	9c 81       	ldd	r25, Y+4	; 0x04
    1504:	81 30       	cpi	r24, 0x01	; 1
    1506:	91 05       	cpc	r25, r1
    1508:	89 f0       	breq	.+34     	; 0x152c <EXTI_u8IntDisable+0x46>
    150a:	2b 81       	ldd	r18, Y+3	; 0x03
    150c:	3c 81       	ldd	r19, Y+4	; 0x04
    150e:	22 30       	cpi	r18, 0x02	; 2
    1510:	31 05       	cpc	r19, r1
    1512:	a1 f0       	breq	.+40     	; 0x153c <EXTI_u8IntDisable+0x56>
    1514:	8b 81       	ldd	r24, Y+3	; 0x03
    1516:	9c 81       	ldd	r25, Y+4	; 0x04
    1518:	00 97       	sbiw	r24, 0x00	; 0
    151a:	c1 f4       	brne	.+48     	; 0x154c <EXTI_u8IntDisable+0x66>
	{
		case INT0:CLR_BIT(GICR,GICR_INT0);break;
    151c:	ab e5       	ldi	r26, 0x5B	; 91
    151e:	b0 e0       	ldi	r27, 0x00	; 0
    1520:	eb e5       	ldi	r30, 0x5B	; 91
    1522:	f0 e0       	ldi	r31, 0x00	; 0
    1524:	80 81       	ld	r24, Z
    1526:	8f 7b       	andi	r24, 0xBF	; 191
    1528:	8c 93       	st	X, r24
    152a:	12 c0       	rjmp	.+36     	; 0x1550 <EXTI_u8IntDisable+0x6a>
		case INT1:CLR_BIT(GICR,GICR_INT1);break;
    152c:	ab e5       	ldi	r26, 0x5B	; 91
    152e:	b0 e0       	ldi	r27, 0x00	; 0
    1530:	eb e5       	ldi	r30, 0x5B	; 91
    1532:	f0 e0       	ldi	r31, 0x00	; 0
    1534:	80 81       	ld	r24, Z
    1536:	8f 77       	andi	r24, 0x7F	; 127
    1538:	8c 93       	st	X, r24
    153a:	0a c0       	rjmp	.+20     	; 0x1550 <EXTI_u8IntDisable+0x6a>
		case INT2:CLR_BIT(GICR,GICR_INT2);break;
    153c:	ab e5       	ldi	r26, 0x5B	; 91
    153e:	b0 e0       	ldi	r27, 0x00	; 0
    1540:	eb e5       	ldi	r30, 0x5B	; 91
    1542:	f0 e0       	ldi	r31, 0x00	; 0
    1544:	80 81       	ld	r24, Z
    1546:	8f 7d       	andi	r24, 0xDF	; 223
    1548:	8c 93       	st	X, r24
    154a:	02 c0       	rjmp	.+4      	; 0x1550 <EXTI_u8IntDisable+0x6a>
		default:Local_u8ErrorState = NOT_OK ;
    154c:	81 e0       	ldi	r24, 0x01	; 1
    154e:	89 83       	std	Y+1, r24	; 0x01
		
	}
	return Local_u8ErrorState ;
    1550:	89 81       	ldd	r24, Y+1	; 0x01
}
    1552:	0f 90       	pop	r0
    1554:	0f 90       	pop	r0
    1556:	0f 90       	pop	r0
    1558:	0f 90       	pop	r0
    155a:	cf 91       	pop	r28
    155c:	df 91       	pop	r29
    155e:	08 95       	ret

00001560 <EXTI_u8Int0SetCallBack>:


u8 EXTI_u8Int0SetCallBack(void(*copy_pvINT0Func)(void))
{
    1560:	df 93       	push	r29
    1562:	cf 93       	push	r28
    1564:	00 d0       	rcall	.+0      	; 0x1566 <EXTI_u8Int0SetCallBack+0x6>
    1566:	00 d0       	rcall	.+0      	; 0x1568 <EXTI_u8Int0SetCallBack+0x8>
    1568:	cd b7       	in	r28, 0x3d	; 61
    156a:	de b7       	in	r29, 0x3e	; 62
    156c:	9b 83       	std	Y+3, r25	; 0x03
    156e:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErrorState = Ok ; 
    1570:	19 82       	std	Y+1, r1	; 0x01
	if(copy_pvINT0Func!=NULL)
    1572:	8a 81       	ldd	r24, Y+2	; 0x02
    1574:	9b 81       	ldd	r25, Y+3	; 0x03
    1576:	00 97       	sbiw	r24, 0x00	; 0
    1578:	49 f0       	breq	.+18     	; 0x158c <EXTI_u8Int0SetCallBack+0x2c>
	{
		EXTI_pvINT0func=copy_pvINT0Func ;
    157a:	8a 81       	ldd	r24, Y+2	; 0x02
    157c:	9b 81       	ldd	r25, Y+3	; 0x03
    157e:	90 93 03 02 	sts	0x0203, r25
    1582:	80 93 02 02 	sts	0x0202, r24
	else
	{
		return Local_u8ErrorState=NULL_POINTER; 
	}
	
	return Local_u8ErrorState ; 
    1586:	89 81       	ldd	r24, Y+1	; 0x01
    1588:	8c 83       	std	Y+4, r24	; 0x04
    158a:	04 c0       	rjmp	.+8      	; 0x1594 <EXTI_u8Int0SetCallBack+0x34>
	{
		EXTI_pvINT0func=copy_pvINT0Func ;
	}
	else
	{
		return Local_u8ErrorState=NULL_POINTER; 
    158c:	82 e0       	ldi	r24, 0x02	; 2
    158e:	89 83       	std	Y+1, r24	; 0x01
    1590:	89 81       	ldd	r24, Y+1	; 0x01
    1592:	8c 83       	std	Y+4, r24	; 0x04
    1594:	8c 81       	ldd	r24, Y+4	; 0x04
	}
	
	return Local_u8ErrorState ; 
}
    1596:	0f 90       	pop	r0
    1598:	0f 90       	pop	r0
    159a:	0f 90       	pop	r0
    159c:	0f 90       	pop	r0
    159e:	cf 91       	pop	r28
    15a0:	df 91       	pop	r29
    15a2:	08 95       	ret

000015a4 <EXTI_u8Int1SetCallBack>:

u8 EXTI_u8Int1SetCallBack(void(*copy_pvINT1Func)(void))
{
    15a4:	df 93       	push	r29
    15a6:	cf 93       	push	r28
    15a8:	00 d0       	rcall	.+0      	; 0x15aa <EXTI_u8Int1SetCallBack+0x6>
    15aa:	00 d0       	rcall	.+0      	; 0x15ac <EXTI_u8Int1SetCallBack+0x8>
    15ac:	cd b7       	in	r28, 0x3d	; 61
    15ae:	de b7       	in	r29, 0x3e	; 62
    15b0:	9b 83       	std	Y+3, r25	; 0x03
    15b2:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErrorState = Ok ;
    15b4:	19 82       	std	Y+1, r1	; 0x01
	if(copy_pvINT1Func!=NULL)
    15b6:	8a 81       	ldd	r24, Y+2	; 0x02
    15b8:	9b 81       	ldd	r25, Y+3	; 0x03
    15ba:	00 97       	sbiw	r24, 0x00	; 0
    15bc:	49 f0       	breq	.+18     	; 0x15d0 <EXTI_u8Int1SetCallBack+0x2c>
	{
		EXTI_pvINT1func=copy_pvINT1Func ;
    15be:	8a 81       	ldd	r24, Y+2	; 0x02
    15c0:	9b 81       	ldd	r25, Y+3	; 0x03
    15c2:	90 93 05 02 	sts	0x0205, r25
    15c6:	80 93 04 02 	sts	0x0204, r24
	else
	{
		return Local_u8ErrorState=NULL_POINTER;
	}
	
	return Local_u8ErrorState ;
    15ca:	89 81       	ldd	r24, Y+1	; 0x01
    15cc:	8c 83       	std	Y+4, r24	; 0x04
    15ce:	04 c0       	rjmp	.+8      	; 0x15d8 <EXTI_u8Int1SetCallBack+0x34>
	{
		EXTI_pvINT1func=copy_pvINT1Func ;
	}
	else
	{
		return Local_u8ErrorState=NULL_POINTER;
    15d0:	82 e0       	ldi	r24, 0x02	; 2
    15d2:	89 83       	std	Y+1, r24	; 0x01
    15d4:	89 81       	ldd	r24, Y+1	; 0x01
    15d6:	8c 83       	std	Y+4, r24	; 0x04
    15d8:	8c 81       	ldd	r24, Y+4	; 0x04
	}
	
	return Local_u8ErrorState ;
}
    15da:	0f 90       	pop	r0
    15dc:	0f 90       	pop	r0
    15de:	0f 90       	pop	r0
    15e0:	0f 90       	pop	r0
    15e2:	cf 91       	pop	r28
    15e4:	df 91       	pop	r29
    15e6:	08 95       	ret

000015e8 <EXTI_u8Int2SetCallBack>:

u8 EXTI_u8Int2SetCallBack(void(*copy_pvINT2Func)(void))
{
    15e8:	df 93       	push	r29
    15ea:	cf 93       	push	r28
    15ec:	00 d0       	rcall	.+0      	; 0x15ee <EXTI_u8Int2SetCallBack+0x6>
    15ee:	00 d0       	rcall	.+0      	; 0x15f0 <EXTI_u8Int2SetCallBack+0x8>
    15f0:	cd b7       	in	r28, 0x3d	; 61
    15f2:	de b7       	in	r29, 0x3e	; 62
    15f4:	9b 83       	std	Y+3, r25	; 0x03
    15f6:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErrorState = Ok ;
    15f8:	19 82       	std	Y+1, r1	; 0x01
	if(copy_pvINT2Func!=NULL)
    15fa:	8a 81       	ldd	r24, Y+2	; 0x02
    15fc:	9b 81       	ldd	r25, Y+3	; 0x03
    15fe:	00 97       	sbiw	r24, 0x00	; 0
    1600:	49 f0       	breq	.+18     	; 0x1614 <EXTI_u8Int2SetCallBack+0x2c>
	{
		EXTI_pvINT2func=copy_pvINT2Func ;
    1602:	8a 81       	ldd	r24, Y+2	; 0x02
    1604:	9b 81       	ldd	r25, Y+3	; 0x03
    1606:	90 93 07 02 	sts	0x0207, r25
    160a:	80 93 06 02 	sts	0x0206, r24
	else
	{
		return Local_u8ErrorState=NULL_POINTER;
	}
	
	return Local_u8ErrorState ;
    160e:	89 81       	ldd	r24, Y+1	; 0x01
    1610:	8c 83       	std	Y+4, r24	; 0x04
    1612:	04 c0       	rjmp	.+8      	; 0x161c <EXTI_u8Int2SetCallBack+0x34>
	{
		EXTI_pvINT2func=copy_pvINT2Func ;
	}
	else
	{
		return Local_u8ErrorState=NULL_POINTER;
    1614:	82 e0       	ldi	r24, 0x02	; 2
    1616:	89 83       	std	Y+1, r24	; 0x01
    1618:	89 81       	ldd	r24, Y+1	; 0x01
    161a:	8c 83       	std	Y+4, r24	; 0x04
    161c:	8c 81       	ldd	r24, Y+4	; 0x04
	}
	
	return Local_u8ErrorState ;
}
    161e:	0f 90       	pop	r0
    1620:	0f 90       	pop	r0
    1622:	0f 90       	pop	r0
    1624:	0f 90       	pop	r0
    1626:	cf 91       	pop	r28
    1628:	df 91       	pop	r29
    162a:	08 95       	ret

0000162c <__vector_1>:


/*ISR of INT0*/
void __vector_1 (void) __attribute__((signal));
void __vector_1 (void)
{
    162c:	1f 92       	push	r1
    162e:	0f 92       	push	r0
    1630:	0f b6       	in	r0, 0x3f	; 63
    1632:	0f 92       	push	r0
    1634:	11 24       	eor	r1, r1
    1636:	2f 93       	push	r18
    1638:	3f 93       	push	r19
    163a:	4f 93       	push	r20
    163c:	5f 93       	push	r21
    163e:	6f 93       	push	r22
    1640:	7f 93       	push	r23
    1642:	8f 93       	push	r24
    1644:	9f 93       	push	r25
    1646:	af 93       	push	r26
    1648:	bf 93       	push	r27
    164a:	ef 93       	push	r30
    164c:	ff 93       	push	r31
    164e:	df 93       	push	r29
    1650:	cf 93       	push	r28
    1652:	cd b7       	in	r28, 0x3d	; 61
    1654:	de b7       	in	r29, 0x3e	; 62
	if (EXTI_pvINT0func!=NULL)
    1656:	80 91 02 02 	lds	r24, 0x0202
    165a:	90 91 03 02 	lds	r25, 0x0203
    165e:	00 97       	sbiw	r24, 0x00	; 0
    1660:	29 f0       	breq	.+10     	; 0x166c <__vector_1+0x40>
	{
		EXTI_pvINT0func();
    1662:	e0 91 02 02 	lds	r30, 0x0202
    1666:	f0 91 03 02 	lds	r31, 0x0203
    166a:	09 95       	icall
	else
	{
		/*do nothing*/
	}
	
}
    166c:	cf 91       	pop	r28
    166e:	df 91       	pop	r29
    1670:	ff 91       	pop	r31
    1672:	ef 91       	pop	r30
    1674:	bf 91       	pop	r27
    1676:	af 91       	pop	r26
    1678:	9f 91       	pop	r25
    167a:	8f 91       	pop	r24
    167c:	7f 91       	pop	r23
    167e:	6f 91       	pop	r22
    1680:	5f 91       	pop	r21
    1682:	4f 91       	pop	r20
    1684:	3f 91       	pop	r19
    1686:	2f 91       	pop	r18
    1688:	0f 90       	pop	r0
    168a:	0f be       	out	0x3f, r0	; 63
    168c:	0f 90       	pop	r0
    168e:	1f 90       	pop	r1
    1690:	18 95       	reti

00001692 <__vector_2>:


/*ISR of INT1*/
void __vector_2 (void) __attribute__((signal));
void __vector_2 (void)
{
    1692:	1f 92       	push	r1
    1694:	0f 92       	push	r0
    1696:	0f b6       	in	r0, 0x3f	; 63
    1698:	0f 92       	push	r0
    169a:	11 24       	eor	r1, r1
    169c:	2f 93       	push	r18
    169e:	3f 93       	push	r19
    16a0:	4f 93       	push	r20
    16a2:	5f 93       	push	r21
    16a4:	6f 93       	push	r22
    16a6:	7f 93       	push	r23
    16a8:	8f 93       	push	r24
    16aa:	9f 93       	push	r25
    16ac:	af 93       	push	r26
    16ae:	bf 93       	push	r27
    16b0:	ef 93       	push	r30
    16b2:	ff 93       	push	r31
    16b4:	df 93       	push	r29
    16b6:	cf 93       	push	r28
    16b8:	cd b7       	in	r28, 0x3d	; 61
    16ba:	de b7       	in	r29, 0x3e	; 62
	if (EXTI_pvINT1func!=NULL)
    16bc:	80 91 04 02 	lds	r24, 0x0204
    16c0:	90 91 05 02 	lds	r25, 0x0205
    16c4:	00 97       	sbiw	r24, 0x00	; 0
    16c6:	29 f0       	breq	.+10     	; 0x16d2 <__vector_2+0x40>
	{
		EXTI_pvINT1func();
    16c8:	e0 91 04 02 	lds	r30, 0x0204
    16cc:	f0 91 05 02 	lds	r31, 0x0205
    16d0:	09 95       	icall
	else
	{
		/*do nothing*/
	}
	
}
    16d2:	cf 91       	pop	r28
    16d4:	df 91       	pop	r29
    16d6:	ff 91       	pop	r31
    16d8:	ef 91       	pop	r30
    16da:	bf 91       	pop	r27
    16dc:	af 91       	pop	r26
    16de:	9f 91       	pop	r25
    16e0:	8f 91       	pop	r24
    16e2:	7f 91       	pop	r23
    16e4:	6f 91       	pop	r22
    16e6:	5f 91       	pop	r21
    16e8:	4f 91       	pop	r20
    16ea:	3f 91       	pop	r19
    16ec:	2f 91       	pop	r18
    16ee:	0f 90       	pop	r0
    16f0:	0f be       	out	0x3f, r0	; 63
    16f2:	0f 90       	pop	r0
    16f4:	1f 90       	pop	r1
    16f6:	18 95       	reti

000016f8 <__vector_3>:

/*ISR of INT2*/
void __vector_3 (void) __attribute__((signal));
void __vector_3 (void)
{
    16f8:	1f 92       	push	r1
    16fa:	0f 92       	push	r0
    16fc:	0f b6       	in	r0, 0x3f	; 63
    16fe:	0f 92       	push	r0
    1700:	11 24       	eor	r1, r1
    1702:	2f 93       	push	r18
    1704:	3f 93       	push	r19
    1706:	4f 93       	push	r20
    1708:	5f 93       	push	r21
    170a:	6f 93       	push	r22
    170c:	7f 93       	push	r23
    170e:	8f 93       	push	r24
    1710:	9f 93       	push	r25
    1712:	af 93       	push	r26
    1714:	bf 93       	push	r27
    1716:	ef 93       	push	r30
    1718:	ff 93       	push	r31
    171a:	df 93       	push	r29
    171c:	cf 93       	push	r28
    171e:	cd b7       	in	r28, 0x3d	; 61
    1720:	de b7       	in	r29, 0x3e	; 62
	if (EXTI_pvINT2func!=NULL)
    1722:	80 91 06 02 	lds	r24, 0x0206
    1726:	90 91 07 02 	lds	r25, 0x0207
    172a:	00 97       	sbiw	r24, 0x00	; 0
    172c:	29 f0       	breq	.+10     	; 0x1738 <__vector_3+0x40>
	{
		EXTI_pvINT2func();
    172e:	e0 91 06 02 	lds	r30, 0x0206
    1732:	f0 91 07 02 	lds	r31, 0x0207
    1736:	09 95       	icall
	else
	{
		/*do nothing*/
	}
	
    1738:	cf 91       	pop	r28
    173a:	df 91       	pop	r29
    173c:	ff 91       	pop	r31
    173e:	ef 91       	pop	r30
    1740:	bf 91       	pop	r27
    1742:	af 91       	pop	r26
    1744:	9f 91       	pop	r25
    1746:	8f 91       	pop	r24
    1748:	7f 91       	pop	r23
    174a:	6f 91       	pop	r22
    174c:	5f 91       	pop	r21
    174e:	4f 91       	pop	r20
    1750:	3f 91       	pop	r19
    1752:	2f 91       	pop	r18
    1754:	0f 90       	pop	r0
    1756:	0f be       	out	0x3f, r0	; 63
    1758:	0f 90       	pop	r0
    175a:	1f 90       	pop	r1
    175c:	18 95       	reti

0000175e <DIO_u8SetPinValue>:



/* function to set pin value high or low */
u8 DIO_u8SetPinValue(u8 Copy_u8Port , u8 Copy_u8Pin , u8 Copy_u8Value)
{
    175e:	df 93       	push	r29
    1760:	cf 93       	push	r28
    1762:	cd b7       	in	r28, 0x3d	; 61
    1764:	de b7       	in	r29, 0x3e	; 62
    1766:	28 97       	sbiw	r28, 0x08	; 8
    1768:	0f b6       	in	r0, 0x3f	; 63
    176a:	f8 94       	cli
    176c:	de bf       	out	0x3e, r29	; 62
    176e:	0f be       	out	0x3f, r0	; 63
    1770:	cd bf       	out	0x3d, r28	; 61
    1772:	8a 83       	std	Y+2, r24	; 0x02
    1774:	6b 83       	std	Y+3, r22	; 0x03
    1776:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErroState = 0 ;//return with value zero no error
    1778:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8Pin<=DIO_u8PIN7)
    177a:	8b 81       	ldd	r24, Y+3	; 0x03
    177c:	88 30       	cpi	r24, 0x08	; 8
    177e:	08 f0       	brcs	.+2      	; 0x1782 <DIO_u8SetPinValue+0x24>
    1780:	f3 c0       	rjmp	.+486    	; 0x1968 <DIO_u8SetPinValue+0x20a>
	{
		if(Copy_u8Value == DIO_u8PIN_LOW )
    1782:	8c 81       	ldd	r24, Y+4	; 0x04
    1784:	88 23       	and	r24, r24
    1786:	09 f0       	breq	.+2      	; 0x178a <DIO_u8SetPinValue+0x2c>
    1788:	77 c0       	rjmp	.+238    	; 0x1878 <DIO_u8SetPinValue+0x11a>
		{
			switch (Copy_u8Port)
    178a:	8a 81       	ldd	r24, Y+2	; 0x02
    178c:	28 2f       	mov	r18, r24
    178e:	30 e0       	ldi	r19, 0x00	; 0
    1790:	38 87       	std	Y+8, r19	; 0x08
    1792:	2f 83       	std	Y+7, r18	; 0x07
    1794:	8f 81       	ldd	r24, Y+7	; 0x07
    1796:	98 85       	ldd	r25, Y+8	; 0x08
    1798:	81 30       	cpi	r24, 0x01	; 1
    179a:	91 05       	cpc	r25, r1
    179c:	59 f1       	breq	.+86     	; 0x17f4 <DIO_u8SetPinValue+0x96>
    179e:	2f 81       	ldd	r18, Y+7	; 0x07
    17a0:	38 85       	ldd	r19, Y+8	; 0x08
    17a2:	22 30       	cpi	r18, 0x02	; 2
    17a4:	31 05       	cpc	r19, r1
    17a6:	2c f4       	brge	.+10     	; 0x17b2 <DIO_u8SetPinValue+0x54>
    17a8:	8f 81       	ldd	r24, Y+7	; 0x07
    17aa:	98 85       	ldd	r25, Y+8	; 0x08
    17ac:	00 97       	sbiw	r24, 0x00	; 0
    17ae:	69 f0       	breq	.+26     	; 0x17ca <DIO_u8SetPinValue+0x6c>
    17b0:	60 c0       	rjmp	.+192    	; 0x1872 <DIO_u8SetPinValue+0x114>
    17b2:	2f 81       	ldd	r18, Y+7	; 0x07
    17b4:	38 85       	ldd	r19, Y+8	; 0x08
    17b6:	22 30       	cpi	r18, 0x02	; 2
    17b8:	31 05       	cpc	r19, r1
    17ba:	89 f1       	breq	.+98     	; 0x181e <DIO_u8SetPinValue+0xc0>
    17bc:	8f 81       	ldd	r24, Y+7	; 0x07
    17be:	98 85       	ldd	r25, Y+8	; 0x08
    17c0:	83 30       	cpi	r24, 0x03	; 3
    17c2:	91 05       	cpc	r25, r1
    17c4:	09 f4       	brne	.+2      	; 0x17c8 <DIO_u8SetPinValue+0x6a>
    17c6:	40 c0       	rjmp	.+128    	; 0x1848 <DIO_u8SetPinValue+0xea>
    17c8:	54 c0       	rjmp	.+168    	; 0x1872 <DIO_u8SetPinValue+0x114>
			{
				case DIO_u8PORTA:CLR_BIT(PORTA,Copy_u8Pin);break; 
    17ca:	ab e3       	ldi	r26, 0x3B	; 59
    17cc:	b0 e0       	ldi	r27, 0x00	; 0
    17ce:	eb e3       	ldi	r30, 0x3B	; 59
    17d0:	f0 e0       	ldi	r31, 0x00	; 0
    17d2:	80 81       	ld	r24, Z
    17d4:	48 2f       	mov	r20, r24
    17d6:	8b 81       	ldd	r24, Y+3	; 0x03
    17d8:	28 2f       	mov	r18, r24
    17da:	30 e0       	ldi	r19, 0x00	; 0
    17dc:	81 e0       	ldi	r24, 0x01	; 1
    17de:	90 e0       	ldi	r25, 0x00	; 0
    17e0:	02 2e       	mov	r0, r18
    17e2:	02 c0       	rjmp	.+4      	; 0x17e8 <DIO_u8SetPinValue+0x8a>
    17e4:	88 0f       	add	r24, r24
    17e6:	99 1f       	adc	r25, r25
    17e8:	0a 94       	dec	r0
    17ea:	e2 f7       	brpl	.-8      	; 0x17e4 <DIO_u8SetPinValue+0x86>
    17ec:	80 95       	com	r24
    17ee:	84 23       	and	r24, r20
    17f0:	8c 93       	st	X, r24
    17f2:	ba c0       	rjmp	.+372    	; 0x1968 <DIO_u8SetPinValue+0x20a>
				case DIO_u8PORTB:CLR_BIT(PORTB,Copy_u8Pin);break;
    17f4:	a8 e3       	ldi	r26, 0x38	; 56
    17f6:	b0 e0       	ldi	r27, 0x00	; 0
    17f8:	e8 e3       	ldi	r30, 0x38	; 56
    17fa:	f0 e0       	ldi	r31, 0x00	; 0
    17fc:	80 81       	ld	r24, Z
    17fe:	48 2f       	mov	r20, r24
    1800:	8b 81       	ldd	r24, Y+3	; 0x03
    1802:	28 2f       	mov	r18, r24
    1804:	30 e0       	ldi	r19, 0x00	; 0
    1806:	81 e0       	ldi	r24, 0x01	; 1
    1808:	90 e0       	ldi	r25, 0x00	; 0
    180a:	02 2e       	mov	r0, r18
    180c:	02 c0       	rjmp	.+4      	; 0x1812 <DIO_u8SetPinValue+0xb4>
    180e:	88 0f       	add	r24, r24
    1810:	99 1f       	adc	r25, r25
    1812:	0a 94       	dec	r0
    1814:	e2 f7       	brpl	.-8      	; 0x180e <DIO_u8SetPinValue+0xb0>
    1816:	80 95       	com	r24
    1818:	84 23       	and	r24, r20
    181a:	8c 93       	st	X, r24
    181c:	a5 c0       	rjmp	.+330    	; 0x1968 <DIO_u8SetPinValue+0x20a>
				case DIO_u8PORTC:CLR_BIT(PORTC,Copy_u8Pin);break;
    181e:	a5 e3       	ldi	r26, 0x35	; 53
    1820:	b0 e0       	ldi	r27, 0x00	; 0
    1822:	e5 e3       	ldi	r30, 0x35	; 53
    1824:	f0 e0       	ldi	r31, 0x00	; 0
    1826:	80 81       	ld	r24, Z
    1828:	48 2f       	mov	r20, r24
    182a:	8b 81       	ldd	r24, Y+3	; 0x03
    182c:	28 2f       	mov	r18, r24
    182e:	30 e0       	ldi	r19, 0x00	; 0
    1830:	81 e0       	ldi	r24, 0x01	; 1
    1832:	90 e0       	ldi	r25, 0x00	; 0
    1834:	02 2e       	mov	r0, r18
    1836:	02 c0       	rjmp	.+4      	; 0x183c <DIO_u8SetPinValue+0xde>
    1838:	88 0f       	add	r24, r24
    183a:	99 1f       	adc	r25, r25
    183c:	0a 94       	dec	r0
    183e:	e2 f7       	brpl	.-8      	; 0x1838 <DIO_u8SetPinValue+0xda>
    1840:	80 95       	com	r24
    1842:	84 23       	and	r24, r20
    1844:	8c 93       	st	X, r24
    1846:	90 c0       	rjmp	.+288    	; 0x1968 <DIO_u8SetPinValue+0x20a>
				case DIO_u8PORTD:CLR_BIT(PORTD,Copy_u8Pin);break;
    1848:	a2 e3       	ldi	r26, 0x32	; 50
    184a:	b0 e0       	ldi	r27, 0x00	; 0
    184c:	e2 e3       	ldi	r30, 0x32	; 50
    184e:	f0 e0       	ldi	r31, 0x00	; 0
    1850:	80 81       	ld	r24, Z
    1852:	48 2f       	mov	r20, r24
    1854:	8b 81       	ldd	r24, Y+3	; 0x03
    1856:	28 2f       	mov	r18, r24
    1858:	30 e0       	ldi	r19, 0x00	; 0
    185a:	81 e0       	ldi	r24, 0x01	; 1
    185c:	90 e0       	ldi	r25, 0x00	; 0
    185e:	02 2e       	mov	r0, r18
    1860:	02 c0       	rjmp	.+4      	; 0x1866 <DIO_u8SetPinValue+0x108>
    1862:	88 0f       	add	r24, r24
    1864:	99 1f       	adc	r25, r25
    1866:	0a 94       	dec	r0
    1868:	e2 f7       	brpl	.-8      	; 0x1862 <DIO_u8SetPinValue+0x104>
    186a:	80 95       	com	r24
    186c:	84 23       	and	r24, r20
    186e:	8c 93       	st	X, r24
    1870:	7b c0       	rjmp	.+246    	; 0x1968 <DIO_u8SetPinValue+0x20a>
				default:Local_u8ErroState = 1 ; break;
    1872:	81 e0       	ldi	r24, 0x01	; 1
    1874:	89 83       	std	Y+1, r24	; 0x01
    1876:	78 c0       	rjmp	.+240    	; 0x1968 <DIO_u8SetPinValue+0x20a>
				
			}
		}
			
		else if(Copy_u8Value == DIO_u8PIN_HIGH )
    1878:	8c 81       	ldd	r24, Y+4	; 0x04
    187a:	81 30       	cpi	r24, 0x01	; 1
    187c:	09 f0       	breq	.+2      	; 0x1880 <DIO_u8SetPinValue+0x122>
    187e:	72 c0       	rjmp	.+228    	; 0x1964 <DIO_u8SetPinValue+0x206>
		{
			switch (Copy_u8Port)
    1880:	8a 81       	ldd	r24, Y+2	; 0x02
    1882:	28 2f       	mov	r18, r24
    1884:	30 e0       	ldi	r19, 0x00	; 0
    1886:	3e 83       	std	Y+6, r19	; 0x06
    1888:	2d 83       	std	Y+5, r18	; 0x05
    188a:	8d 81       	ldd	r24, Y+5	; 0x05
    188c:	9e 81       	ldd	r25, Y+6	; 0x06
    188e:	81 30       	cpi	r24, 0x01	; 1
    1890:	91 05       	cpc	r25, r1
    1892:	49 f1       	breq	.+82     	; 0x18e6 <DIO_u8SetPinValue+0x188>
    1894:	2d 81       	ldd	r18, Y+5	; 0x05
    1896:	3e 81       	ldd	r19, Y+6	; 0x06
    1898:	22 30       	cpi	r18, 0x02	; 2
    189a:	31 05       	cpc	r19, r1
    189c:	2c f4       	brge	.+10     	; 0x18a8 <DIO_u8SetPinValue+0x14a>
    189e:	8d 81       	ldd	r24, Y+5	; 0x05
    18a0:	9e 81       	ldd	r25, Y+6	; 0x06
    18a2:	00 97       	sbiw	r24, 0x00	; 0
    18a4:	61 f0       	breq	.+24     	; 0x18be <DIO_u8SetPinValue+0x160>
    18a6:	5b c0       	rjmp	.+182    	; 0x195e <DIO_u8SetPinValue+0x200>
    18a8:	2d 81       	ldd	r18, Y+5	; 0x05
    18aa:	3e 81       	ldd	r19, Y+6	; 0x06
    18ac:	22 30       	cpi	r18, 0x02	; 2
    18ae:	31 05       	cpc	r19, r1
    18b0:	71 f1       	breq	.+92     	; 0x190e <DIO_u8SetPinValue+0x1b0>
    18b2:	8d 81       	ldd	r24, Y+5	; 0x05
    18b4:	9e 81       	ldd	r25, Y+6	; 0x06
    18b6:	83 30       	cpi	r24, 0x03	; 3
    18b8:	91 05       	cpc	r25, r1
    18ba:	e9 f1       	breq	.+122    	; 0x1936 <DIO_u8SetPinValue+0x1d8>
    18bc:	50 c0       	rjmp	.+160    	; 0x195e <DIO_u8SetPinValue+0x200>
			{
					case DIO_u8PORTA:SET_BIT(PORTA,Copy_u8Pin);break;
    18be:	ab e3       	ldi	r26, 0x3B	; 59
    18c0:	b0 e0       	ldi	r27, 0x00	; 0
    18c2:	eb e3       	ldi	r30, 0x3B	; 59
    18c4:	f0 e0       	ldi	r31, 0x00	; 0
    18c6:	80 81       	ld	r24, Z
    18c8:	48 2f       	mov	r20, r24
    18ca:	8b 81       	ldd	r24, Y+3	; 0x03
    18cc:	28 2f       	mov	r18, r24
    18ce:	30 e0       	ldi	r19, 0x00	; 0
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	90 e0       	ldi	r25, 0x00	; 0
    18d4:	02 2e       	mov	r0, r18
    18d6:	02 c0       	rjmp	.+4      	; 0x18dc <DIO_u8SetPinValue+0x17e>
    18d8:	88 0f       	add	r24, r24
    18da:	99 1f       	adc	r25, r25
    18dc:	0a 94       	dec	r0
    18de:	e2 f7       	brpl	.-8      	; 0x18d8 <DIO_u8SetPinValue+0x17a>
    18e0:	84 2b       	or	r24, r20
    18e2:	8c 93       	st	X, r24
    18e4:	41 c0       	rjmp	.+130    	; 0x1968 <DIO_u8SetPinValue+0x20a>
					case DIO_u8PORTB:SET_BIT(PORTB,Copy_u8Pin);break;
    18e6:	a8 e3       	ldi	r26, 0x38	; 56
    18e8:	b0 e0       	ldi	r27, 0x00	; 0
    18ea:	e8 e3       	ldi	r30, 0x38	; 56
    18ec:	f0 e0       	ldi	r31, 0x00	; 0
    18ee:	80 81       	ld	r24, Z
    18f0:	48 2f       	mov	r20, r24
    18f2:	8b 81       	ldd	r24, Y+3	; 0x03
    18f4:	28 2f       	mov	r18, r24
    18f6:	30 e0       	ldi	r19, 0x00	; 0
    18f8:	81 e0       	ldi	r24, 0x01	; 1
    18fa:	90 e0       	ldi	r25, 0x00	; 0
    18fc:	02 2e       	mov	r0, r18
    18fe:	02 c0       	rjmp	.+4      	; 0x1904 <DIO_u8SetPinValue+0x1a6>
    1900:	88 0f       	add	r24, r24
    1902:	99 1f       	adc	r25, r25
    1904:	0a 94       	dec	r0
    1906:	e2 f7       	brpl	.-8      	; 0x1900 <DIO_u8SetPinValue+0x1a2>
    1908:	84 2b       	or	r24, r20
    190a:	8c 93       	st	X, r24
    190c:	2d c0       	rjmp	.+90     	; 0x1968 <DIO_u8SetPinValue+0x20a>
					case DIO_u8PORTC:SET_BIT(PORTC,Copy_u8Pin);break;
    190e:	a5 e3       	ldi	r26, 0x35	; 53
    1910:	b0 e0       	ldi	r27, 0x00	; 0
    1912:	e5 e3       	ldi	r30, 0x35	; 53
    1914:	f0 e0       	ldi	r31, 0x00	; 0
    1916:	80 81       	ld	r24, Z
    1918:	48 2f       	mov	r20, r24
    191a:	8b 81       	ldd	r24, Y+3	; 0x03
    191c:	28 2f       	mov	r18, r24
    191e:	30 e0       	ldi	r19, 0x00	; 0
    1920:	81 e0       	ldi	r24, 0x01	; 1
    1922:	90 e0       	ldi	r25, 0x00	; 0
    1924:	02 2e       	mov	r0, r18
    1926:	02 c0       	rjmp	.+4      	; 0x192c <DIO_u8SetPinValue+0x1ce>
    1928:	88 0f       	add	r24, r24
    192a:	99 1f       	adc	r25, r25
    192c:	0a 94       	dec	r0
    192e:	e2 f7       	brpl	.-8      	; 0x1928 <DIO_u8SetPinValue+0x1ca>
    1930:	84 2b       	or	r24, r20
    1932:	8c 93       	st	X, r24
    1934:	19 c0       	rjmp	.+50     	; 0x1968 <DIO_u8SetPinValue+0x20a>
					case DIO_u8PORTD:SET_BIT(PORTD,Copy_u8Pin);break;
    1936:	a2 e3       	ldi	r26, 0x32	; 50
    1938:	b0 e0       	ldi	r27, 0x00	; 0
    193a:	e2 e3       	ldi	r30, 0x32	; 50
    193c:	f0 e0       	ldi	r31, 0x00	; 0
    193e:	80 81       	ld	r24, Z
    1940:	48 2f       	mov	r20, r24
    1942:	8b 81       	ldd	r24, Y+3	; 0x03
    1944:	28 2f       	mov	r18, r24
    1946:	30 e0       	ldi	r19, 0x00	; 0
    1948:	81 e0       	ldi	r24, 0x01	; 1
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	02 2e       	mov	r0, r18
    194e:	02 c0       	rjmp	.+4      	; 0x1954 <DIO_u8SetPinValue+0x1f6>
    1950:	88 0f       	add	r24, r24
    1952:	99 1f       	adc	r25, r25
    1954:	0a 94       	dec	r0
    1956:	e2 f7       	brpl	.-8      	; 0x1950 <DIO_u8SetPinValue+0x1f2>
    1958:	84 2b       	or	r24, r20
    195a:	8c 93       	st	X, r24
    195c:	05 c0       	rjmp	.+10     	; 0x1968 <DIO_u8SetPinValue+0x20a>
					default:Local_u8ErroState = 1 ; break;
    195e:	81 e0       	ldi	r24, 0x01	; 1
    1960:	89 83       	std	Y+1, r24	; 0x01
    1962:	02 c0       	rjmp	.+4      	; 0x1968 <DIO_u8SetPinValue+0x20a>
					
			}
		}
		else 
		{
			Local_u8ErroState = 1 ; 
    1964:	81 e0       	ldi	r24, 0x01	; 1
    1966:	89 83       	std	Y+1, r24	; 0x01
			
		}
		
	}
	return Local_u8ErroState ;
    1968:	89 81       	ldd	r24, Y+1	; 0x01
	
}// end of set pin value function 
    196a:	28 96       	adiw	r28, 0x08	; 8
    196c:	0f b6       	in	r0, 0x3f	; 63
    196e:	f8 94       	cli
    1970:	de bf       	out	0x3e, r29	; 62
    1972:	0f be       	out	0x3f, r0	; 63
    1974:	cd bf       	out	0x3d, r28	; 61
    1976:	cf 91       	pop	r28
    1978:	df 91       	pop	r29
    197a:	08 95       	ret

0000197c <DIO_u8SetPortValue>:


/*function to set port value high or low */
u8 DIO_u8SetPortValue(u8 Copy_u8Port , u8 Copy_u8Value)
{
    197c:	df 93       	push	r29
    197e:	cf 93       	push	r28
    1980:	00 d0       	rcall	.+0      	; 0x1982 <DIO_u8SetPortValue+0x6>
    1982:	00 d0       	rcall	.+0      	; 0x1984 <DIO_u8SetPortValue+0x8>
    1984:	0f 92       	push	r0
    1986:	cd b7       	in	r28, 0x3d	; 61
    1988:	de b7       	in	r29, 0x3e	; 62
    198a:	8a 83       	std	Y+2, r24	; 0x02
    198c:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErroState = 0 ;
    198e:	19 82       	std	Y+1, r1	; 0x01
	 switch(Copy_u8Port)
    1990:	8a 81       	ldd	r24, Y+2	; 0x02
    1992:	28 2f       	mov	r18, r24
    1994:	30 e0       	ldi	r19, 0x00	; 0
    1996:	3d 83       	std	Y+5, r19	; 0x05
    1998:	2c 83       	std	Y+4, r18	; 0x04
    199a:	8c 81       	ldd	r24, Y+4	; 0x04
    199c:	9d 81       	ldd	r25, Y+5	; 0x05
    199e:	81 30       	cpi	r24, 0x01	; 1
    19a0:	91 05       	cpc	r25, r1
    19a2:	d1 f0       	breq	.+52     	; 0x19d8 <DIO_u8SetPortValue+0x5c>
    19a4:	2c 81       	ldd	r18, Y+4	; 0x04
    19a6:	3d 81       	ldd	r19, Y+5	; 0x05
    19a8:	22 30       	cpi	r18, 0x02	; 2
    19aa:	31 05       	cpc	r19, r1
    19ac:	2c f4       	brge	.+10     	; 0x19b8 <DIO_u8SetPortValue+0x3c>
    19ae:	8c 81       	ldd	r24, Y+4	; 0x04
    19b0:	9d 81       	ldd	r25, Y+5	; 0x05
    19b2:	00 97       	sbiw	r24, 0x00	; 0
    19b4:	61 f0       	breq	.+24     	; 0x19ce <DIO_u8SetPortValue+0x52>
    19b6:	1f c0       	rjmp	.+62     	; 0x19f6 <DIO_u8SetPortValue+0x7a>
    19b8:	2c 81       	ldd	r18, Y+4	; 0x04
    19ba:	3d 81       	ldd	r19, Y+5	; 0x05
    19bc:	22 30       	cpi	r18, 0x02	; 2
    19be:	31 05       	cpc	r19, r1
    19c0:	81 f0       	breq	.+32     	; 0x19e2 <DIO_u8SetPortValue+0x66>
    19c2:	8c 81       	ldd	r24, Y+4	; 0x04
    19c4:	9d 81       	ldd	r25, Y+5	; 0x05
    19c6:	83 30       	cpi	r24, 0x03	; 3
    19c8:	91 05       	cpc	r25, r1
    19ca:	81 f0       	breq	.+32     	; 0x19ec <DIO_u8SetPortValue+0x70>
    19cc:	14 c0       	rjmp	.+40     	; 0x19f6 <DIO_u8SetPortValue+0x7a>
	 {
		 case DIO_u8PORTA : PORTA = Copy_u8Value ; break; 
    19ce:	eb e3       	ldi	r30, 0x3B	; 59
    19d0:	f0 e0       	ldi	r31, 0x00	; 0
    19d2:	8b 81       	ldd	r24, Y+3	; 0x03
    19d4:	80 83       	st	Z, r24
    19d6:	11 c0       	rjmp	.+34     	; 0x19fa <DIO_u8SetPortValue+0x7e>
		 case DIO_u8PORTB : PORTB = Copy_u8Value ; break; 
    19d8:	e8 e3       	ldi	r30, 0x38	; 56
    19da:	f0 e0       	ldi	r31, 0x00	; 0
    19dc:	8b 81       	ldd	r24, Y+3	; 0x03
    19de:	80 83       	st	Z, r24
    19e0:	0c c0       	rjmp	.+24     	; 0x19fa <DIO_u8SetPortValue+0x7e>
		 case DIO_u8PORTC : PORTC = Copy_u8Value ; break; 
    19e2:	e5 e3       	ldi	r30, 0x35	; 53
    19e4:	f0 e0       	ldi	r31, 0x00	; 0
    19e6:	8b 81       	ldd	r24, Y+3	; 0x03
    19e8:	80 83       	st	Z, r24
    19ea:	07 c0       	rjmp	.+14     	; 0x19fa <DIO_u8SetPortValue+0x7e>
		 case DIO_u8PORTD : PORTD = Copy_u8Value ; break;
    19ec:	e2 e3       	ldi	r30, 0x32	; 50
    19ee:	f0 e0       	ldi	r31, 0x00	; 0
    19f0:	8b 81       	ldd	r24, Y+3	; 0x03
    19f2:	80 83       	st	Z, r24
    19f4:	02 c0       	rjmp	.+4      	; 0x19fa <DIO_u8SetPortValue+0x7e>
		 default: Local_u8ErroState = 1 ; break;
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	89 83       	std	Y+1, r24	; 0x01
	 } 
	return Local_u8ErroState ; 
    19fa:	89 81       	ldd	r24, Y+1	; 0x01
}// end of set port value function 
    19fc:	0f 90       	pop	r0
    19fe:	0f 90       	pop	r0
    1a00:	0f 90       	pop	r0
    1a02:	0f 90       	pop	r0
    1a04:	0f 90       	pop	r0
    1a06:	cf 91       	pop	r28
    1a08:	df 91       	pop	r29
    1a0a:	08 95       	ret

00001a0c <DIO_u8GetPinValue>:


/*function to read pin value high or low */
u8 DIO_u8GetPinValue(u8 Copy_u8Port , u8 Copy_u8Pin , u8* Copy_Pu8Value)
{
    1a0c:	df 93       	push	r29
    1a0e:	cf 93       	push	r28
    1a10:	cd b7       	in	r28, 0x3d	; 61
    1a12:	de b7       	in	r29, 0x3e	; 62
    1a14:	27 97       	sbiw	r28, 0x07	; 7
    1a16:	0f b6       	in	r0, 0x3f	; 63
    1a18:	f8 94       	cli
    1a1a:	de bf       	out	0x3e, r29	; 62
    1a1c:	0f be       	out	0x3f, r0	; 63
    1a1e:	cd bf       	out	0x3d, r28	; 61
    1a20:	8a 83       	std	Y+2, r24	; 0x02
    1a22:	6b 83       	std	Y+3, r22	; 0x03
    1a24:	5d 83       	std	Y+5, r21	; 0x05
    1a26:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErroState = 0 ; 
    1a28:	19 82       	std	Y+1, r1	; 0x01
	
	if((Copy_Pu8Value!= NULL) && (Copy_u8Pin <= DIO_u8PIN7))
    1a2a:	8c 81       	ldd	r24, Y+4	; 0x04
    1a2c:	9d 81       	ldd	r25, Y+5	; 0x05
    1a2e:	00 97       	sbiw	r24, 0x00	; 0
    1a30:	09 f4       	brne	.+2      	; 0x1a34 <DIO_u8GetPinValue+0x28>
    1a32:	78 c0       	rjmp	.+240    	; 0x1b24 <DIO_u8GetPinValue+0x118>
    1a34:	8b 81       	ldd	r24, Y+3	; 0x03
    1a36:	88 30       	cpi	r24, 0x08	; 8
    1a38:	08 f0       	brcs	.+2      	; 0x1a3c <DIO_u8GetPinValue+0x30>
    1a3a:	74 c0       	rjmp	.+232    	; 0x1b24 <DIO_u8GetPinValue+0x118>
	{
		switch (Copy_u8Port)
    1a3c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a3e:	28 2f       	mov	r18, r24
    1a40:	30 e0       	ldi	r19, 0x00	; 0
    1a42:	3f 83       	std	Y+7, r19	; 0x07
    1a44:	2e 83       	std	Y+6, r18	; 0x06
    1a46:	4e 81       	ldd	r20, Y+6	; 0x06
    1a48:	5f 81       	ldd	r21, Y+7	; 0x07
    1a4a:	41 30       	cpi	r20, 0x01	; 1
    1a4c:	51 05       	cpc	r21, r1
    1a4e:	59 f1       	breq	.+86     	; 0x1aa6 <DIO_u8GetPinValue+0x9a>
    1a50:	8e 81       	ldd	r24, Y+6	; 0x06
    1a52:	9f 81       	ldd	r25, Y+7	; 0x07
    1a54:	82 30       	cpi	r24, 0x02	; 2
    1a56:	91 05       	cpc	r25, r1
    1a58:	34 f4       	brge	.+12     	; 0x1a66 <DIO_u8GetPinValue+0x5a>
    1a5a:	2e 81       	ldd	r18, Y+6	; 0x06
    1a5c:	3f 81       	ldd	r19, Y+7	; 0x07
    1a5e:	21 15       	cp	r18, r1
    1a60:	31 05       	cpc	r19, r1
    1a62:	69 f0       	breq	.+26     	; 0x1a7e <DIO_u8GetPinValue+0x72>
    1a64:	5c c0       	rjmp	.+184    	; 0x1b1e <DIO_u8GetPinValue+0x112>
    1a66:	4e 81       	ldd	r20, Y+6	; 0x06
    1a68:	5f 81       	ldd	r21, Y+7	; 0x07
    1a6a:	42 30       	cpi	r20, 0x02	; 2
    1a6c:	51 05       	cpc	r21, r1
    1a6e:	79 f1       	breq	.+94     	; 0x1ace <DIO_u8GetPinValue+0xc2>
    1a70:	8e 81       	ldd	r24, Y+6	; 0x06
    1a72:	9f 81       	ldd	r25, Y+7	; 0x07
    1a74:	83 30       	cpi	r24, 0x03	; 3
    1a76:	91 05       	cpc	r25, r1
    1a78:	09 f4       	brne	.+2      	; 0x1a7c <DIO_u8GetPinValue+0x70>
    1a7a:	3d c0       	rjmp	.+122    	; 0x1af6 <DIO_u8GetPinValue+0xea>
    1a7c:	50 c0       	rjmp	.+160    	; 0x1b1e <DIO_u8GetPinValue+0x112>
		{
			case DIO_u8PORTA :*Copy_Pu8Value = GET_BIT(PINA,Copy_u8Pin); break; 
    1a7e:	e9 e3       	ldi	r30, 0x39	; 57
    1a80:	f0 e0       	ldi	r31, 0x00	; 0
    1a82:	80 81       	ld	r24, Z
    1a84:	28 2f       	mov	r18, r24
    1a86:	30 e0       	ldi	r19, 0x00	; 0
    1a88:	8b 81       	ldd	r24, Y+3	; 0x03
    1a8a:	88 2f       	mov	r24, r24
    1a8c:	90 e0       	ldi	r25, 0x00	; 0
    1a8e:	a9 01       	movw	r20, r18
    1a90:	02 c0       	rjmp	.+4      	; 0x1a96 <DIO_u8GetPinValue+0x8a>
    1a92:	55 95       	asr	r21
    1a94:	47 95       	ror	r20
    1a96:	8a 95       	dec	r24
    1a98:	e2 f7       	brpl	.-8      	; 0x1a92 <DIO_u8GetPinValue+0x86>
    1a9a:	ca 01       	movw	r24, r20
    1a9c:	81 70       	andi	r24, 0x01	; 1
    1a9e:	ec 81       	ldd	r30, Y+4	; 0x04
    1aa0:	fd 81       	ldd	r31, Y+5	; 0x05
    1aa2:	80 83       	st	Z, r24
    1aa4:	41 c0       	rjmp	.+130    	; 0x1b28 <DIO_u8GetPinValue+0x11c>
			case DIO_u8PORTB :*Copy_Pu8Value = GET_BIT(PINB,Copy_u8Pin); break;
    1aa6:	e6 e3       	ldi	r30, 0x36	; 54
    1aa8:	f0 e0       	ldi	r31, 0x00	; 0
    1aaa:	80 81       	ld	r24, Z
    1aac:	28 2f       	mov	r18, r24
    1aae:	30 e0       	ldi	r19, 0x00	; 0
    1ab0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab2:	88 2f       	mov	r24, r24
    1ab4:	90 e0       	ldi	r25, 0x00	; 0
    1ab6:	a9 01       	movw	r20, r18
    1ab8:	02 c0       	rjmp	.+4      	; 0x1abe <DIO_u8GetPinValue+0xb2>
    1aba:	55 95       	asr	r21
    1abc:	47 95       	ror	r20
    1abe:	8a 95       	dec	r24
    1ac0:	e2 f7       	brpl	.-8      	; 0x1aba <DIO_u8GetPinValue+0xae>
    1ac2:	ca 01       	movw	r24, r20
    1ac4:	81 70       	andi	r24, 0x01	; 1
    1ac6:	ec 81       	ldd	r30, Y+4	; 0x04
    1ac8:	fd 81       	ldd	r31, Y+5	; 0x05
    1aca:	80 83       	st	Z, r24
    1acc:	2d c0       	rjmp	.+90     	; 0x1b28 <DIO_u8GetPinValue+0x11c>
			case DIO_u8PORTC :*Copy_Pu8Value = GET_BIT(PINC,Copy_u8Pin); break;
    1ace:	e3 e3       	ldi	r30, 0x33	; 51
    1ad0:	f0 e0       	ldi	r31, 0x00	; 0
    1ad2:	80 81       	ld	r24, Z
    1ad4:	28 2f       	mov	r18, r24
    1ad6:	30 e0       	ldi	r19, 0x00	; 0
    1ad8:	8b 81       	ldd	r24, Y+3	; 0x03
    1ada:	88 2f       	mov	r24, r24
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	a9 01       	movw	r20, r18
    1ae0:	02 c0       	rjmp	.+4      	; 0x1ae6 <DIO_u8GetPinValue+0xda>
    1ae2:	55 95       	asr	r21
    1ae4:	47 95       	ror	r20
    1ae6:	8a 95       	dec	r24
    1ae8:	e2 f7       	brpl	.-8      	; 0x1ae2 <DIO_u8GetPinValue+0xd6>
    1aea:	ca 01       	movw	r24, r20
    1aec:	81 70       	andi	r24, 0x01	; 1
    1aee:	ec 81       	ldd	r30, Y+4	; 0x04
    1af0:	fd 81       	ldd	r31, Y+5	; 0x05
    1af2:	80 83       	st	Z, r24
    1af4:	19 c0       	rjmp	.+50     	; 0x1b28 <DIO_u8GetPinValue+0x11c>
			case DIO_u8PORTD :*Copy_Pu8Value = GET_BIT(PIND,Copy_u8Pin); break;
    1af6:	e0 e3       	ldi	r30, 0x30	; 48
    1af8:	f0 e0       	ldi	r31, 0x00	; 0
    1afa:	80 81       	ld	r24, Z
    1afc:	28 2f       	mov	r18, r24
    1afe:	30 e0       	ldi	r19, 0x00	; 0
    1b00:	8b 81       	ldd	r24, Y+3	; 0x03
    1b02:	88 2f       	mov	r24, r24
    1b04:	90 e0       	ldi	r25, 0x00	; 0
    1b06:	a9 01       	movw	r20, r18
    1b08:	02 c0       	rjmp	.+4      	; 0x1b0e <DIO_u8GetPinValue+0x102>
    1b0a:	55 95       	asr	r21
    1b0c:	47 95       	ror	r20
    1b0e:	8a 95       	dec	r24
    1b10:	e2 f7       	brpl	.-8      	; 0x1b0a <DIO_u8GetPinValue+0xfe>
    1b12:	ca 01       	movw	r24, r20
    1b14:	81 70       	andi	r24, 0x01	; 1
    1b16:	ec 81       	ldd	r30, Y+4	; 0x04
    1b18:	fd 81       	ldd	r31, Y+5	; 0x05
    1b1a:	80 83       	st	Z, r24
    1b1c:	05 c0       	rjmp	.+10     	; 0x1b28 <DIO_u8GetPinValue+0x11c>
			default:Local_u8ErroState =1 ; 
    1b1e:	81 e0       	ldi	r24, 0x01	; 1
    1b20:	89 83       	std	Y+1, r24	; 0x01
    1b22:	02 c0       	rjmp	.+4      	; 0x1b28 <DIO_u8GetPinValue+0x11c>
		}
		
	}
	else 
	{
		Local_u8ErroState = 1; 
    1b24:	81 e0       	ldi	r24, 0x01	; 1
    1b26:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErroState ; 
    1b28:	89 81       	ldd	r24, Y+1	; 0x01
	

}// end of get pin value function 
    1b2a:	27 96       	adiw	r28, 0x07	; 7
    1b2c:	0f b6       	in	r0, 0x3f	; 63
    1b2e:	f8 94       	cli
    1b30:	de bf       	out	0x3e, r29	; 62
    1b32:	0f be       	out	0x3f, r0	; 63
    1b34:	cd bf       	out	0x3d, r28	; 61
    1b36:	cf 91       	pop	r28
    1b38:	df 91       	pop	r29
    1b3a:	08 95       	ret

00001b3c <DIO_u8TogglePinValue>:


/*function to toggle a pin */
u8 DIO_u8TogglePinValue(u8 Copy_u8Port , u8 Copy_u8Pin)
{
    1b3c:	df 93       	push	r29
    1b3e:	cf 93       	push	r28
    1b40:	00 d0       	rcall	.+0      	; 0x1b42 <DIO_u8TogglePinValue+0x6>
    1b42:	00 d0       	rcall	.+0      	; 0x1b44 <DIO_u8TogglePinValue+0x8>
    1b44:	0f 92       	push	r0
    1b46:	cd b7       	in	r28, 0x3d	; 61
    1b48:	de b7       	in	r29, 0x3e	; 62
    1b4a:	8a 83       	std	Y+2, r24	; 0x02
    1b4c:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErroState =0 ; 
    1b4e:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8Pin<= DIO_u8PIN7)
    1b50:	8b 81       	ldd	r24, Y+3	; 0x03
    1b52:	88 30       	cpi	r24, 0x08	; 8
    1b54:	08 f0       	brcs	.+2      	; 0x1b58 <DIO_u8TogglePinValue+0x1c>
    1b56:	71 c0       	rjmp	.+226    	; 0x1c3a <DIO_u8TogglePinValue+0xfe>
	{
		switch(Copy_u8Port)
    1b58:	8a 81       	ldd	r24, Y+2	; 0x02
    1b5a:	28 2f       	mov	r18, r24
    1b5c:	30 e0       	ldi	r19, 0x00	; 0
    1b5e:	3d 83       	std	Y+5, r19	; 0x05
    1b60:	2c 83       	std	Y+4, r18	; 0x04
    1b62:	8c 81       	ldd	r24, Y+4	; 0x04
    1b64:	9d 81       	ldd	r25, Y+5	; 0x05
    1b66:	81 30       	cpi	r24, 0x01	; 1
    1b68:	91 05       	cpc	r25, r1
    1b6a:	49 f1       	breq	.+82     	; 0x1bbe <DIO_u8TogglePinValue+0x82>
    1b6c:	2c 81       	ldd	r18, Y+4	; 0x04
    1b6e:	3d 81       	ldd	r19, Y+5	; 0x05
    1b70:	22 30       	cpi	r18, 0x02	; 2
    1b72:	31 05       	cpc	r19, r1
    1b74:	2c f4       	brge	.+10     	; 0x1b80 <DIO_u8TogglePinValue+0x44>
    1b76:	8c 81       	ldd	r24, Y+4	; 0x04
    1b78:	9d 81       	ldd	r25, Y+5	; 0x05
    1b7a:	00 97       	sbiw	r24, 0x00	; 0
    1b7c:	61 f0       	breq	.+24     	; 0x1b96 <DIO_u8TogglePinValue+0x5a>
    1b7e:	5b c0       	rjmp	.+182    	; 0x1c36 <DIO_u8TogglePinValue+0xfa>
    1b80:	2c 81       	ldd	r18, Y+4	; 0x04
    1b82:	3d 81       	ldd	r19, Y+5	; 0x05
    1b84:	22 30       	cpi	r18, 0x02	; 2
    1b86:	31 05       	cpc	r19, r1
    1b88:	71 f1       	breq	.+92     	; 0x1be6 <DIO_u8TogglePinValue+0xaa>
    1b8a:	8c 81       	ldd	r24, Y+4	; 0x04
    1b8c:	9d 81       	ldd	r25, Y+5	; 0x05
    1b8e:	83 30       	cpi	r24, 0x03	; 3
    1b90:	91 05       	cpc	r25, r1
    1b92:	e9 f1       	breq	.+122    	; 0x1c0e <DIO_u8TogglePinValue+0xd2>
    1b94:	50 c0       	rjmp	.+160    	; 0x1c36 <DIO_u8TogglePinValue+0xfa>
		{
				case DIO_u8PORTA : TOGGLE_BIT(PORTA,Copy_u8Pin); break;
    1b96:	ab e3       	ldi	r26, 0x3B	; 59
    1b98:	b0 e0       	ldi	r27, 0x00	; 0
    1b9a:	eb e3       	ldi	r30, 0x3B	; 59
    1b9c:	f0 e0       	ldi	r31, 0x00	; 0
    1b9e:	80 81       	ld	r24, Z
    1ba0:	48 2f       	mov	r20, r24
    1ba2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ba4:	28 2f       	mov	r18, r24
    1ba6:	30 e0       	ldi	r19, 0x00	; 0
    1ba8:	81 e0       	ldi	r24, 0x01	; 1
    1baa:	90 e0       	ldi	r25, 0x00	; 0
    1bac:	02 2e       	mov	r0, r18
    1bae:	02 c0       	rjmp	.+4      	; 0x1bb4 <DIO_u8TogglePinValue+0x78>
    1bb0:	88 0f       	add	r24, r24
    1bb2:	99 1f       	adc	r25, r25
    1bb4:	0a 94       	dec	r0
    1bb6:	e2 f7       	brpl	.-8      	; 0x1bb0 <DIO_u8TogglePinValue+0x74>
    1bb8:	84 27       	eor	r24, r20
    1bba:	8c 93       	st	X, r24
    1bbc:	3e c0       	rjmp	.+124    	; 0x1c3a <DIO_u8TogglePinValue+0xfe>
				case DIO_u8PORTB : TOGGLE_BIT(PORTB,Copy_u8Pin); break;
    1bbe:	a8 e3       	ldi	r26, 0x38	; 56
    1bc0:	b0 e0       	ldi	r27, 0x00	; 0
    1bc2:	e8 e3       	ldi	r30, 0x38	; 56
    1bc4:	f0 e0       	ldi	r31, 0x00	; 0
    1bc6:	80 81       	ld	r24, Z
    1bc8:	48 2f       	mov	r20, r24
    1bca:	8b 81       	ldd	r24, Y+3	; 0x03
    1bcc:	28 2f       	mov	r18, r24
    1bce:	30 e0       	ldi	r19, 0x00	; 0
    1bd0:	81 e0       	ldi	r24, 0x01	; 1
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	02 2e       	mov	r0, r18
    1bd6:	02 c0       	rjmp	.+4      	; 0x1bdc <DIO_u8TogglePinValue+0xa0>
    1bd8:	88 0f       	add	r24, r24
    1bda:	99 1f       	adc	r25, r25
    1bdc:	0a 94       	dec	r0
    1bde:	e2 f7       	brpl	.-8      	; 0x1bd8 <DIO_u8TogglePinValue+0x9c>
    1be0:	84 27       	eor	r24, r20
    1be2:	8c 93       	st	X, r24
    1be4:	2a c0       	rjmp	.+84     	; 0x1c3a <DIO_u8TogglePinValue+0xfe>
				case DIO_u8PORTC : TOGGLE_BIT(PORTC,Copy_u8Pin); break;
    1be6:	a5 e3       	ldi	r26, 0x35	; 53
    1be8:	b0 e0       	ldi	r27, 0x00	; 0
    1bea:	e5 e3       	ldi	r30, 0x35	; 53
    1bec:	f0 e0       	ldi	r31, 0x00	; 0
    1bee:	80 81       	ld	r24, Z
    1bf0:	48 2f       	mov	r20, r24
    1bf2:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf4:	28 2f       	mov	r18, r24
    1bf6:	30 e0       	ldi	r19, 0x00	; 0
    1bf8:	81 e0       	ldi	r24, 0x01	; 1
    1bfa:	90 e0       	ldi	r25, 0x00	; 0
    1bfc:	02 2e       	mov	r0, r18
    1bfe:	02 c0       	rjmp	.+4      	; 0x1c04 <DIO_u8TogglePinValue+0xc8>
    1c00:	88 0f       	add	r24, r24
    1c02:	99 1f       	adc	r25, r25
    1c04:	0a 94       	dec	r0
    1c06:	e2 f7       	brpl	.-8      	; 0x1c00 <DIO_u8TogglePinValue+0xc4>
    1c08:	84 27       	eor	r24, r20
    1c0a:	8c 93       	st	X, r24
    1c0c:	16 c0       	rjmp	.+44     	; 0x1c3a <DIO_u8TogglePinValue+0xfe>
				case DIO_u8PORTD : TOGGLE_BIT(PORTD,Copy_u8Pin); break;
    1c0e:	a2 e3       	ldi	r26, 0x32	; 50
    1c10:	b0 e0       	ldi	r27, 0x00	; 0
    1c12:	e2 e3       	ldi	r30, 0x32	; 50
    1c14:	f0 e0       	ldi	r31, 0x00	; 0
    1c16:	80 81       	ld	r24, Z
    1c18:	48 2f       	mov	r20, r24
    1c1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c1c:	28 2f       	mov	r18, r24
    1c1e:	30 e0       	ldi	r19, 0x00	; 0
    1c20:	81 e0       	ldi	r24, 0x01	; 1
    1c22:	90 e0       	ldi	r25, 0x00	; 0
    1c24:	02 2e       	mov	r0, r18
    1c26:	02 c0       	rjmp	.+4      	; 0x1c2c <DIO_u8TogglePinValue+0xf0>
    1c28:	88 0f       	add	r24, r24
    1c2a:	99 1f       	adc	r25, r25
    1c2c:	0a 94       	dec	r0
    1c2e:	e2 f7       	brpl	.-8      	; 0x1c28 <DIO_u8TogglePinValue+0xec>
    1c30:	84 27       	eor	r24, r20
    1c32:	8c 93       	st	X, r24
    1c34:	02 c0       	rjmp	.+4      	; 0x1c3a <DIO_u8TogglePinValue+0xfe>
				default: Local_u8ErroState =1 ;break;
    1c36:	81 e0       	ldi	r24, 0x01	; 1
    1c38:	89 83       	std	Y+1, r24	; 0x01
		}
	
	}
	return Local_u8ErroState ; 
    1c3a:	89 81       	ldd	r24, Y+1	; 0x01
	
}// end of toggle pin value function 
    1c3c:	0f 90       	pop	r0
    1c3e:	0f 90       	pop	r0
    1c40:	0f 90       	pop	r0
    1c42:	0f 90       	pop	r0
    1c44:	0f 90       	pop	r0
    1c46:	cf 91       	pop	r28
    1c48:	df 91       	pop	r29
    1c4a:	08 95       	ret

00001c4c <ADC_vidInit>:

static u16 *ADC_pu16Reading=NULL ;
static void(*ADC_pvCallBackNotficationFunc)(void)= NULL;  

void ADC_vidInit(void)
{
    1c4c:	df 93       	push	r29
    1c4e:	cf 93       	push	r28
    1c50:	cd b7       	in	r28, 0x3d	; 61
    1c52:	de b7       	in	r29, 0x3e	; 62
	/*AVCC as reference voltage */
	SET_BIT(ADMUX,ADMUX_REFS0);
    1c54:	a7 e2       	ldi	r26, 0x27	; 39
    1c56:	b0 e0       	ldi	r27, 0x00	; 0
    1c58:	e7 e2       	ldi	r30, 0x27	; 39
    1c5a:	f0 e0       	ldi	r31, 0x00	; 0
    1c5c:	80 81       	ld	r24, Z
    1c5e:	80 64       	ori	r24, 0x40	; 64
    1c60:	8c 93       	st	X, r24
	CLR_BIT(ADMUX,ADMUX_REFS1);
    1c62:	a7 e2       	ldi	r26, 0x27	; 39
    1c64:	b0 e0       	ldi	r27, 0x00	; 0
    1c66:	e7 e2       	ldi	r30, 0x27	; 39
    1c68:	f0 e0       	ldi	r31, 0x00	; 0
    1c6a:	80 81       	ld	r24, Z
    1c6c:	8f 77       	andi	r24, 0x7F	; 127
    1c6e:	8c 93       	st	X, r24
	/*choose left adjust result */
	SET_BIT(ADMUX,ADMUX_ADLAR); 
    1c70:	a7 e2       	ldi	r26, 0x27	; 39
    1c72:	b0 e0       	ldi	r27, 0x00	; 0
    1c74:	e7 e2       	ldi	r30, 0x27	; 39
    1c76:	f0 e0       	ldi	r31, 0x00	; 0
    1c78:	80 81       	ld	r24, Z
    1c7a:	80 62       	ori	r24, 0x20	; 32
    1c7c:	8c 93       	st	X, r24
	
	/*set prescaler to divide by 128*/
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
    1c7e:	a6 e2       	ldi	r26, 0x26	; 38
    1c80:	b0 e0       	ldi	r27, 0x00	; 0
    1c82:	e6 e2       	ldi	r30, 0x26	; 38
    1c84:	f0 e0       	ldi	r31, 0x00	; 0
    1c86:	80 81       	ld	r24, Z
    1c88:	84 60       	ori	r24, 0x04	; 4
    1c8a:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
    1c8c:	a6 e2       	ldi	r26, 0x26	; 38
    1c8e:	b0 e0       	ldi	r27, 0x00	; 0
    1c90:	e6 e2       	ldi	r30, 0x26	; 38
    1c92:	f0 e0       	ldi	r31, 0x00	; 0
    1c94:	80 81       	ld	r24, Z
    1c96:	82 60       	ori	r24, 0x02	; 2
    1c98:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,ADCSRA_ADPS0);
    1c9a:	a6 e2       	ldi	r26, 0x26	; 38
    1c9c:	b0 e0       	ldi	r27, 0x00	; 0
    1c9e:	e6 e2       	ldi	r30, 0x26	; 38
    1ca0:	f0 e0       	ldi	r31, 0x00	; 0
    1ca2:	80 81       	ld	r24, Z
    1ca4:	81 60       	ori	r24, 0x01	; 1
    1ca6:	8c 93       	st	X, r24

	/*enable ADC*/
	SET_BIT(ADCSRA,ADCSRA_ADEN); 
    1ca8:	a6 e2       	ldi	r26, 0x26	; 38
    1caa:	b0 e0       	ldi	r27, 0x00	; 0
    1cac:	e6 e2       	ldi	r30, 0x26	; 38
    1cae:	f0 e0       	ldi	r31, 0x00	; 0
    1cb0:	80 81       	ld	r24, Z
    1cb2:	80 68       	ori	r24, 0x80	; 128
    1cb4:	8c 93       	st	X, r24
	
}
    1cb6:	cf 91       	pop	r28
    1cb8:	df 91       	pop	r29
    1cba:	08 95       	ret

00001cbc <ADC_u8StartConversionSynch>:

u8 ADC_u8StartConversionSynch(u8 copy_u8Channel, u16 *copy_pu168Reading)
{
    1cbc:	df 93       	push	r29
    1cbe:	cf 93       	push	r28
    1cc0:	cd b7       	in	r28, 0x3d	; 61
    1cc2:	de b7       	in	r29, 0x3e	; 62
    1cc4:	28 97       	sbiw	r28, 0x08	; 8
    1cc6:	0f b6       	in	r0, 0x3f	; 63
    1cc8:	f8 94       	cli
    1cca:	de bf       	out	0x3e, r29	; 62
    1ccc:	0f be       	out	0x3f, r0	; 63
    1cce:	cd bf       	out	0x3d, r28	; 61
    1cd0:	8e 83       	std	Y+6, r24	; 0x06
    1cd2:	78 87       	std	Y+8, r23	; 0x08
    1cd4:	6f 83       	std	Y+7, r22	; 0x07
	u32 Local_u32Counter=0; 
    1cd6:	1a 82       	std	Y+2, r1	; 0x02
    1cd8:	1b 82       	std	Y+3, r1	; 0x03
    1cda:	1c 82       	std	Y+4, r1	; 0x04
    1cdc:	1d 82       	std	Y+5, r1	; 0x05
	u8 Local_u8ErrorState=0 ;
    1cde:	19 82       	std	Y+1, r1	; 0x01
	/*u8  Local_u8ErrorState= Ok ; */
	
	/*Clear the MUX bits in ADMUX register*/
	ADMUX&=0b11100000; 
    1ce0:	a7 e2       	ldi	r26, 0x27	; 39
    1ce2:	b0 e0       	ldi	r27, 0x00	; 0
    1ce4:	e7 e2       	ldi	r30, 0x27	; 39
    1ce6:	f0 e0       	ldi	r31, 0x00	; 0
    1ce8:	80 81       	ld	r24, Z
    1cea:	80 7e       	andi	r24, 0xE0	; 224
    1cec:	8c 93       	st	X, r24
	/*set the required channel at ADMUX */
	ADMUX|=copy_u8Channel;
    1cee:	a7 e2       	ldi	r26, 0x27	; 39
    1cf0:	b0 e0       	ldi	r27, 0x00	; 0
    1cf2:	e7 e2       	ldi	r30, 0x27	; 39
    1cf4:	f0 e0       	ldi	r31, 0x00	; 0
    1cf6:	90 81       	ld	r25, Z
    1cf8:	8e 81       	ldd	r24, Y+6	; 0x06
    1cfa:	89 2b       	or	r24, r25
    1cfc:	8c 93       	st	X, r24
	/*start conversion*/
    SET_BIT(ADCSRA,ADCSRA_ADSC); 
    1cfe:	a6 e2       	ldi	r26, 0x26	; 38
    1d00:	b0 e0       	ldi	r27, 0x00	; 0
    1d02:	e6 e2       	ldi	r30, 0x26	; 38
    1d04:	f0 e0       	ldi	r31, 0x00	; 0
    1d06:	80 81       	ld	r24, Z
    1d08:	80 64       	ori	r24, 0x40	; 64
    1d0a:	8c 93       	st	X, r24
    1d0c:	0b c0       	rjmp	.+22     	; 0x1d24 <ADC_u8StartConversionSynch+0x68>
	/*busy wait until the conversion complete flag is set  or reaching timeout*/
    while((GET_BIT(ADCSRA,ADCSRA_ADIF))==0 && (Local_u32Counter!=ADC_u32TIME_OUT))  
	{
		Local_u32Counter++;
    1d0e:	8a 81       	ldd	r24, Y+2	; 0x02
    1d10:	9b 81       	ldd	r25, Y+3	; 0x03
    1d12:	ac 81       	ldd	r26, Y+4	; 0x04
    1d14:	bd 81       	ldd	r27, Y+5	; 0x05
    1d16:	01 96       	adiw	r24, 0x01	; 1
    1d18:	a1 1d       	adc	r26, r1
    1d1a:	b1 1d       	adc	r27, r1
    1d1c:	8a 83       	std	Y+2, r24	; 0x02
    1d1e:	9b 83       	std	Y+3, r25	; 0x03
    1d20:	ac 83       	std	Y+4, r26	; 0x04
    1d22:	bd 83       	std	Y+5, r27	; 0x05
	/*set the required channel at ADMUX */
	ADMUX|=copy_u8Channel;
	/*start conversion*/
    SET_BIT(ADCSRA,ADCSRA_ADSC); 
	/*busy wait until the conversion complete flag is set  or reaching timeout*/
    while((GET_BIT(ADCSRA,ADCSRA_ADIF))==0 && (Local_u32Counter!=ADC_u32TIME_OUT))  
    1d24:	e6 e2       	ldi	r30, 0x26	; 38
    1d26:	f0 e0       	ldi	r31, 0x00	; 0
    1d28:	80 81       	ld	r24, Z
    1d2a:	82 95       	swap	r24
    1d2c:	8f 70       	andi	r24, 0x0F	; 15
    1d2e:	88 2f       	mov	r24, r24
    1d30:	90 e0       	ldi	r25, 0x00	; 0
    1d32:	81 70       	andi	r24, 0x01	; 1
    1d34:	90 70       	andi	r25, 0x00	; 0
    1d36:	00 97       	sbiw	r24, 0x00	; 0
    1d38:	61 f4       	brne	.+24     	; 0x1d52 <ADC_u8StartConversionSynch+0x96>
    1d3a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d3c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d3e:	ac 81       	ldd	r26, Y+4	; 0x04
    1d40:	bd 81       	ldd	r27, Y+5	; 0x05
    1d42:	80 35       	cpi	r24, 0x50	; 80
    1d44:	23 ec       	ldi	r18, 0xC3	; 195
    1d46:	92 07       	cpc	r25, r18
    1d48:	20 e0       	ldi	r18, 0x00	; 0
    1d4a:	a2 07       	cpc	r26, r18
    1d4c:	20 e0       	ldi	r18, 0x00	; 0
    1d4e:	b2 07       	cpc	r27, r18
    1d50:	f1 f6       	brne	.-68     	; 0x1d0e <ADC_u8StartConversionSynch+0x52>
	{
		Local_u32Counter++;
	}
	/*check the reason of while loop broken */
	if (Local_u32Counter == ADC_u32TIME_OUT)
    1d52:	8a 81       	ldd	r24, Y+2	; 0x02
    1d54:	9b 81       	ldd	r25, Y+3	; 0x03
    1d56:	ac 81       	ldd	r26, Y+4	; 0x04
    1d58:	bd 81       	ldd	r27, Y+5	; 0x05
    1d5a:	80 35       	cpi	r24, 0x50	; 80
    1d5c:	23 ec       	ldi	r18, 0xC3	; 195
    1d5e:	92 07       	cpc	r25, r18
    1d60:	20 e0       	ldi	r18, 0x00	; 0
    1d62:	a2 07       	cpc	r26, r18
    1d64:	20 e0       	ldi	r18, 0x00	; 0
    1d66:	b2 07       	cpc	r27, r18
    1d68:	19 f4       	brne	.+6      	; 0x1d70 <ADC_u8StartConversionSynch+0xb4>
	{
	  // loop is broken because timeout is reached 
	  Local_u8ErrorState = NOT_OK ; 
    1d6a:	81 e0       	ldi	r24, 0x01	; 1
    1d6c:	89 83       	std	Y+1, r24	; 0x01
    1d6e:	10 c0       	rjmp	.+32     	; 0x1d90 <ADC_u8StartConversionSynch+0xd4>
	else
 	{
		/*loop is broken because flag is raised */
		
		/*clear the conversion complete flag*/
		SET_BIT(ADCSRA,ADCSRA_ADIF);
    1d70:	a6 e2       	ldi	r26, 0x26	; 38
    1d72:	b0 e0       	ldi	r27, 0x00	; 0
    1d74:	e6 e2       	ldi	r30, 0x26	; 38
    1d76:	f0 e0       	ldi	r31, 0x00	; 0
    1d78:	80 81       	ld	r24, Z
    1d7a:	80 61       	ori	r24, 0x10	; 16
    1d7c:	8c 93       	st	X, r24
		/*return the reading value*/
		*copy_pu168Reading= ADCH ; 
    1d7e:	e5 e2       	ldi	r30, 0x25	; 37
    1d80:	f0 e0       	ldi	r31, 0x00	; 0
    1d82:	80 81       	ld	r24, Z
    1d84:	88 2f       	mov	r24, r24
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	ef 81       	ldd	r30, Y+7	; 0x07
    1d8a:	f8 85       	ldd	r31, Y+8	; 0x08
    1d8c:	91 83       	std	Z+1, r25	; 0x01
    1d8e:	80 83       	st	Z, r24
    }
		return Local_u8ErrorState; 
    1d90:	89 81       	ldd	r24, Y+1	; 0x01
	  
}
    1d92:	28 96       	adiw	r28, 0x08	; 8
    1d94:	0f b6       	in	r0, 0x3f	; 63
    1d96:	f8 94       	cli
    1d98:	de bf       	out	0x3e, r29	; 62
    1d9a:	0f be       	out	0x3f, r0	; 63
    1d9c:	cd bf       	out	0x3d, r28	; 61
    1d9e:	cf 91       	pop	r28
    1da0:	df 91       	pop	r29
    1da2:	08 95       	ret

00001da4 <ADC_u8SartConversionAsynch>:

u8 ADC_u8SartConversionAsynch(u8 copy_u8Channel, u16 *copy_pu16Reading , void(*copy_pvNotficationFunc)(void))
{
    1da4:	df 93       	push	r29
    1da6:	cf 93       	push	r28
    1da8:	cd b7       	in	r28, 0x3d	; 61
    1daa:	de b7       	in	r29, 0x3e	; 62
    1dac:	27 97       	sbiw	r28, 0x07	; 7
    1dae:	0f b6       	in	r0, 0x3f	; 63
    1db0:	f8 94       	cli
    1db2:	de bf       	out	0x3e, r29	; 62
    1db4:	0f be       	out	0x3f, r0	; 63
    1db6:	cd bf       	out	0x3d, r28	; 61
    1db8:	8a 83       	std	Y+2, r24	; 0x02
    1dba:	7c 83       	std	Y+4, r23	; 0x04
    1dbc:	6b 83       	std	Y+3, r22	; 0x03
    1dbe:	5e 83       	std	Y+6, r21	; 0x06
    1dc0:	4d 83       	std	Y+5, r20	; 0x05
	u8 Local_u8ErrorState =0 ; 
    1dc2:	19 82       	std	Y+1, r1	; 0x01
	if ((Local_u8ErrorState == NULL) || (copy_pvNotficationFunc==NULL))
    1dc4:	89 81       	ldd	r24, Y+1	; 0x01
    1dc6:	88 23       	and	r24, r24
    1dc8:	21 f0       	breq	.+8      	; 0x1dd2 <ADC_u8SartConversionAsynch+0x2e>
    1dca:	8d 81       	ldd	r24, Y+5	; 0x05
    1dcc:	9e 81       	ldd	r25, Y+6	; 0x06
    1dce:	00 97       	sbiw	r24, 0x00	; 0
    1dd0:	29 f4       	brne	.+10     	; 0x1ddc <ADC_u8SartConversionAsynch+0x38>
	{
		return Local_u8ErrorState = NULL_POINTER ;
    1dd2:	82 e0       	ldi	r24, 0x02	; 2
    1dd4:	89 83       	std	Y+1, r24	; 0x01
    1dd6:	89 81       	ldd	r24, Y+1	; 0x01
    1dd8:	8f 83       	std	Y+7, r24	; 0x07
    1dda:	2b c0       	rjmp	.+86     	; 0x1e32 <ADC_u8SartConversionAsynch+0x8e>
	}
	else
	{
		/*Initiate the reading variable globally*/
		ADC_pu16Reading = copy_pu16Reading ; 
    1ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dde:	9c 81       	ldd	r25, Y+4	; 0x04
    1de0:	90 93 09 02 	sts	0x0209, r25
    1de4:	80 93 08 02 	sts	0x0208, r24
		/*Initiate the Callback notification function globally */
		ADC_pvCallBackNotficationFunc=copy_pvNotficationFunc; 
    1de8:	8d 81       	ldd	r24, Y+5	; 0x05
    1dea:	9e 81       	ldd	r25, Y+6	; 0x06
    1dec:	90 93 0b 02 	sts	0x020B, r25
    1df0:	80 93 0a 02 	sts	0x020A, r24
		/*Clear the MUX bits in ADMUX register*/
		ADMUX&=0b11100000;
    1df4:	a7 e2       	ldi	r26, 0x27	; 39
    1df6:	b0 e0       	ldi	r27, 0x00	; 0
    1df8:	e7 e2       	ldi	r30, 0x27	; 39
    1dfa:	f0 e0       	ldi	r31, 0x00	; 0
    1dfc:	80 81       	ld	r24, Z
    1dfe:	80 7e       	andi	r24, 0xE0	; 224
    1e00:	8c 93       	st	X, r24
		/*set the required channel at ADMUX */
		ADMUX|=copy_u8Channel;
    1e02:	a7 e2       	ldi	r26, 0x27	; 39
    1e04:	b0 e0       	ldi	r27, 0x00	; 0
    1e06:	e7 e2       	ldi	r30, 0x27	; 39
    1e08:	f0 e0       	ldi	r31, 0x00	; 0
    1e0a:	90 81       	ld	r25, Z
    1e0c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e0e:	89 2b       	or	r24, r25
    1e10:	8c 93       	st	X, r24
		/*start conversion*/
		SET_BIT(ADCSRA,ADCSRA_ADSC);
    1e12:	a6 e2       	ldi	r26, 0x26	; 38
    1e14:	b0 e0       	ldi	r27, 0x00	; 0
    1e16:	e6 e2       	ldi	r30, 0x26	; 38
    1e18:	f0 e0       	ldi	r31, 0x00	; 0
    1e1a:	80 81       	ld	r24, Z
    1e1c:	80 64       	ori	r24, 0x40	; 64
    1e1e:	8c 93       	st	X, r24
		/*ADC interrupt enable*/
		SET_BIT(ADCSRA,ADCSRA_ADIE);
    1e20:	a6 e2       	ldi	r26, 0x26	; 38
    1e22:	b0 e0       	ldi	r27, 0x00	; 0
    1e24:	e6 e2       	ldi	r30, 0x26	; 38
    1e26:	f0 e0       	ldi	r31, 0x00	; 0
    1e28:	80 81       	ld	r24, Z
    1e2a:	88 60       	ori	r24, 0x08	; 8
    1e2c:	8c 93       	st	X, r24
		
	}
	return Local_u8ErrorState ; 
    1e2e:	89 81       	ldd	r24, Y+1	; 0x01
    1e30:	8f 83       	std	Y+7, r24	; 0x07
    1e32:	8f 81       	ldd	r24, Y+7	; 0x07
	
}
    1e34:	27 96       	adiw	r28, 0x07	; 7
    1e36:	0f b6       	in	r0, 0x3f	; 63
    1e38:	f8 94       	cli
    1e3a:	de bf       	out	0x3e, r29	; 62
    1e3c:	0f be       	out	0x3f, r0	; 63
    1e3e:	cd bf       	out	0x3d, r28	; 61
    1e40:	cf 91       	pop	r28
    1e42:	df 91       	pop	r29
    1e44:	08 95       	ret

00001e46 <__vector_16>:
void __vector_16(void)__attribute__((signal));
void __vector_16(void)
{
    1e46:	1f 92       	push	r1
    1e48:	0f 92       	push	r0
    1e4a:	0f b6       	in	r0, 0x3f	; 63
    1e4c:	0f 92       	push	r0
    1e4e:	11 24       	eor	r1, r1
    1e50:	2f 93       	push	r18
    1e52:	3f 93       	push	r19
    1e54:	4f 93       	push	r20
    1e56:	5f 93       	push	r21
    1e58:	6f 93       	push	r22
    1e5a:	7f 93       	push	r23
    1e5c:	8f 93       	push	r24
    1e5e:	9f 93       	push	r25
    1e60:	af 93       	push	r26
    1e62:	bf 93       	push	r27
    1e64:	ef 93       	push	r30
    1e66:	ff 93       	push	r31
    1e68:	df 93       	push	r29
    1e6a:	cf 93       	push	r28
    1e6c:	cd b7       	in	r28, 0x3d	; 61
    1e6e:	de b7       	in	r29, 0x3e	; 62
	/*read ADC result*/
	*ADC_pu16Reading = ADCH; 
    1e70:	a0 91 08 02 	lds	r26, 0x0208
    1e74:	b0 91 09 02 	lds	r27, 0x0209
    1e78:	e5 e2       	ldi	r30, 0x25	; 37
    1e7a:	f0 e0       	ldi	r31, 0x00	; 0
    1e7c:	80 81       	ld	r24, Z
    1e7e:	88 2f       	mov	r24, r24
    1e80:	90 e0       	ldi	r25, 0x00	; 0
    1e82:	8d 93       	st	X+, r24
    1e84:	9c 93       	st	X, r25
	/*Invoke Call back notification*/
	ADC_pvCallBackNotficationFunc();
    1e86:	e0 91 0a 02 	lds	r30, 0x020A
    1e8a:	f0 91 0b 02 	lds	r31, 0x020B
    1e8e:	09 95       	icall
	/*disable ADC conversion complete interrupt*/
	CLR_BIT(ADCSRA,ADCSRA_ADIE);  
    1e90:	a6 e2       	ldi	r26, 0x26	; 38
    1e92:	b0 e0       	ldi	r27, 0x00	; 0
    1e94:	e6 e2       	ldi	r30, 0x26	; 38
    1e96:	f0 e0       	ldi	r31, 0x00	; 0
    1e98:	80 81       	ld	r24, Z
    1e9a:	87 7f       	andi	r24, 0xF7	; 247
    1e9c:	8c 93       	st	X, r24
    1e9e:	cf 91       	pop	r28
    1ea0:	df 91       	pop	r29
    1ea2:	ff 91       	pop	r31
    1ea4:	ef 91       	pop	r30
    1ea6:	bf 91       	pop	r27
    1ea8:	af 91       	pop	r26
    1eaa:	9f 91       	pop	r25
    1eac:	8f 91       	pop	r24
    1eae:	7f 91       	pop	r23
    1eb0:	6f 91       	pop	r22
    1eb2:	5f 91       	pop	r21
    1eb4:	4f 91       	pop	r20
    1eb6:	3f 91       	pop	r19
    1eb8:	2f 91       	pop	r18
    1eba:	0f 90       	pop	r0
    1ebc:	0f be       	out	0x3f, r0	; 63
    1ebe:	0f 90       	pop	r0
    1ec0:	1f 90       	pop	r1
    1ec2:	18 95       	reti

00001ec4 <LED_u8SetLedOn>:



/*function to set led pin high  turn led on */
u8 LED_u8SetLedOn(u8 copy_u8LedPort , u8 copy_u8LedPin)
{
    1ec4:	df 93       	push	r29
    1ec6:	cf 93       	push	r28
    1ec8:	00 d0       	rcall	.+0      	; 0x1eca <LED_u8SetLedOn+0x6>
    1eca:	0f 92       	push	r0
    1ecc:	cd b7       	in	r28, 0x3d	; 61
    1ece:	de b7       	in	r29, 0x3e	; 62
    1ed0:	8a 83       	std	Y+2, r24	; 0x02
    1ed2:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErroState = 0 ;
    1ed4:	19 82       	std	Y+1, r1	; 0x01
	if(copy_u8LedPin <= DIO_u8PIN7 && copy_u8LedPort <= DIO_u8PORTD)
    1ed6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ed8:	88 30       	cpi	r24, 0x08	; 8
    1eda:	48 f4       	brcc	.+18     	; 0x1eee <LED_u8SetLedOn+0x2a>
    1edc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ede:	84 30       	cpi	r24, 0x04	; 4
    1ee0:	30 f4       	brcc	.+12     	; 0x1eee <LED_u8SetLedOn+0x2a>
	{
		DIO_u8SetPinValue(copy_u8LedPort,copy_u8LedPin,LED_u8PIN_HIGH);
    1ee2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee4:	6b 81       	ldd	r22, Y+3	; 0x03
    1ee6:	41 e0       	ldi	r20, 0x01	; 1
    1ee8:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
    1eec:	02 c0       	rjmp	.+4      	; 0x1ef2 <LED_u8SetLedOn+0x2e>
	}// end of if
	else
	{
		Local_u8ErroState = 1 ;
    1eee:	81 e0       	ldi	r24, 0x01	; 1
    1ef0:	89 83       	std	Y+1, r24	; 0x01
	} // end of else
	
	return Local_u8ErroState ;
    1ef2:	89 81       	ldd	r24, Y+1	; 0x01
}// end of led set led on function
    1ef4:	0f 90       	pop	r0
    1ef6:	0f 90       	pop	r0
    1ef8:	0f 90       	pop	r0
    1efa:	cf 91       	pop	r28
    1efc:	df 91       	pop	r29
    1efe:	08 95       	ret

00001f00 <LED_u8SetLedOff>:


/*function to set led pin low turn led off */
u8 LED_u8SetLedOff(u8 copy_u8LedPort , u8 copy_u8LedPin)
{
    1f00:	df 93       	push	r29
    1f02:	cf 93       	push	r28
    1f04:	00 d0       	rcall	.+0      	; 0x1f06 <LED_u8SetLedOff+0x6>
    1f06:	0f 92       	push	r0
    1f08:	cd b7       	in	r28, 0x3d	; 61
    1f0a:	de b7       	in	r29, 0x3e	; 62
    1f0c:	8a 83       	std	Y+2, r24	; 0x02
    1f0e:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErroState = 0 ;
    1f10:	19 82       	std	Y+1, r1	; 0x01
	if(copy_u8LedPin <= DIO_u8PIN7 && copy_u8LedPort <= DIO_u8PORTD)
    1f12:	8b 81       	ldd	r24, Y+3	; 0x03
    1f14:	88 30       	cpi	r24, 0x08	; 8
    1f16:	48 f4       	brcc	.+18     	; 0x1f2a <LED_u8SetLedOff+0x2a>
    1f18:	8a 81       	ldd	r24, Y+2	; 0x02
    1f1a:	84 30       	cpi	r24, 0x04	; 4
    1f1c:	30 f4       	brcc	.+12     	; 0x1f2a <LED_u8SetLedOff+0x2a>
	{
		DIO_u8SetPinValue(copy_u8LedPort,copy_u8LedPin,DIO_u8PIN_LOW);
    1f1e:	8a 81       	ldd	r24, Y+2	; 0x02
    1f20:	6b 81       	ldd	r22, Y+3	; 0x03
    1f22:	40 e0       	ldi	r20, 0x00	; 0
    1f24:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
    1f28:	02 c0       	rjmp	.+4      	; 0x1f2e <LED_u8SetLedOff+0x2e>
	}// end of if
	else
	{
		Local_u8ErroState = 1 ;
    1f2a:	81 e0       	ldi	r24, 0x01	; 1
    1f2c:	89 83       	std	Y+1, r24	; 0x01
	} // end of else
	
	return Local_u8ErroState ;
    1f2e:	89 81       	ldd	r24, Y+1	; 0x01
}// end of set led of function 
    1f30:	0f 90       	pop	r0
    1f32:	0f 90       	pop	r0
    1f34:	0f 90       	pop	r0
    1f36:	cf 91       	pop	r28
    1f38:	df 91       	pop	r29
    1f3a:	08 95       	ret

00001f3c <LED_u8ToggleLed>:

/*function to toggle led pin */

u8 LED_u8ToggleLed(u8 copy_u8LedPort , u8 copy_u8LedPin)
{
    1f3c:	df 93       	push	r29
    1f3e:	cf 93       	push	r28
    1f40:	00 d0       	rcall	.+0      	; 0x1f42 <LED_u8ToggleLed+0x6>
    1f42:	0f 92       	push	r0
    1f44:	cd b7       	in	r28, 0x3d	; 61
    1f46:	de b7       	in	r29, 0x3e	; 62
    1f48:	8a 83       	std	Y+2, r24	; 0x02
    1f4a:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErroState = 0 ;
    1f4c:	19 82       	std	Y+1, r1	; 0x01
	if(copy_u8LedPin <= DIO_u8PIN7 && copy_u8LedPort <= DIO_u8PORTD)
    1f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f50:	88 30       	cpi	r24, 0x08	; 8
    1f52:	40 f4       	brcc	.+16     	; 0x1f64 <LED_u8ToggleLed+0x28>
    1f54:	8a 81       	ldd	r24, Y+2	; 0x02
    1f56:	84 30       	cpi	r24, 0x04	; 4
    1f58:	28 f4       	brcc	.+10     	; 0x1f64 <LED_u8ToggleLed+0x28>
	{
		DIO_u8TogglePinValue(copy_u8LedPort , copy_u8LedPin ); 
    1f5a:	8a 81       	ldd	r24, Y+2	; 0x02
    1f5c:	6b 81       	ldd	r22, Y+3	; 0x03
    1f5e:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <DIO_u8TogglePinValue>
    1f62:	02 c0       	rjmp	.+4      	; 0x1f68 <LED_u8ToggleLed+0x2c>
	}// end of if
	else
	{
		Local_u8ErroState = 1 ;
    1f64:	81 e0       	ldi	r24, 0x01	; 1
    1f66:	89 83       	std	Y+1, r24	; 0x01
	} // end of else
	
	return Local_u8ErroState ;
    1f68:	89 81       	ldd	r24, Y+1	; 0x01
}//end of led state toggle function 
    1f6a:	0f 90       	pop	r0
    1f6c:	0f 90       	pop	r0
    1f6e:	0f 90       	pop	r0
    1f70:	cf 91       	pop	r28
    1f72:	df 91       	pop	r29
    1f74:	08 95       	ret

00001f76 <KPD_u8GetPressedKey>:
#define F_CPU 8000000UL
#include "util/delay.h"

extern u8 GLOBAL_u8SELECTOR ; 
u8 KPD_u8GetPressedKey(void)
{
    1f76:	df 93       	push	r29
    1f78:	cf 93       	push	r28
    1f7a:	00 d0       	rcall	.+0      	; 0x1f7c <KPD_u8GetPressedKey+0x6>
    1f7c:	00 d0       	rcall	.+0      	; 0x1f7e <KPD_u8GetPressedKey+0x8>
    1f7e:	0f 92       	push	r0
    1f80:	cd b7       	in	r28, 0x3d	; 61
    1f82:	de b7       	in	r29, 0x3e	; 62
	/*variable to return the pressed key */
	u8 Local_u8PressedKey= KPD_NO_PRESSED_KEY; 
    1f84:	8f ef       	ldi	r24, 0xFF	; 255
    1f86:	8b 83       	std	Y+3, r24	; 0x03
		
	/*TWO nested for loops the outer for loop iterate on columns and set the current column by zero 
	  and second loop to iterate on the row and check which one value is zero 
	  to determine the pressed KEY  */
	
	for (Local_u8ColumnIndx=0 ; Local_u8ColumnIndx<COLUMN_NUM ; Local_u8ColumnIndx++)
    1f88:	1a 82       	std	Y+2, r1	; 0x02
    1f8a:	5e c0       	rjmp	.+188    	; 0x2048 <KPD_u8GetPressedKey+0xd2>
	{
		/*activate current column*/
		DIO_u8SetPinValue(KPD_COL_PORT,Local_u8KPDColumnArr[Local_u8ColumnIndx],DIO_u8PIN_LOW);
    1f8c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f8e:	88 2f       	mov	r24, r24
    1f90:	90 e0       	ldi	r25, 0x00	; 0
    1f92:	fc 01       	movw	r30, r24
    1f94:	e6 51       	subi	r30, 0x16	; 22
    1f96:	fe 4f       	sbci	r31, 0xFE	; 254
    1f98:	90 81       	ld	r25, Z
    1f9a:	82 e0       	ldi	r24, 0x02	; 2
    1f9c:	69 2f       	mov	r22, r25
    1f9e:	40 e0       	ldi	r20, 0x00	; 0
    1fa0:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
		/*go to check which row is equal to zero */
		for (Local_u8RowIndx=0 ; Local_u8RowIndx<ROW_NUM ; Local_u8RowIndx++)
    1fa4:	19 82       	std	Y+1, r1	; 0x01
    1fa6:	3d c0       	rjmp	.+122    	; 0x2022 <KPD_u8GetPressedKey+0xac>
		{
			/*read current Row*/
			DIO_u8GetPinValue(KPD_ROW_PORT,Local_u8KPDROWArr[Local_u8RowIndx],&Local_u8RowState);
    1fa8:	89 81       	ldd	r24, Y+1	; 0x01
    1faa:	88 2f       	mov	r24, r24
    1fac:	90 e0       	ldi	r25, 0x00	; 0
    1fae:	fc 01       	movw	r30, r24
    1fb0:	ea 51       	subi	r30, 0x1A	; 26
    1fb2:	fe 4f       	sbci	r31, 0xFE	; 254
    1fb4:	90 81       	ld	r25, Z
    1fb6:	9e 01       	movw	r18, r28
    1fb8:	2c 5f       	subi	r18, 0xFC	; 252
    1fba:	3f 4f       	sbci	r19, 0xFF	; 255
    1fbc:	83 e0       	ldi	r24, 0x03	; 3
    1fbe:	69 2f       	mov	r22, r25
    1fc0:	a9 01       	movw	r20, r18
    1fc2:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <DIO_u8GetPinValue>
		
			/*check switch is pressed or not */
			if (DIO_u8PIN_LOW==Local_u8RowState)
    1fc6:	8c 81       	ldd	r24, Y+4	; 0x04
    1fc8:	88 23       	and	r24, r24
    1fca:	41 f5       	brne	.+80     	; 0x201c <KPD_u8GetPressedKey+0xa6>
    1fcc:	0f c0       	rjmp	.+30     	; 0x1fec <KPD_u8GetPressedKey+0x76>
			{
				/*polling (busy waiting)until the pressed key is released */
				while(DIO_u8PIN_LOW==Local_u8RowState)
				{
					DIO_u8GetPinValue(KPD_ROW_PORT,Local_u8KPDROWArr[Local_u8RowIndx],&Local_u8RowState);
    1fce:	89 81       	ldd	r24, Y+1	; 0x01
    1fd0:	88 2f       	mov	r24, r24
    1fd2:	90 e0       	ldi	r25, 0x00	; 0
    1fd4:	fc 01       	movw	r30, r24
    1fd6:	ea 51       	subi	r30, 0x1A	; 26
    1fd8:	fe 4f       	sbci	r31, 0xFE	; 254
    1fda:	90 81       	ld	r25, Z
    1fdc:	9e 01       	movw	r18, r28
    1fde:	2c 5f       	subi	r18, 0xFC	; 252
    1fe0:	3f 4f       	sbci	r19, 0xFF	; 255
    1fe2:	83 e0       	ldi	r24, 0x03	; 3
    1fe4:	69 2f       	mov	r22, r25
    1fe6:	a9 01       	movw	r20, r18
    1fe8:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <DIO_u8GetPinValue>
		
			/*check switch is pressed or not */
			if (DIO_u8PIN_LOW==Local_u8RowState)
			{
				/*polling (busy waiting)until the pressed key is released */
				while(DIO_u8PIN_LOW==Local_u8RowState)
    1fec:	8c 81       	ldd	r24, Y+4	; 0x04
    1fee:	88 23       	and	r24, r24
    1ff0:	71 f3       	breq	.-36     	; 0x1fce <KPD_u8GetPressedKey+0x58>
				{
					DIO_u8GetPinValue(KPD_ROW_PORT,Local_u8KPDROWArr[Local_u8RowIndx],&Local_u8RowState);
				}
				Local_u8PressedKey=Local_u8KPDArr[Local_u8RowIndx][Local_u8ColumnIndx];
    1ff2:	89 81       	ldd	r24, Y+1	; 0x01
    1ff4:	48 2f       	mov	r20, r24
    1ff6:	50 e0       	ldi	r21, 0x00	; 0
    1ff8:	8a 81       	ldd	r24, Y+2	; 0x02
    1ffa:	28 2f       	mov	r18, r24
    1ffc:	30 e0       	ldi	r19, 0x00	; 0
    1ffe:	ca 01       	movw	r24, r20
    2000:	88 0f       	add	r24, r24
    2002:	99 1f       	adc	r25, r25
    2004:	88 0f       	add	r24, r24
    2006:	99 1f       	adc	r25, r25
    2008:	82 0f       	add	r24, r18
    200a:	93 1f       	adc	r25, r19
    200c:	fc 01       	movw	r30, r24
    200e:	e2 51       	subi	r30, 0x12	; 18
    2010:	fe 4f       	sbci	r31, 0xFE	; 254
    2012:	80 81       	ld	r24, Z
    2014:	8b 83       	std	Y+3, r24	; 0x03
				return Local_u8PressedKey ;
    2016:	8b 81       	ldd	r24, Y+3	; 0x03
    2018:	8d 83       	std	Y+5, r24	; 0x05
    201a:	1c c0       	rjmp	.+56     	; 0x2054 <KPD_u8GetPressedKey+0xde>
	for (Local_u8ColumnIndx=0 ; Local_u8ColumnIndx<COLUMN_NUM ; Local_u8ColumnIndx++)
	{
		/*activate current column*/
		DIO_u8SetPinValue(KPD_COL_PORT,Local_u8KPDColumnArr[Local_u8ColumnIndx],DIO_u8PIN_LOW);
		/*go to check which row is equal to zero */
		for (Local_u8RowIndx=0 ; Local_u8RowIndx<ROW_NUM ; Local_u8RowIndx++)
    201c:	89 81       	ldd	r24, Y+1	; 0x01
    201e:	8f 5f       	subi	r24, 0xFF	; 255
    2020:	89 83       	std	Y+1, r24	; 0x01
    2022:	89 81       	ldd	r24, Y+1	; 0x01
    2024:	84 30       	cpi	r24, 0x04	; 4
    2026:	08 f4       	brcc	.+2      	; 0x202a <KPD_u8GetPressedKey+0xb4>
    2028:	bf cf       	rjmp	.-130    	; 0x1fa8 <KPD_u8GetPressedKey+0x32>
				return Local_u8PressedKey ;
			}
		}
		
		/*deactivate the current columns*/
		DIO_u8SetPinValue(KPD_COL_PORT,Local_u8KPDColumnArr[Local_u8ColumnIndx],DIO_u8PIN_HIGH);
    202a:	8a 81       	ldd	r24, Y+2	; 0x02
    202c:	88 2f       	mov	r24, r24
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	fc 01       	movw	r30, r24
    2032:	e6 51       	subi	r30, 0x16	; 22
    2034:	fe 4f       	sbci	r31, 0xFE	; 254
    2036:	90 81       	ld	r25, Z
    2038:	82 e0       	ldi	r24, 0x02	; 2
    203a:	69 2f       	mov	r22, r25
    203c:	41 e0       	ldi	r20, 0x01	; 1
    203e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
		
	/*TWO nested for loops the outer for loop iterate on columns and set the current column by zero 
	  and second loop to iterate on the row and check which one value is zero 
	  to determine the pressed KEY  */
	
	for (Local_u8ColumnIndx=0 ; Local_u8ColumnIndx<COLUMN_NUM ; Local_u8ColumnIndx++)
    2042:	8a 81       	ldd	r24, Y+2	; 0x02
    2044:	8f 5f       	subi	r24, 0xFF	; 255
    2046:	8a 83       	std	Y+2, r24	; 0x02
    2048:	8a 81       	ldd	r24, Y+2	; 0x02
    204a:	84 30       	cpi	r24, 0x04	; 4
    204c:	08 f4       	brcc	.+2      	; 0x2050 <KPD_u8GetPressedKey+0xda>
    204e:	9e cf       	rjmp	.-196    	; 0x1f8c <KPD_u8GetPressedKey+0x16>
		/*deactivate the current columns*/
		DIO_u8SetPinValue(KPD_COL_PORT,Local_u8KPDColumnArr[Local_u8ColumnIndx],DIO_u8PIN_HIGH);
	}
	
	
	return Local_u8PressedKey ;
    2050:	8b 81       	ldd	r24, Y+3	; 0x03
    2052:	8d 83       	std	Y+5, r24	; 0x05
    2054:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2056:	0f 90       	pop	r0
    2058:	0f 90       	pop	r0
    205a:	0f 90       	pop	r0
    205c:	0f 90       	pop	r0
    205e:	0f 90       	pop	r0
    2060:	cf 91       	pop	r28
    2062:	df 91       	pop	r29
    2064:	08 95       	ret

00002066 <KEYPAD_u8GetValue>:

u8 KEYPAD_u8GetValue(void)
{
    2066:	df 93       	push	r29
    2068:	cf 93       	push	r28
    206a:	00 d0       	rcall	.+0      	; 0x206c <KEYPAD_u8GetValue+0x6>
    206c:	00 d0       	rcall	.+0      	; 0x206e <KEYPAD_u8GetValue+0x8>
    206e:	cd b7       	in	r28, 0x3d	; 61
    2070:	de b7       	in	r29, 0x3e	; 62
	u8 Local_u8Var=0,Sum=0;
    2072:	1a 82       	std	Y+2, r1	; 0x02
    2074:	19 82       	std	Y+1, r1	; 0x01
	
	do
	{
		
		CLCD_vidSendLargeNmber(Sum);
    2076:	89 81       	ldd	r24, Y+1	; 0x01
    2078:	88 2f       	mov	r24, r24
    207a:	90 e0       	ldi	r25, 0x00	; 0
    207c:	a0 e0       	ldi	r26, 0x00	; 0
    207e:	b0 e0       	ldi	r27, 0x00	; 0
    2080:	bc 01       	movw	r22, r24
    2082:	cd 01       	movw	r24, r26
    2084:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <CLCD_vidSendLargeNmber>
		do
		{
			if (GLOBAL_u8SELECTOR=='0')
    2088:	80 91 fe 01 	lds	r24, 0x01FE
    208c:	80 33       	cpi	r24, 0x30	; 48
    208e:	11 f4       	brne	.+4      	; 0x2094 <KEYPAD_u8GetValue+0x2e>
			{
				return 0; 
    2090:	1b 82       	std	Y+3, r1	; 0x03
    2092:	24 c0       	rjmp	.+72     	; 0x20dc <KEYPAD_u8GetValue+0x76>
			}
			Local_u8Var = KPD_u8GetPressedKey();
    2094:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <KPD_u8GetPressedKey>
    2098:	8a 83       	std	Y+2, r24	; 0x02
		} while (Local_u8Var==0xff);
    209a:	8a 81       	ldd	r24, Y+2	; 0x02
    209c:	8f 3f       	cpi	r24, 0xFF	; 255
    209e:	a1 f3       	breq	.-24     	; 0x2088 <KEYPAD_u8GetValue+0x22>
		if (Local_u8Var =='=')
    20a0:	8a 81       	ldd	r24, Y+2	; 0x02
    20a2:	8d 33       	cpi	r24, 0x3D	; 61
    20a4:	19 f4       	brne	.+6      	; 0x20ac <KEYPAD_u8GetValue+0x46>
		{
			return Sum;
    20a6:	89 81       	ldd	r24, Y+1	; 0x01
    20a8:	8b 83       	std	Y+3, r24	; 0x03
    20aa:	18 c0       	rjmp	.+48     	; 0x20dc <KEYPAD_u8GetValue+0x76>
		}
		else
		{
			Sum=(Sum*10+(Local_u8Var-'0'));
    20ac:	89 81       	ldd	r24, Y+1	; 0x01
    20ae:	88 2f       	mov	r24, r24
    20b0:	90 e0       	ldi	r25, 0x00	; 0
    20b2:	9c 01       	movw	r18, r24
    20b4:	22 0f       	add	r18, r18
    20b6:	33 1f       	adc	r19, r19
    20b8:	c9 01       	movw	r24, r18
    20ba:	88 0f       	add	r24, r24
    20bc:	99 1f       	adc	r25, r25
    20be:	88 0f       	add	r24, r24
    20c0:	99 1f       	adc	r25, r25
    20c2:	82 0f       	add	r24, r18
    20c4:	93 1f       	adc	r25, r19
    20c6:	98 2f       	mov	r25, r24
    20c8:	8a 81       	ldd	r24, Y+2	; 0x02
    20ca:	89 0f       	add	r24, r25
    20cc:	80 53       	subi	r24, 0x30	; 48
    20ce:	89 83       	std	Y+1, r24	; 0x01
	
			CLCD_vidClearLcd();
    20d0:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
		}
		
	}while(Local_u8Var!= '=');
    20d4:	8a 81       	ldd	r24, Y+2	; 0x02
    20d6:	8d 33       	cpi	r24, 0x3D	; 61
    20d8:	71 f6       	brne	.-100    	; 0x2076 <KEYPAD_u8GetValue+0x10>
    20da:	02 c0       	rjmp	.+4      	; 0x20e0 <KEYPAD_u8GetValue+0x7a>
	/*return Sum;*/
    20dc:	8b 81       	ldd	r24, Y+3	; 0x03
    20de:	8c 83       	std	Y+4, r24	; 0x04
    20e0:	8c 81       	ldd	r24, Y+4	; 0x04
    20e2:	0f 90       	pop	r0
    20e4:	0f 90       	pop	r0
    20e6:	0f 90       	pop	r0
    20e8:	0f 90       	pop	r0
    20ea:	cf 91       	pop	r28
    20ec:	df 91       	pop	r29
    20ee:	08 95       	ret

000020f0 <EEPROM_INIT>:

#include "EEPROM_MT.h"


void EEPROM_INIT(void)
{
    20f0:	df 93       	push	r29
    20f2:	cf 93       	push	r28
    20f4:	cd b7       	in	r28, 0x3d	; 61
    20f6:	de b7       	in	r29, 0x3e	; 62
	i2c_init();
    20f8:	0e 94 20 08 	call	0x1040	; 0x1040 <i2c_init>
}
    20fc:	cf 91       	pop	r28
    20fe:	df 91       	pop	r29
    2100:	08 95       	ret

00002102 <EEPROM_write>:

void EEPROM_write (uint8_t memory_location, uint8_t slave_address , uint8_t data)
{
    2102:	df 93       	push	r29
    2104:	cf 93       	push	r28
    2106:	cd b7       	in	r28, 0x3d	; 61
    2108:	de b7       	in	r29, 0x3e	; 62
    210a:	61 97       	sbiw	r28, 0x11	; 17
    210c:	0f b6       	in	r0, 0x3f	; 63
    210e:	f8 94       	cli
    2110:	de bf       	out	0x3e, r29	; 62
    2112:	0f be       	out	0x3f, r0	; 63
    2114:	cd bf       	out	0x3d, r28	; 61
    2116:	8f 87       	std	Y+15, r24	; 0x0f
    2118:	68 8b       	std	Y+16, r22	; 0x10
    211a:	49 8b       	std	Y+17, r20	; 0x11
	i2c_init();
    211c:	0e 94 20 08 	call	0x1040	; 0x1040 <i2c_init>
	i2c_start();
    2120:	0e 94 32 08 	call	0x1064	; 0x1064 <i2c_start>
	i2c_write(slave_address); //slave address 0xa0
    2124:	88 89       	ldd	r24, Y+16	; 0x10
    2126:	0e 94 4d 08 	call	0x109a	; 0x109a <i2c_write>
	i2c_write(memory_location); //memory location
    212a:	8f 85       	ldd	r24, Y+15	; 0x0f
    212c:	0e 94 4d 08 	call	0x109a	; 0x109a <i2c_write>
	i2c_write(data);   //data
    2130:	89 89       	ldd	r24, Y+17	; 0x11
    2132:	0e 94 4d 08 	call	0x109a	; 0x109a <i2c_write>
	i2c_stop();
    2136:	0e 94 42 08 	call	0x1084	; 0x1084 <i2c_stop>
    213a:	80 e0       	ldi	r24, 0x00	; 0
    213c:	90 e0       	ldi	r25, 0x00	; 0
    213e:	a0 e7       	ldi	r26, 0x70	; 112
    2140:	b1 e4       	ldi	r27, 0x41	; 65
    2142:	8b 87       	std	Y+11, r24	; 0x0b
    2144:	9c 87       	std	Y+12, r25	; 0x0c
    2146:	ad 87       	std	Y+13, r26	; 0x0d
    2148:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    214a:	6b 85       	ldd	r22, Y+11	; 0x0b
    214c:	7c 85       	ldd	r23, Y+12	; 0x0c
    214e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2150:	9e 85       	ldd	r25, Y+14	; 0x0e
    2152:	20 e0       	ldi	r18, 0x00	; 0
    2154:	30 e0       	ldi	r19, 0x00	; 0
    2156:	4a ef       	ldi	r20, 0xFA	; 250
    2158:	54 e4       	ldi	r21, 0x44	; 68
    215a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    215e:	dc 01       	movw	r26, r24
    2160:	cb 01       	movw	r24, r22
    2162:	8f 83       	std	Y+7, r24	; 0x07
    2164:	98 87       	std	Y+8, r25	; 0x08
    2166:	a9 87       	std	Y+9, r26	; 0x09
    2168:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    216a:	6f 81       	ldd	r22, Y+7	; 0x07
    216c:	78 85       	ldd	r23, Y+8	; 0x08
    216e:	89 85       	ldd	r24, Y+9	; 0x09
    2170:	9a 85       	ldd	r25, Y+10	; 0x0a
    2172:	20 e0       	ldi	r18, 0x00	; 0
    2174:	30 e0       	ldi	r19, 0x00	; 0
    2176:	40 e8       	ldi	r20, 0x80	; 128
    2178:	5f e3       	ldi	r21, 0x3F	; 63
    217a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    217e:	88 23       	and	r24, r24
    2180:	2c f4       	brge	.+10     	; 0x218c <EEPROM_write+0x8a>
		__ticks = 1;
    2182:	81 e0       	ldi	r24, 0x01	; 1
    2184:	90 e0       	ldi	r25, 0x00	; 0
    2186:	9e 83       	std	Y+6, r25	; 0x06
    2188:	8d 83       	std	Y+5, r24	; 0x05
    218a:	3f c0       	rjmp	.+126    	; 0x220a <EEPROM_write+0x108>
	else if (__tmp > 65535)
    218c:	6f 81       	ldd	r22, Y+7	; 0x07
    218e:	78 85       	ldd	r23, Y+8	; 0x08
    2190:	89 85       	ldd	r24, Y+9	; 0x09
    2192:	9a 85       	ldd	r25, Y+10	; 0x0a
    2194:	20 e0       	ldi	r18, 0x00	; 0
    2196:	3f ef       	ldi	r19, 0xFF	; 255
    2198:	4f e7       	ldi	r20, 0x7F	; 127
    219a:	57 e4       	ldi	r21, 0x47	; 71
    219c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    21a0:	18 16       	cp	r1, r24
    21a2:	4c f5       	brge	.+82     	; 0x21f6 <EEPROM_write+0xf4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    21a4:	6b 85       	ldd	r22, Y+11	; 0x0b
    21a6:	7c 85       	ldd	r23, Y+12	; 0x0c
    21a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    21aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    21ac:	20 e0       	ldi	r18, 0x00	; 0
    21ae:	30 e0       	ldi	r19, 0x00	; 0
    21b0:	40 e2       	ldi	r20, 0x20	; 32
    21b2:	51 e4       	ldi	r21, 0x41	; 65
    21b4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21b8:	dc 01       	movw	r26, r24
    21ba:	cb 01       	movw	r24, r22
    21bc:	bc 01       	movw	r22, r24
    21be:	cd 01       	movw	r24, r26
    21c0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21c4:	dc 01       	movw	r26, r24
    21c6:	cb 01       	movw	r24, r22
    21c8:	9e 83       	std	Y+6, r25	; 0x06
    21ca:	8d 83       	std	Y+5, r24	; 0x05
    21cc:	0f c0       	rjmp	.+30     	; 0x21ec <EEPROM_write+0xea>
    21ce:	88 ec       	ldi	r24, 0xC8	; 200
    21d0:	90 e0       	ldi	r25, 0x00	; 0
    21d2:	9c 83       	std	Y+4, r25	; 0x04
    21d4:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    21d6:	8b 81       	ldd	r24, Y+3	; 0x03
    21d8:	9c 81       	ldd	r25, Y+4	; 0x04
    21da:	01 97       	sbiw	r24, 0x01	; 1
    21dc:	f1 f7       	brne	.-4      	; 0x21da <EEPROM_write+0xd8>
    21de:	9c 83       	std	Y+4, r25	; 0x04
    21e0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    21e2:	8d 81       	ldd	r24, Y+5	; 0x05
    21e4:	9e 81       	ldd	r25, Y+6	; 0x06
    21e6:	01 97       	sbiw	r24, 0x01	; 1
    21e8:	9e 83       	std	Y+6, r25	; 0x06
    21ea:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    21ec:	8d 81       	ldd	r24, Y+5	; 0x05
    21ee:	9e 81       	ldd	r25, Y+6	; 0x06
    21f0:	00 97       	sbiw	r24, 0x00	; 0
    21f2:	69 f7       	brne	.-38     	; 0x21ce <EEPROM_write+0xcc>
    21f4:	14 c0       	rjmp	.+40     	; 0x221e <EEPROM_write+0x11c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    21f6:	6f 81       	ldd	r22, Y+7	; 0x07
    21f8:	78 85       	ldd	r23, Y+8	; 0x08
    21fa:	89 85       	ldd	r24, Y+9	; 0x09
    21fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    21fe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2202:	dc 01       	movw	r26, r24
    2204:	cb 01       	movw	r24, r22
    2206:	9e 83       	std	Y+6, r25	; 0x06
    2208:	8d 83       	std	Y+5, r24	; 0x05
    220a:	8d 81       	ldd	r24, Y+5	; 0x05
    220c:	9e 81       	ldd	r25, Y+6	; 0x06
    220e:	9a 83       	std	Y+2, r25	; 0x02
    2210:	89 83       	std	Y+1, r24	; 0x01
    2212:	89 81       	ldd	r24, Y+1	; 0x01
    2214:	9a 81       	ldd	r25, Y+2	; 0x02
    2216:	01 97       	sbiw	r24, 0x01	; 1
    2218:	f1 f7       	brne	.-4      	; 0x2216 <EEPROM_write+0x114>
    221a:	9a 83       	std	Y+2, r25	; 0x02
    221c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(15);
}
    221e:	61 96       	adiw	r28, 0x11	; 17
    2220:	0f b6       	in	r0, 0x3f	; 63
    2222:	f8 94       	cli
    2224:	de bf       	out	0x3e, r29	; 62
    2226:	0f be       	out	0x3f, r0	; 63
    2228:	cd bf       	out	0x3d, r28	; 61
    222a:	cf 91       	pop	r28
    222c:	df 91       	pop	r29
    222e:	08 95       	ret

00002230 <EEPROM_READ>:



uint8_t EEPROM_READ(uint8_t memory_location, uint8_t slave_address)
{
    2230:	df 93       	push	r29
    2232:	cf 93       	push	r28
    2234:	00 d0       	rcall	.+0      	; 0x2236 <EEPROM_READ+0x6>
    2236:	0f 92       	push	r0
    2238:	cd b7       	in	r28, 0x3d	; 61
    223a:	de b7       	in	r29, 0x3e	; 62
    223c:	8a 83       	std	Y+2, r24	; 0x02
    223e:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t data=0;
    2240:	19 82       	std	Y+1, r1	; 0x01


	i2c_start();                      /* Send Start Bit 						 */
    2242:	0e 94 32 08 	call	0x1064	; 0x1064 <i2c_start>
	i2c_write(slave_address);         /* Send Slave address with Operation Write */
    2246:	8b 81       	ldd	r24, Y+3	; 0x03
    2248:	0e 94 4d 08 	call	0x109a	; 0x109a <i2c_write>
	i2c_write(memory_location);       /* Send Memory Location Address 			 */
    224c:	8a 81       	ldd	r24, Y+2	; 0x02
    224e:	0e 94 4d 08 	call	0x109a	; 0x109a <i2c_write>

	i2c_start();                      /* Send Restart Bit 						 */
    2252:	0e 94 32 08 	call	0x1064	; 0x1064 <i2c_start>
	i2c_write(slave_address | 1);     /* Send Slave address with Operation read  */
    2256:	8b 81       	ldd	r24, Y+3	; 0x03
    2258:	81 60       	ori	r24, 0x01	; 1
    225a:	0e 94 4d 08 	call	0x109a	; 0x109a <i2c_write>
	data = i2c_read(0);
    225e:	80 e0       	ldi	r24, 0x00	; 0
    2260:	0e 94 64 08 	call	0x10c8	; 0x10c8 <i2c_read>
    2264:	89 83       	std	Y+1, r24	; 0x01
	i2c_stop();
    2266:	0e 94 42 08 	call	0x1084	; 0x1084 <i2c_stop>

	return data;
    226a:	89 81       	ldd	r24, Y+1	; 0x01
}
    226c:	0f 90       	pop	r0
    226e:	0f 90       	pop	r0
    2270:	0f 90       	pop	r0
    2272:	cf 91       	pop	r28
    2274:	df 91       	pop	r29
    2276:	08 95       	ret

00002278 <CLCD_vidSendCommand>:
#define F_CPU 8000000UL
#include "util/delay.h"

/*function that send command to LCD */
void CLCD_vidSendCommand(u8 copy_u8Command)
{
    2278:	df 93       	push	r29
    227a:	cf 93       	push	r28
    227c:	cd b7       	in	r28, 0x3d	; 61
    227e:	de b7       	in	r29, 0x3e	; 62
    2280:	e9 97       	sbiw	r28, 0x39	; 57
    2282:	0f b6       	in	r0, 0x3f	; 63
    2284:	f8 94       	cli
    2286:	de bf       	out	0x3e, r29	; 62
    2288:	0f be       	out	0x3f, r0	; 63
    228a:	cd bf       	out	0x3d, r28	; 61
    228c:	89 af       	std	Y+57, r24	; 0x39
	/*set rs pin to low for command */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_RS_PIN,DIO_u8PIN_LOW);
    228e:	81 e0       	ldi	r24, 0x01	; 1
    2290:	61 e0       	ldi	r22, 0x01	; 1
    2292:	40 e0       	ldi	r20, 0x00	; 0
    2294:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
	/*set R/W pin to 0 to active write */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_RW_PIN,DIO_u8PIN_LOW);
    2298:	81 e0       	ldi	r24, 0x01	; 1
    229a:	62 e0       	ldi	r22, 0x02	; 2
    229c:	40 e0       	ldi	r20, 0x00	; 0
    229e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
	
	/*send upper half of command*/
	/*set command to data pins  */
	DIO_u8SetPortValue(CLCD_DATA_PORT,(copy_u8Command & 0xf0));//& 0xf0)
    22a2:	89 ad       	ldd	r24, Y+57	; 0x39
    22a4:	98 2f       	mov	r25, r24
    22a6:	90 7f       	andi	r25, 0xF0	; 240
    22a8:	80 e0       	ldi	r24, 0x00	; 0
    22aa:	69 2f       	mov	r22, r25
    22ac:	0e 94 be 0c 	call	0x197c	; 0x197c <DIO_u8SetPortValue>
	/*send enable pulse */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_HIGH);
    22b0:	81 e0       	ldi	r24, 0x01	; 1
    22b2:	60 e0       	ldi	r22, 0x00	; 0
    22b4:	41 e0       	ldi	r20, 0x01	; 1
    22b6:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
    22ba:	80 e0       	ldi	r24, 0x00	; 0
    22bc:	90 e0       	ldi	r25, 0x00	; 0
    22be:	a0 e8       	ldi	r26, 0x80	; 128
    22c0:	bf e3       	ldi	r27, 0x3F	; 63
    22c2:	8d ab       	std	Y+53, r24	; 0x35
    22c4:	9e ab       	std	Y+54, r25	; 0x36
    22c6:	af ab       	std	Y+55, r26	; 0x37
    22c8:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    22ca:	6d a9       	ldd	r22, Y+53	; 0x35
    22cc:	7e a9       	ldd	r23, Y+54	; 0x36
    22ce:	8f a9       	ldd	r24, Y+55	; 0x37
    22d0:	98 ad       	ldd	r25, Y+56	; 0x38
    22d2:	20 e0       	ldi	r18, 0x00	; 0
    22d4:	30 e0       	ldi	r19, 0x00	; 0
    22d6:	4a ef       	ldi	r20, 0xFA	; 250
    22d8:	54 e4       	ldi	r21, 0x44	; 68
    22da:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22de:	dc 01       	movw	r26, r24
    22e0:	cb 01       	movw	r24, r22
    22e2:	89 ab       	std	Y+49, r24	; 0x31
    22e4:	9a ab       	std	Y+50, r25	; 0x32
    22e6:	ab ab       	std	Y+51, r26	; 0x33
    22e8:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    22ea:	69 a9       	ldd	r22, Y+49	; 0x31
    22ec:	7a a9       	ldd	r23, Y+50	; 0x32
    22ee:	8b a9       	ldd	r24, Y+51	; 0x33
    22f0:	9c a9       	ldd	r25, Y+52	; 0x34
    22f2:	20 e0       	ldi	r18, 0x00	; 0
    22f4:	30 e0       	ldi	r19, 0x00	; 0
    22f6:	40 e8       	ldi	r20, 0x80	; 128
    22f8:	5f e3       	ldi	r21, 0x3F	; 63
    22fa:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    22fe:	88 23       	and	r24, r24
    2300:	2c f4       	brge	.+10     	; 0x230c <CLCD_vidSendCommand+0x94>
		__ticks = 1;
    2302:	81 e0       	ldi	r24, 0x01	; 1
    2304:	90 e0       	ldi	r25, 0x00	; 0
    2306:	98 ab       	std	Y+48, r25	; 0x30
    2308:	8f a7       	std	Y+47, r24	; 0x2f
    230a:	3f c0       	rjmp	.+126    	; 0x238a <CLCD_vidSendCommand+0x112>
	else if (__tmp > 65535)
    230c:	69 a9       	ldd	r22, Y+49	; 0x31
    230e:	7a a9       	ldd	r23, Y+50	; 0x32
    2310:	8b a9       	ldd	r24, Y+51	; 0x33
    2312:	9c a9       	ldd	r25, Y+52	; 0x34
    2314:	20 e0       	ldi	r18, 0x00	; 0
    2316:	3f ef       	ldi	r19, 0xFF	; 255
    2318:	4f e7       	ldi	r20, 0x7F	; 127
    231a:	57 e4       	ldi	r21, 0x47	; 71
    231c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2320:	18 16       	cp	r1, r24
    2322:	4c f5       	brge	.+82     	; 0x2376 <CLCD_vidSendCommand+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2324:	6d a9       	ldd	r22, Y+53	; 0x35
    2326:	7e a9       	ldd	r23, Y+54	; 0x36
    2328:	8f a9       	ldd	r24, Y+55	; 0x37
    232a:	98 ad       	ldd	r25, Y+56	; 0x38
    232c:	20 e0       	ldi	r18, 0x00	; 0
    232e:	30 e0       	ldi	r19, 0x00	; 0
    2330:	40 e2       	ldi	r20, 0x20	; 32
    2332:	51 e4       	ldi	r21, 0x41	; 65
    2334:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2338:	dc 01       	movw	r26, r24
    233a:	cb 01       	movw	r24, r22
    233c:	bc 01       	movw	r22, r24
    233e:	cd 01       	movw	r24, r26
    2340:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2344:	dc 01       	movw	r26, r24
    2346:	cb 01       	movw	r24, r22
    2348:	98 ab       	std	Y+48, r25	; 0x30
    234a:	8f a7       	std	Y+47, r24	; 0x2f
    234c:	0f c0       	rjmp	.+30     	; 0x236c <CLCD_vidSendCommand+0xf4>
    234e:	88 ec       	ldi	r24, 0xC8	; 200
    2350:	90 e0       	ldi	r25, 0x00	; 0
    2352:	9e a7       	std	Y+46, r25	; 0x2e
    2354:	8d a7       	std	Y+45, r24	; 0x2d
    2356:	8d a5       	ldd	r24, Y+45	; 0x2d
    2358:	9e a5       	ldd	r25, Y+46	; 0x2e
    235a:	01 97       	sbiw	r24, 0x01	; 1
    235c:	f1 f7       	brne	.-4      	; 0x235a <CLCD_vidSendCommand+0xe2>
    235e:	9e a7       	std	Y+46, r25	; 0x2e
    2360:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2362:	8f a5       	ldd	r24, Y+47	; 0x2f
    2364:	98 a9       	ldd	r25, Y+48	; 0x30
    2366:	01 97       	sbiw	r24, 0x01	; 1
    2368:	98 ab       	std	Y+48, r25	; 0x30
    236a:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    236c:	8f a5       	ldd	r24, Y+47	; 0x2f
    236e:	98 a9       	ldd	r25, Y+48	; 0x30
    2370:	00 97       	sbiw	r24, 0x00	; 0
    2372:	69 f7       	brne	.-38     	; 0x234e <CLCD_vidSendCommand+0xd6>
    2374:	14 c0       	rjmp	.+40     	; 0x239e <CLCD_vidSendCommand+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2376:	69 a9       	ldd	r22, Y+49	; 0x31
    2378:	7a a9       	ldd	r23, Y+50	; 0x32
    237a:	8b a9       	ldd	r24, Y+51	; 0x33
    237c:	9c a9       	ldd	r25, Y+52	; 0x34
    237e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2382:	dc 01       	movw	r26, r24
    2384:	cb 01       	movw	r24, r22
    2386:	98 ab       	std	Y+48, r25	; 0x30
    2388:	8f a7       	std	Y+47, r24	; 0x2f
    238a:	8f a5       	ldd	r24, Y+47	; 0x2f
    238c:	98 a9       	ldd	r25, Y+48	; 0x30
    238e:	9c a7       	std	Y+44, r25	; 0x2c
    2390:	8b a7       	std	Y+43, r24	; 0x2b
    2392:	8b a5       	ldd	r24, Y+43	; 0x2b
    2394:	9c a5       	ldd	r25, Y+44	; 0x2c
    2396:	01 97       	sbiw	r24, 0x01	; 1
    2398:	f1 f7       	brne	.-4      	; 0x2396 <CLCD_vidSendCommand+0x11e>
    239a:	9c a7       	std	Y+44, r25	; 0x2c
    239c:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1);
	/*set enable again to zero*/
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_LOW);
    239e:	81 e0       	ldi	r24, 0x01	; 1
    23a0:	60 e0       	ldi	r22, 0x00	; 0
    23a2:	40 e0       	ldi	r20, 0x00	; 0
    23a4:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
    23a8:	80 e0       	ldi	r24, 0x00	; 0
    23aa:	90 e0       	ldi	r25, 0x00	; 0
    23ac:	a0 e8       	ldi	r26, 0x80	; 128
    23ae:	bf e3       	ldi	r27, 0x3F	; 63
    23b0:	8f a3       	std	Y+39, r24	; 0x27
    23b2:	98 a7       	std	Y+40, r25	; 0x28
    23b4:	a9 a7       	std	Y+41, r26	; 0x29
    23b6:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    23b8:	6f a1       	ldd	r22, Y+39	; 0x27
    23ba:	78 a5       	ldd	r23, Y+40	; 0x28
    23bc:	89 a5       	ldd	r24, Y+41	; 0x29
    23be:	9a a5       	ldd	r25, Y+42	; 0x2a
    23c0:	20 e0       	ldi	r18, 0x00	; 0
    23c2:	30 e0       	ldi	r19, 0x00	; 0
    23c4:	4a ef       	ldi	r20, 0xFA	; 250
    23c6:	54 e4       	ldi	r21, 0x44	; 68
    23c8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23cc:	dc 01       	movw	r26, r24
    23ce:	cb 01       	movw	r24, r22
    23d0:	8b a3       	std	Y+35, r24	; 0x23
    23d2:	9c a3       	std	Y+36, r25	; 0x24
    23d4:	ad a3       	std	Y+37, r26	; 0x25
    23d6:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    23d8:	6b a1       	ldd	r22, Y+35	; 0x23
    23da:	7c a1       	ldd	r23, Y+36	; 0x24
    23dc:	8d a1       	ldd	r24, Y+37	; 0x25
    23de:	9e a1       	ldd	r25, Y+38	; 0x26
    23e0:	20 e0       	ldi	r18, 0x00	; 0
    23e2:	30 e0       	ldi	r19, 0x00	; 0
    23e4:	40 e8       	ldi	r20, 0x80	; 128
    23e6:	5f e3       	ldi	r21, 0x3F	; 63
    23e8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    23ec:	88 23       	and	r24, r24
    23ee:	2c f4       	brge	.+10     	; 0x23fa <CLCD_vidSendCommand+0x182>
		__ticks = 1;
    23f0:	81 e0       	ldi	r24, 0x01	; 1
    23f2:	90 e0       	ldi	r25, 0x00	; 0
    23f4:	9a a3       	std	Y+34, r25	; 0x22
    23f6:	89 a3       	std	Y+33, r24	; 0x21
    23f8:	3f c0       	rjmp	.+126    	; 0x2478 <CLCD_vidSendCommand+0x200>
	else if (__tmp > 65535)
    23fa:	6b a1       	ldd	r22, Y+35	; 0x23
    23fc:	7c a1       	ldd	r23, Y+36	; 0x24
    23fe:	8d a1       	ldd	r24, Y+37	; 0x25
    2400:	9e a1       	ldd	r25, Y+38	; 0x26
    2402:	20 e0       	ldi	r18, 0x00	; 0
    2404:	3f ef       	ldi	r19, 0xFF	; 255
    2406:	4f e7       	ldi	r20, 0x7F	; 127
    2408:	57 e4       	ldi	r21, 0x47	; 71
    240a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    240e:	18 16       	cp	r1, r24
    2410:	4c f5       	brge	.+82     	; 0x2464 <CLCD_vidSendCommand+0x1ec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2412:	6f a1       	ldd	r22, Y+39	; 0x27
    2414:	78 a5       	ldd	r23, Y+40	; 0x28
    2416:	89 a5       	ldd	r24, Y+41	; 0x29
    2418:	9a a5       	ldd	r25, Y+42	; 0x2a
    241a:	20 e0       	ldi	r18, 0x00	; 0
    241c:	30 e0       	ldi	r19, 0x00	; 0
    241e:	40 e2       	ldi	r20, 0x20	; 32
    2420:	51 e4       	ldi	r21, 0x41	; 65
    2422:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2426:	dc 01       	movw	r26, r24
    2428:	cb 01       	movw	r24, r22
    242a:	bc 01       	movw	r22, r24
    242c:	cd 01       	movw	r24, r26
    242e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2432:	dc 01       	movw	r26, r24
    2434:	cb 01       	movw	r24, r22
    2436:	9a a3       	std	Y+34, r25	; 0x22
    2438:	89 a3       	std	Y+33, r24	; 0x21
    243a:	0f c0       	rjmp	.+30     	; 0x245a <CLCD_vidSendCommand+0x1e2>
    243c:	88 ec       	ldi	r24, 0xC8	; 200
    243e:	90 e0       	ldi	r25, 0x00	; 0
    2440:	98 a3       	std	Y+32, r25	; 0x20
    2442:	8f 8f       	std	Y+31, r24	; 0x1f
    2444:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2446:	98 a1       	ldd	r25, Y+32	; 0x20
    2448:	01 97       	sbiw	r24, 0x01	; 1
    244a:	f1 f7       	brne	.-4      	; 0x2448 <CLCD_vidSendCommand+0x1d0>
    244c:	98 a3       	std	Y+32, r25	; 0x20
    244e:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2450:	89 a1       	ldd	r24, Y+33	; 0x21
    2452:	9a a1       	ldd	r25, Y+34	; 0x22
    2454:	01 97       	sbiw	r24, 0x01	; 1
    2456:	9a a3       	std	Y+34, r25	; 0x22
    2458:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    245a:	89 a1       	ldd	r24, Y+33	; 0x21
    245c:	9a a1       	ldd	r25, Y+34	; 0x22
    245e:	00 97       	sbiw	r24, 0x00	; 0
    2460:	69 f7       	brne	.-38     	; 0x243c <CLCD_vidSendCommand+0x1c4>
    2462:	14 c0       	rjmp	.+40     	; 0x248c <CLCD_vidSendCommand+0x214>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2464:	6b a1       	ldd	r22, Y+35	; 0x23
    2466:	7c a1       	ldd	r23, Y+36	; 0x24
    2468:	8d a1       	ldd	r24, Y+37	; 0x25
    246a:	9e a1       	ldd	r25, Y+38	; 0x26
    246c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2470:	dc 01       	movw	r26, r24
    2472:	cb 01       	movw	r24, r22
    2474:	9a a3       	std	Y+34, r25	; 0x22
    2476:	89 a3       	std	Y+33, r24	; 0x21
    2478:	89 a1       	ldd	r24, Y+33	; 0x21
    247a:	9a a1       	ldd	r25, Y+34	; 0x22
    247c:	9e 8f       	std	Y+30, r25	; 0x1e
    247e:	8d 8f       	std	Y+29, r24	; 0x1d
    2480:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2482:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2484:	01 97       	sbiw	r24, 0x01	; 1
    2486:	f1 f7       	brne	.-4      	; 0x2484 <CLCD_vidSendCommand+0x20c>
    2488:	9e 8f       	std	Y+30, r25	; 0x1e
    248a:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
// 	/*send lower half of command*/
	DIO_u8SetPortValue(CLCD_DATA_PORT,((copy_u8Command&0x0f)<<4));//& 0x0f)<<4
    248c:	89 ad       	ldd	r24, Y+57	; 0x39
    248e:	88 2f       	mov	r24, r24
    2490:	90 e0       	ldi	r25, 0x00	; 0
    2492:	82 95       	swap	r24
    2494:	92 95       	swap	r25
    2496:	90 7f       	andi	r25, 0xF0	; 240
    2498:	98 27       	eor	r25, r24
    249a:	80 7f       	andi	r24, 0xF0	; 240
    249c:	98 27       	eor	r25, r24
    249e:	98 2f       	mov	r25, r24
    24a0:	80 e0       	ldi	r24, 0x00	; 0
    24a2:	69 2f       	mov	r22, r25
    24a4:	0e 94 be 0c 	call	0x197c	; 0x197c <DIO_u8SetPortValue>
	/*send enable pulse */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_HIGH);
    24a8:	81 e0       	ldi	r24, 0x01	; 1
    24aa:	60 e0       	ldi	r22, 0x00	; 0
    24ac:	41 e0       	ldi	r20, 0x01	; 1
    24ae:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
    24b2:	80 e0       	ldi	r24, 0x00	; 0
    24b4:	90 e0       	ldi	r25, 0x00	; 0
    24b6:	a0 e8       	ldi	r26, 0x80	; 128
    24b8:	bf e3       	ldi	r27, 0x3F	; 63
    24ba:	89 8f       	std	Y+25, r24	; 0x19
    24bc:	9a 8f       	std	Y+26, r25	; 0x1a
    24be:	ab 8f       	std	Y+27, r26	; 0x1b
    24c0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    24c2:	69 8d       	ldd	r22, Y+25	; 0x19
    24c4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    24c6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    24c8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    24ca:	20 e0       	ldi	r18, 0x00	; 0
    24cc:	30 e0       	ldi	r19, 0x00	; 0
    24ce:	4a ef       	ldi	r20, 0xFA	; 250
    24d0:	54 e4       	ldi	r21, 0x44	; 68
    24d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    24d6:	dc 01       	movw	r26, r24
    24d8:	cb 01       	movw	r24, r22
    24da:	8d 8b       	std	Y+21, r24	; 0x15
    24dc:	9e 8b       	std	Y+22, r25	; 0x16
    24de:	af 8b       	std	Y+23, r26	; 0x17
    24e0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    24e2:	6d 89       	ldd	r22, Y+21	; 0x15
    24e4:	7e 89       	ldd	r23, Y+22	; 0x16
    24e6:	8f 89       	ldd	r24, Y+23	; 0x17
    24e8:	98 8d       	ldd	r25, Y+24	; 0x18
    24ea:	20 e0       	ldi	r18, 0x00	; 0
    24ec:	30 e0       	ldi	r19, 0x00	; 0
    24ee:	40 e8       	ldi	r20, 0x80	; 128
    24f0:	5f e3       	ldi	r21, 0x3F	; 63
    24f2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    24f6:	88 23       	and	r24, r24
    24f8:	2c f4       	brge	.+10     	; 0x2504 <CLCD_vidSendCommand+0x28c>
		__ticks = 1;
    24fa:	81 e0       	ldi	r24, 0x01	; 1
    24fc:	90 e0       	ldi	r25, 0x00	; 0
    24fe:	9c 8b       	std	Y+20, r25	; 0x14
    2500:	8b 8b       	std	Y+19, r24	; 0x13
    2502:	3f c0       	rjmp	.+126    	; 0x2582 <CLCD_vidSendCommand+0x30a>
	else if (__tmp > 65535)
    2504:	6d 89       	ldd	r22, Y+21	; 0x15
    2506:	7e 89       	ldd	r23, Y+22	; 0x16
    2508:	8f 89       	ldd	r24, Y+23	; 0x17
    250a:	98 8d       	ldd	r25, Y+24	; 0x18
    250c:	20 e0       	ldi	r18, 0x00	; 0
    250e:	3f ef       	ldi	r19, 0xFF	; 255
    2510:	4f e7       	ldi	r20, 0x7F	; 127
    2512:	57 e4       	ldi	r21, 0x47	; 71
    2514:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2518:	18 16       	cp	r1, r24
    251a:	4c f5       	brge	.+82     	; 0x256e <CLCD_vidSendCommand+0x2f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    251c:	69 8d       	ldd	r22, Y+25	; 0x19
    251e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2520:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2522:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2524:	20 e0       	ldi	r18, 0x00	; 0
    2526:	30 e0       	ldi	r19, 0x00	; 0
    2528:	40 e2       	ldi	r20, 0x20	; 32
    252a:	51 e4       	ldi	r21, 0x41	; 65
    252c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2530:	dc 01       	movw	r26, r24
    2532:	cb 01       	movw	r24, r22
    2534:	bc 01       	movw	r22, r24
    2536:	cd 01       	movw	r24, r26
    2538:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    253c:	dc 01       	movw	r26, r24
    253e:	cb 01       	movw	r24, r22
    2540:	9c 8b       	std	Y+20, r25	; 0x14
    2542:	8b 8b       	std	Y+19, r24	; 0x13
    2544:	0f c0       	rjmp	.+30     	; 0x2564 <CLCD_vidSendCommand+0x2ec>
    2546:	88 ec       	ldi	r24, 0xC8	; 200
    2548:	90 e0       	ldi	r25, 0x00	; 0
    254a:	9a 8b       	std	Y+18, r25	; 0x12
    254c:	89 8b       	std	Y+17, r24	; 0x11
    254e:	89 89       	ldd	r24, Y+17	; 0x11
    2550:	9a 89       	ldd	r25, Y+18	; 0x12
    2552:	01 97       	sbiw	r24, 0x01	; 1
    2554:	f1 f7       	brne	.-4      	; 0x2552 <CLCD_vidSendCommand+0x2da>
    2556:	9a 8b       	std	Y+18, r25	; 0x12
    2558:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    255a:	8b 89       	ldd	r24, Y+19	; 0x13
    255c:	9c 89       	ldd	r25, Y+20	; 0x14
    255e:	01 97       	sbiw	r24, 0x01	; 1
    2560:	9c 8b       	std	Y+20, r25	; 0x14
    2562:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2564:	8b 89       	ldd	r24, Y+19	; 0x13
    2566:	9c 89       	ldd	r25, Y+20	; 0x14
    2568:	00 97       	sbiw	r24, 0x00	; 0
    256a:	69 f7       	brne	.-38     	; 0x2546 <CLCD_vidSendCommand+0x2ce>
    256c:	14 c0       	rjmp	.+40     	; 0x2596 <CLCD_vidSendCommand+0x31e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    256e:	6d 89       	ldd	r22, Y+21	; 0x15
    2570:	7e 89       	ldd	r23, Y+22	; 0x16
    2572:	8f 89       	ldd	r24, Y+23	; 0x17
    2574:	98 8d       	ldd	r25, Y+24	; 0x18
    2576:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    257a:	dc 01       	movw	r26, r24
    257c:	cb 01       	movw	r24, r22
    257e:	9c 8b       	std	Y+20, r25	; 0x14
    2580:	8b 8b       	std	Y+19, r24	; 0x13
    2582:	8b 89       	ldd	r24, Y+19	; 0x13
    2584:	9c 89       	ldd	r25, Y+20	; 0x14
    2586:	98 8b       	std	Y+16, r25	; 0x10
    2588:	8f 87       	std	Y+15, r24	; 0x0f
    258a:	8f 85       	ldd	r24, Y+15	; 0x0f
    258c:	98 89       	ldd	r25, Y+16	; 0x10
    258e:	01 97       	sbiw	r24, 0x01	; 1
    2590:	f1 f7       	brne	.-4      	; 0x258e <CLCD_vidSendCommand+0x316>
    2592:	98 8b       	std	Y+16, r25	; 0x10
    2594:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*set enable again to zero*/
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_LOW);
    2596:	81 e0       	ldi	r24, 0x01	; 1
    2598:	60 e0       	ldi	r22, 0x00	; 0
    259a:	40 e0       	ldi	r20, 0x00	; 0
    259c:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
    25a0:	80 e0       	ldi	r24, 0x00	; 0
    25a2:	90 e0       	ldi	r25, 0x00	; 0
    25a4:	a0 e8       	ldi	r26, 0x80	; 128
    25a6:	bf e3       	ldi	r27, 0x3F	; 63
    25a8:	8b 87       	std	Y+11, r24	; 0x0b
    25aa:	9c 87       	std	Y+12, r25	; 0x0c
    25ac:	ad 87       	std	Y+13, r26	; 0x0d
    25ae:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    25b0:	6b 85       	ldd	r22, Y+11	; 0x0b
    25b2:	7c 85       	ldd	r23, Y+12	; 0x0c
    25b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    25b6:	9e 85       	ldd	r25, Y+14	; 0x0e
    25b8:	20 e0       	ldi	r18, 0x00	; 0
    25ba:	30 e0       	ldi	r19, 0x00	; 0
    25bc:	4a ef       	ldi	r20, 0xFA	; 250
    25be:	54 e4       	ldi	r21, 0x44	; 68
    25c0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    25c4:	dc 01       	movw	r26, r24
    25c6:	cb 01       	movw	r24, r22
    25c8:	8f 83       	std	Y+7, r24	; 0x07
    25ca:	98 87       	std	Y+8, r25	; 0x08
    25cc:	a9 87       	std	Y+9, r26	; 0x09
    25ce:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    25d0:	6f 81       	ldd	r22, Y+7	; 0x07
    25d2:	78 85       	ldd	r23, Y+8	; 0x08
    25d4:	89 85       	ldd	r24, Y+9	; 0x09
    25d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    25d8:	20 e0       	ldi	r18, 0x00	; 0
    25da:	30 e0       	ldi	r19, 0x00	; 0
    25dc:	40 e8       	ldi	r20, 0x80	; 128
    25de:	5f e3       	ldi	r21, 0x3F	; 63
    25e0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    25e4:	88 23       	and	r24, r24
    25e6:	2c f4       	brge	.+10     	; 0x25f2 <CLCD_vidSendCommand+0x37a>
		__ticks = 1;
    25e8:	81 e0       	ldi	r24, 0x01	; 1
    25ea:	90 e0       	ldi	r25, 0x00	; 0
    25ec:	9e 83       	std	Y+6, r25	; 0x06
    25ee:	8d 83       	std	Y+5, r24	; 0x05
    25f0:	3f c0       	rjmp	.+126    	; 0x2670 <CLCD_vidSendCommand+0x3f8>
	else if (__tmp > 65535)
    25f2:	6f 81       	ldd	r22, Y+7	; 0x07
    25f4:	78 85       	ldd	r23, Y+8	; 0x08
    25f6:	89 85       	ldd	r24, Y+9	; 0x09
    25f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    25fa:	20 e0       	ldi	r18, 0x00	; 0
    25fc:	3f ef       	ldi	r19, 0xFF	; 255
    25fe:	4f e7       	ldi	r20, 0x7F	; 127
    2600:	57 e4       	ldi	r21, 0x47	; 71
    2602:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2606:	18 16       	cp	r1, r24
    2608:	4c f5       	brge	.+82     	; 0x265c <CLCD_vidSendCommand+0x3e4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    260a:	6b 85       	ldd	r22, Y+11	; 0x0b
    260c:	7c 85       	ldd	r23, Y+12	; 0x0c
    260e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2610:	9e 85       	ldd	r25, Y+14	; 0x0e
    2612:	20 e0       	ldi	r18, 0x00	; 0
    2614:	30 e0       	ldi	r19, 0x00	; 0
    2616:	40 e2       	ldi	r20, 0x20	; 32
    2618:	51 e4       	ldi	r21, 0x41	; 65
    261a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    261e:	dc 01       	movw	r26, r24
    2620:	cb 01       	movw	r24, r22
    2622:	bc 01       	movw	r22, r24
    2624:	cd 01       	movw	r24, r26
    2626:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    262a:	dc 01       	movw	r26, r24
    262c:	cb 01       	movw	r24, r22
    262e:	9e 83       	std	Y+6, r25	; 0x06
    2630:	8d 83       	std	Y+5, r24	; 0x05
    2632:	0f c0       	rjmp	.+30     	; 0x2652 <CLCD_vidSendCommand+0x3da>
    2634:	88 ec       	ldi	r24, 0xC8	; 200
    2636:	90 e0       	ldi	r25, 0x00	; 0
    2638:	9c 83       	std	Y+4, r25	; 0x04
    263a:	8b 83       	std	Y+3, r24	; 0x03
    263c:	8b 81       	ldd	r24, Y+3	; 0x03
    263e:	9c 81       	ldd	r25, Y+4	; 0x04
    2640:	01 97       	sbiw	r24, 0x01	; 1
    2642:	f1 f7       	brne	.-4      	; 0x2640 <CLCD_vidSendCommand+0x3c8>
    2644:	9c 83       	std	Y+4, r25	; 0x04
    2646:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2648:	8d 81       	ldd	r24, Y+5	; 0x05
    264a:	9e 81       	ldd	r25, Y+6	; 0x06
    264c:	01 97       	sbiw	r24, 0x01	; 1
    264e:	9e 83       	std	Y+6, r25	; 0x06
    2650:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2652:	8d 81       	ldd	r24, Y+5	; 0x05
    2654:	9e 81       	ldd	r25, Y+6	; 0x06
    2656:	00 97       	sbiw	r24, 0x00	; 0
    2658:	69 f7       	brne	.-38     	; 0x2634 <CLCD_vidSendCommand+0x3bc>
    265a:	14 c0       	rjmp	.+40     	; 0x2684 <CLCD_vidSendCommand+0x40c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    265c:	6f 81       	ldd	r22, Y+7	; 0x07
    265e:	78 85       	ldd	r23, Y+8	; 0x08
    2660:	89 85       	ldd	r24, Y+9	; 0x09
    2662:	9a 85       	ldd	r25, Y+10	; 0x0a
    2664:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2668:	dc 01       	movw	r26, r24
    266a:	cb 01       	movw	r24, r22
    266c:	9e 83       	std	Y+6, r25	; 0x06
    266e:	8d 83       	std	Y+5, r24	; 0x05
    2670:	8d 81       	ldd	r24, Y+5	; 0x05
    2672:	9e 81       	ldd	r25, Y+6	; 0x06
    2674:	9a 83       	std	Y+2, r25	; 0x02
    2676:	89 83       	std	Y+1, r24	; 0x01
    2678:	89 81       	ldd	r24, Y+1	; 0x01
    267a:	9a 81       	ldd	r25, Y+2	; 0x02
    267c:	01 97       	sbiw	r24, 0x01	; 1
    267e:	f1 f7       	brne	.-4      	; 0x267c <CLCD_vidSendCommand+0x404>
    2680:	9a 83       	std	Y+2, r25	; 0x02
    2682:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
}
    2684:	e9 96       	adiw	r28, 0x39	; 57
    2686:	0f b6       	in	r0, 0x3f	; 63
    2688:	f8 94       	cli
    268a:	de bf       	out	0x3e, r29	; 62
    268c:	0f be       	out	0x3f, r0	; 63
    268e:	cd bf       	out	0x3d, r28	; 61
    2690:	cf 91       	pop	r28
    2692:	df 91       	pop	r29
    2694:	08 95       	ret

00002696 <CLCD_vidSendData>:

/*function that send data to display on LCD*/
void CLCD_vidSendData(u8 copy_u8Data)
{
    2696:	df 93       	push	r29
    2698:	cf 93       	push	r28
    269a:	cd b7       	in	r28, 0x3d	; 61
    269c:	de b7       	in	r29, 0x3e	; 62
    269e:	e9 97       	sbiw	r28, 0x39	; 57
    26a0:	0f b6       	in	r0, 0x3f	; 63
    26a2:	f8 94       	cli
    26a4:	de bf       	out	0x3e, r29	; 62
    26a6:	0f be       	out	0x3f, r0	; 63
    26a8:	cd bf       	out	0x3d, r28	; 61
    26aa:	89 af       	std	Y+57, r24	; 0x39
	/*set rs pin to high  for data  */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_RS_PIN,DIO_u8PIN_HIGH);
    26ac:	81 e0       	ldi	r24, 0x01	; 1
    26ae:	61 e0       	ldi	r22, 0x01	; 1
    26b0:	41 e0       	ldi	r20, 0x01	; 1
    26b2:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
	/*set R/W pin to 0 to active write */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_RW_PIN,DIO_u8PIN_LOW);
    26b6:	81 e0       	ldi	r24, 0x01	; 1
    26b8:	62 e0       	ldi	r22, 0x02	; 2
    26ba:	40 e0       	ldi	r20, 0x00	; 0
    26bc:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
	
	/*send upper half of data */
	/*set data to data pins */
	DIO_u8SetPortValue(CLCD_DATA_PORT,(copy_u8Data&0xf0));//&0xf0)
    26c0:	89 ad       	ldd	r24, Y+57	; 0x39
    26c2:	98 2f       	mov	r25, r24
    26c4:	90 7f       	andi	r25, 0xF0	; 240
    26c6:	80 e0       	ldi	r24, 0x00	; 0
    26c8:	69 2f       	mov	r22, r25
    26ca:	0e 94 be 0c 	call	0x197c	; 0x197c <DIO_u8SetPortValue>
	/*send enable pulse */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_HIGH);
    26ce:	81 e0       	ldi	r24, 0x01	; 1
    26d0:	60 e0       	ldi	r22, 0x00	; 0
    26d2:	41 e0       	ldi	r20, 0x01	; 1
    26d4:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
    26d8:	80 e0       	ldi	r24, 0x00	; 0
    26da:	90 e0       	ldi	r25, 0x00	; 0
    26dc:	a0 e8       	ldi	r26, 0x80	; 128
    26de:	bf e3       	ldi	r27, 0x3F	; 63
    26e0:	8d ab       	std	Y+53, r24	; 0x35
    26e2:	9e ab       	std	Y+54, r25	; 0x36
    26e4:	af ab       	std	Y+55, r26	; 0x37
    26e6:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    26e8:	6d a9       	ldd	r22, Y+53	; 0x35
    26ea:	7e a9       	ldd	r23, Y+54	; 0x36
    26ec:	8f a9       	ldd	r24, Y+55	; 0x37
    26ee:	98 ad       	ldd	r25, Y+56	; 0x38
    26f0:	20 e0       	ldi	r18, 0x00	; 0
    26f2:	30 e0       	ldi	r19, 0x00	; 0
    26f4:	4a ef       	ldi	r20, 0xFA	; 250
    26f6:	54 e4       	ldi	r21, 0x44	; 68
    26f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26fc:	dc 01       	movw	r26, r24
    26fe:	cb 01       	movw	r24, r22
    2700:	89 ab       	std	Y+49, r24	; 0x31
    2702:	9a ab       	std	Y+50, r25	; 0x32
    2704:	ab ab       	std	Y+51, r26	; 0x33
    2706:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    2708:	69 a9       	ldd	r22, Y+49	; 0x31
    270a:	7a a9       	ldd	r23, Y+50	; 0x32
    270c:	8b a9       	ldd	r24, Y+51	; 0x33
    270e:	9c a9       	ldd	r25, Y+52	; 0x34
    2710:	20 e0       	ldi	r18, 0x00	; 0
    2712:	30 e0       	ldi	r19, 0x00	; 0
    2714:	40 e8       	ldi	r20, 0x80	; 128
    2716:	5f e3       	ldi	r21, 0x3F	; 63
    2718:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    271c:	88 23       	and	r24, r24
    271e:	2c f4       	brge	.+10     	; 0x272a <CLCD_vidSendData+0x94>
		__ticks = 1;
    2720:	81 e0       	ldi	r24, 0x01	; 1
    2722:	90 e0       	ldi	r25, 0x00	; 0
    2724:	98 ab       	std	Y+48, r25	; 0x30
    2726:	8f a7       	std	Y+47, r24	; 0x2f
    2728:	3f c0       	rjmp	.+126    	; 0x27a8 <CLCD_vidSendData+0x112>
	else if (__tmp > 65535)
    272a:	69 a9       	ldd	r22, Y+49	; 0x31
    272c:	7a a9       	ldd	r23, Y+50	; 0x32
    272e:	8b a9       	ldd	r24, Y+51	; 0x33
    2730:	9c a9       	ldd	r25, Y+52	; 0x34
    2732:	20 e0       	ldi	r18, 0x00	; 0
    2734:	3f ef       	ldi	r19, 0xFF	; 255
    2736:	4f e7       	ldi	r20, 0x7F	; 127
    2738:	57 e4       	ldi	r21, 0x47	; 71
    273a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    273e:	18 16       	cp	r1, r24
    2740:	4c f5       	brge	.+82     	; 0x2794 <CLCD_vidSendData+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2742:	6d a9       	ldd	r22, Y+53	; 0x35
    2744:	7e a9       	ldd	r23, Y+54	; 0x36
    2746:	8f a9       	ldd	r24, Y+55	; 0x37
    2748:	98 ad       	ldd	r25, Y+56	; 0x38
    274a:	20 e0       	ldi	r18, 0x00	; 0
    274c:	30 e0       	ldi	r19, 0x00	; 0
    274e:	40 e2       	ldi	r20, 0x20	; 32
    2750:	51 e4       	ldi	r21, 0x41	; 65
    2752:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2756:	dc 01       	movw	r26, r24
    2758:	cb 01       	movw	r24, r22
    275a:	bc 01       	movw	r22, r24
    275c:	cd 01       	movw	r24, r26
    275e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2762:	dc 01       	movw	r26, r24
    2764:	cb 01       	movw	r24, r22
    2766:	98 ab       	std	Y+48, r25	; 0x30
    2768:	8f a7       	std	Y+47, r24	; 0x2f
    276a:	0f c0       	rjmp	.+30     	; 0x278a <CLCD_vidSendData+0xf4>
    276c:	88 ec       	ldi	r24, 0xC8	; 200
    276e:	90 e0       	ldi	r25, 0x00	; 0
    2770:	9e a7       	std	Y+46, r25	; 0x2e
    2772:	8d a7       	std	Y+45, r24	; 0x2d
    2774:	8d a5       	ldd	r24, Y+45	; 0x2d
    2776:	9e a5       	ldd	r25, Y+46	; 0x2e
    2778:	01 97       	sbiw	r24, 0x01	; 1
    277a:	f1 f7       	brne	.-4      	; 0x2778 <CLCD_vidSendData+0xe2>
    277c:	9e a7       	std	Y+46, r25	; 0x2e
    277e:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2780:	8f a5       	ldd	r24, Y+47	; 0x2f
    2782:	98 a9       	ldd	r25, Y+48	; 0x30
    2784:	01 97       	sbiw	r24, 0x01	; 1
    2786:	98 ab       	std	Y+48, r25	; 0x30
    2788:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    278a:	8f a5       	ldd	r24, Y+47	; 0x2f
    278c:	98 a9       	ldd	r25, Y+48	; 0x30
    278e:	00 97       	sbiw	r24, 0x00	; 0
    2790:	69 f7       	brne	.-38     	; 0x276c <CLCD_vidSendData+0xd6>
    2792:	14 c0       	rjmp	.+40     	; 0x27bc <CLCD_vidSendData+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2794:	69 a9       	ldd	r22, Y+49	; 0x31
    2796:	7a a9       	ldd	r23, Y+50	; 0x32
    2798:	8b a9       	ldd	r24, Y+51	; 0x33
    279a:	9c a9       	ldd	r25, Y+52	; 0x34
    279c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    27a0:	dc 01       	movw	r26, r24
    27a2:	cb 01       	movw	r24, r22
    27a4:	98 ab       	std	Y+48, r25	; 0x30
    27a6:	8f a7       	std	Y+47, r24	; 0x2f
    27a8:	8f a5       	ldd	r24, Y+47	; 0x2f
    27aa:	98 a9       	ldd	r25, Y+48	; 0x30
    27ac:	9c a7       	std	Y+44, r25	; 0x2c
    27ae:	8b a7       	std	Y+43, r24	; 0x2b
    27b0:	8b a5       	ldd	r24, Y+43	; 0x2b
    27b2:	9c a5       	ldd	r25, Y+44	; 0x2c
    27b4:	01 97       	sbiw	r24, 0x01	; 1
    27b6:	f1 f7       	brne	.-4      	; 0x27b4 <CLCD_vidSendData+0x11e>
    27b8:	9c a7       	std	Y+44, r25	; 0x2c
    27ba:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1);
	/*set enable again to zero*/
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_LOW);
    27bc:	81 e0       	ldi	r24, 0x01	; 1
    27be:	60 e0       	ldi	r22, 0x00	; 0
    27c0:	40 e0       	ldi	r20, 0x00	; 0
    27c2:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
    27c6:	80 e0       	ldi	r24, 0x00	; 0
    27c8:	90 e0       	ldi	r25, 0x00	; 0
    27ca:	a0 e8       	ldi	r26, 0x80	; 128
    27cc:	bf e3       	ldi	r27, 0x3F	; 63
    27ce:	8f a3       	std	Y+39, r24	; 0x27
    27d0:	98 a7       	std	Y+40, r25	; 0x28
    27d2:	a9 a7       	std	Y+41, r26	; 0x29
    27d4:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    27d6:	6f a1       	ldd	r22, Y+39	; 0x27
    27d8:	78 a5       	ldd	r23, Y+40	; 0x28
    27da:	89 a5       	ldd	r24, Y+41	; 0x29
    27dc:	9a a5       	ldd	r25, Y+42	; 0x2a
    27de:	20 e0       	ldi	r18, 0x00	; 0
    27e0:	30 e0       	ldi	r19, 0x00	; 0
    27e2:	4a ef       	ldi	r20, 0xFA	; 250
    27e4:	54 e4       	ldi	r21, 0x44	; 68
    27e6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27ea:	dc 01       	movw	r26, r24
    27ec:	cb 01       	movw	r24, r22
    27ee:	8b a3       	std	Y+35, r24	; 0x23
    27f0:	9c a3       	std	Y+36, r25	; 0x24
    27f2:	ad a3       	std	Y+37, r26	; 0x25
    27f4:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    27f6:	6b a1       	ldd	r22, Y+35	; 0x23
    27f8:	7c a1       	ldd	r23, Y+36	; 0x24
    27fa:	8d a1       	ldd	r24, Y+37	; 0x25
    27fc:	9e a1       	ldd	r25, Y+38	; 0x26
    27fe:	20 e0       	ldi	r18, 0x00	; 0
    2800:	30 e0       	ldi	r19, 0x00	; 0
    2802:	40 e8       	ldi	r20, 0x80	; 128
    2804:	5f e3       	ldi	r21, 0x3F	; 63
    2806:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    280a:	88 23       	and	r24, r24
    280c:	2c f4       	brge	.+10     	; 0x2818 <CLCD_vidSendData+0x182>
		__ticks = 1;
    280e:	81 e0       	ldi	r24, 0x01	; 1
    2810:	90 e0       	ldi	r25, 0x00	; 0
    2812:	9a a3       	std	Y+34, r25	; 0x22
    2814:	89 a3       	std	Y+33, r24	; 0x21
    2816:	3f c0       	rjmp	.+126    	; 0x2896 <CLCD_vidSendData+0x200>
	else if (__tmp > 65535)
    2818:	6b a1       	ldd	r22, Y+35	; 0x23
    281a:	7c a1       	ldd	r23, Y+36	; 0x24
    281c:	8d a1       	ldd	r24, Y+37	; 0x25
    281e:	9e a1       	ldd	r25, Y+38	; 0x26
    2820:	20 e0       	ldi	r18, 0x00	; 0
    2822:	3f ef       	ldi	r19, 0xFF	; 255
    2824:	4f e7       	ldi	r20, 0x7F	; 127
    2826:	57 e4       	ldi	r21, 0x47	; 71
    2828:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    282c:	18 16       	cp	r1, r24
    282e:	4c f5       	brge	.+82     	; 0x2882 <CLCD_vidSendData+0x1ec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2830:	6f a1       	ldd	r22, Y+39	; 0x27
    2832:	78 a5       	ldd	r23, Y+40	; 0x28
    2834:	89 a5       	ldd	r24, Y+41	; 0x29
    2836:	9a a5       	ldd	r25, Y+42	; 0x2a
    2838:	20 e0       	ldi	r18, 0x00	; 0
    283a:	30 e0       	ldi	r19, 0x00	; 0
    283c:	40 e2       	ldi	r20, 0x20	; 32
    283e:	51 e4       	ldi	r21, 0x41	; 65
    2840:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2844:	dc 01       	movw	r26, r24
    2846:	cb 01       	movw	r24, r22
    2848:	bc 01       	movw	r22, r24
    284a:	cd 01       	movw	r24, r26
    284c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2850:	dc 01       	movw	r26, r24
    2852:	cb 01       	movw	r24, r22
    2854:	9a a3       	std	Y+34, r25	; 0x22
    2856:	89 a3       	std	Y+33, r24	; 0x21
    2858:	0f c0       	rjmp	.+30     	; 0x2878 <CLCD_vidSendData+0x1e2>
    285a:	88 ec       	ldi	r24, 0xC8	; 200
    285c:	90 e0       	ldi	r25, 0x00	; 0
    285e:	98 a3       	std	Y+32, r25	; 0x20
    2860:	8f 8f       	std	Y+31, r24	; 0x1f
    2862:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2864:	98 a1       	ldd	r25, Y+32	; 0x20
    2866:	01 97       	sbiw	r24, 0x01	; 1
    2868:	f1 f7       	brne	.-4      	; 0x2866 <CLCD_vidSendData+0x1d0>
    286a:	98 a3       	std	Y+32, r25	; 0x20
    286c:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    286e:	89 a1       	ldd	r24, Y+33	; 0x21
    2870:	9a a1       	ldd	r25, Y+34	; 0x22
    2872:	01 97       	sbiw	r24, 0x01	; 1
    2874:	9a a3       	std	Y+34, r25	; 0x22
    2876:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2878:	89 a1       	ldd	r24, Y+33	; 0x21
    287a:	9a a1       	ldd	r25, Y+34	; 0x22
    287c:	00 97       	sbiw	r24, 0x00	; 0
    287e:	69 f7       	brne	.-38     	; 0x285a <CLCD_vidSendData+0x1c4>
    2880:	14 c0       	rjmp	.+40     	; 0x28aa <CLCD_vidSendData+0x214>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2882:	6b a1       	ldd	r22, Y+35	; 0x23
    2884:	7c a1       	ldd	r23, Y+36	; 0x24
    2886:	8d a1       	ldd	r24, Y+37	; 0x25
    2888:	9e a1       	ldd	r25, Y+38	; 0x26
    288a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    288e:	dc 01       	movw	r26, r24
    2890:	cb 01       	movw	r24, r22
    2892:	9a a3       	std	Y+34, r25	; 0x22
    2894:	89 a3       	std	Y+33, r24	; 0x21
    2896:	89 a1       	ldd	r24, Y+33	; 0x21
    2898:	9a a1       	ldd	r25, Y+34	; 0x22
    289a:	9e 8f       	std	Y+30, r25	; 0x1e
    289c:	8d 8f       	std	Y+29, r24	; 0x1d
    289e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    28a0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    28a2:	01 97       	sbiw	r24, 0x01	; 1
    28a4:	f1 f7       	brne	.-4      	; 0x28a2 <CLCD_vidSendData+0x20c>
    28a6:	9e 8f       	std	Y+30, r25	; 0x1e
    28a8:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
 	/*send lower half of data */
	DIO_u8SetPortValue(CLCD_DATA_PORT,((copy_u8Data&0x0f)<<4));//&0xf0)<<4
    28aa:	89 ad       	ldd	r24, Y+57	; 0x39
    28ac:	88 2f       	mov	r24, r24
    28ae:	90 e0       	ldi	r25, 0x00	; 0
    28b0:	82 95       	swap	r24
    28b2:	92 95       	swap	r25
    28b4:	90 7f       	andi	r25, 0xF0	; 240
    28b6:	98 27       	eor	r25, r24
    28b8:	80 7f       	andi	r24, 0xF0	; 240
    28ba:	98 27       	eor	r25, r24
    28bc:	98 2f       	mov	r25, r24
    28be:	80 e0       	ldi	r24, 0x00	; 0
    28c0:	69 2f       	mov	r22, r25
    28c2:	0e 94 be 0c 	call	0x197c	; 0x197c <DIO_u8SetPortValue>
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_HIGH);
    28c6:	81 e0       	ldi	r24, 0x01	; 1
    28c8:	60 e0       	ldi	r22, 0x00	; 0
    28ca:	41 e0       	ldi	r20, 0x01	; 1
    28cc:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
    28d0:	80 e0       	ldi	r24, 0x00	; 0
    28d2:	90 e0       	ldi	r25, 0x00	; 0
    28d4:	a0 e8       	ldi	r26, 0x80	; 128
    28d6:	bf e3       	ldi	r27, 0x3F	; 63
    28d8:	89 8f       	std	Y+25, r24	; 0x19
    28da:	9a 8f       	std	Y+26, r25	; 0x1a
    28dc:	ab 8f       	std	Y+27, r26	; 0x1b
    28de:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    28e0:	69 8d       	ldd	r22, Y+25	; 0x19
    28e2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    28e4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    28e6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    28e8:	20 e0       	ldi	r18, 0x00	; 0
    28ea:	30 e0       	ldi	r19, 0x00	; 0
    28ec:	4a ef       	ldi	r20, 0xFA	; 250
    28ee:	54 e4       	ldi	r21, 0x44	; 68
    28f0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    28f4:	dc 01       	movw	r26, r24
    28f6:	cb 01       	movw	r24, r22
    28f8:	8d 8b       	std	Y+21, r24	; 0x15
    28fa:	9e 8b       	std	Y+22, r25	; 0x16
    28fc:	af 8b       	std	Y+23, r26	; 0x17
    28fe:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2900:	6d 89       	ldd	r22, Y+21	; 0x15
    2902:	7e 89       	ldd	r23, Y+22	; 0x16
    2904:	8f 89       	ldd	r24, Y+23	; 0x17
    2906:	98 8d       	ldd	r25, Y+24	; 0x18
    2908:	20 e0       	ldi	r18, 0x00	; 0
    290a:	30 e0       	ldi	r19, 0x00	; 0
    290c:	40 e8       	ldi	r20, 0x80	; 128
    290e:	5f e3       	ldi	r21, 0x3F	; 63
    2910:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2914:	88 23       	and	r24, r24
    2916:	2c f4       	brge	.+10     	; 0x2922 <CLCD_vidSendData+0x28c>
		__ticks = 1;
    2918:	81 e0       	ldi	r24, 0x01	; 1
    291a:	90 e0       	ldi	r25, 0x00	; 0
    291c:	9c 8b       	std	Y+20, r25	; 0x14
    291e:	8b 8b       	std	Y+19, r24	; 0x13
    2920:	3f c0       	rjmp	.+126    	; 0x29a0 <CLCD_vidSendData+0x30a>
	else if (__tmp > 65535)
    2922:	6d 89       	ldd	r22, Y+21	; 0x15
    2924:	7e 89       	ldd	r23, Y+22	; 0x16
    2926:	8f 89       	ldd	r24, Y+23	; 0x17
    2928:	98 8d       	ldd	r25, Y+24	; 0x18
    292a:	20 e0       	ldi	r18, 0x00	; 0
    292c:	3f ef       	ldi	r19, 0xFF	; 255
    292e:	4f e7       	ldi	r20, 0x7F	; 127
    2930:	57 e4       	ldi	r21, 0x47	; 71
    2932:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2936:	18 16       	cp	r1, r24
    2938:	4c f5       	brge	.+82     	; 0x298c <CLCD_vidSendData+0x2f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    293a:	69 8d       	ldd	r22, Y+25	; 0x19
    293c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    293e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2940:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2942:	20 e0       	ldi	r18, 0x00	; 0
    2944:	30 e0       	ldi	r19, 0x00	; 0
    2946:	40 e2       	ldi	r20, 0x20	; 32
    2948:	51 e4       	ldi	r21, 0x41	; 65
    294a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    294e:	dc 01       	movw	r26, r24
    2950:	cb 01       	movw	r24, r22
    2952:	bc 01       	movw	r22, r24
    2954:	cd 01       	movw	r24, r26
    2956:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    295a:	dc 01       	movw	r26, r24
    295c:	cb 01       	movw	r24, r22
    295e:	9c 8b       	std	Y+20, r25	; 0x14
    2960:	8b 8b       	std	Y+19, r24	; 0x13
    2962:	0f c0       	rjmp	.+30     	; 0x2982 <CLCD_vidSendData+0x2ec>
    2964:	88 ec       	ldi	r24, 0xC8	; 200
    2966:	90 e0       	ldi	r25, 0x00	; 0
    2968:	9a 8b       	std	Y+18, r25	; 0x12
    296a:	89 8b       	std	Y+17, r24	; 0x11
    296c:	89 89       	ldd	r24, Y+17	; 0x11
    296e:	9a 89       	ldd	r25, Y+18	; 0x12
    2970:	01 97       	sbiw	r24, 0x01	; 1
    2972:	f1 f7       	brne	.-4      	; 0x2970 <CLCD_vidSendData+0x2da>
    2974:	9a 8b       	std	Y+18, r25	; 0x12
    2976:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2978:	8b 89       	ldd	r24, Y+19	; 0x13
    297a:	9c 89       	ldd	r25, Y+20	; 0x14
    297c:	01 97       	sbiw	r24, 0x01	; 1
    297e:	9c 8b       	std	Y+20, r25	; 0x14
    2980:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2982:	8b 89       	ldd	r24, Y+19	; 0x13
    2984:	9c 89       	ldd	r25, Y+20	; 0x14
    2986:	00 97       	sbiw	r24, 0x00	; 0
    2988:	69 f7       	brne	.-38     	; 0x2964 <CLCD_vidSendData+0x2ce>
    298a:	14 c0       	rjmp	.+40     	; 0x29b4 <CLCD_vidSendData+0x31e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    298c:	6d 89       	ldd	r22, Y+21	; 0x15
    298e:	7e 89       	ldd	r23, Y+22	; 0x16
    2990:	8f 89       	ldd	r24, Y+23	; 0x17
    2992:	98 8d       	ldd	r25, Y+24	; 0x18
    2994:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2998:	dc 01       	movw	r26, r24
    299a:	cb 01       	movw	r24, r22
    299c:	9c 8b       	std	Y+20, r25	; 0x14
    299e:	8b 8b       	std	Y+19, r24	; 0x13
    29a0:	8b 89       	ldd	r24, Y+19	; 0x13
    29a2:	9c 89       	ldd	r25, Y+20	; 0x14
    29a4:	98 8b       	std	Y+16, r25	; 0x10
    29a6:	8f 87       	std	Y+15, r24	; 0x0f
    29a8:	8f 85       	ldd	r24, Y+15	; 0x0f
    29aa:	98 89       	ldd	r25, Y+16	; 0x10
    29ac:	01 97       	sbiw	r24, 0x01	; 1
    29ae:	f1 f7       	brne	.-4      	; 0x29ac <CLCD_vidSendData+0x316>
    29b0:	98 8b       	std	Y+16, r25	; 0x10
    29b2:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*set enable again to zero*/
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_LOW);
    29b4:	81 e0       	ldi	r24, 0x01	; 1
    29b6:	60 e0       	ldi	r22, 0x00	; 0
    29b8:	40 e0       	ldi	r20, 0x00	; 0
    29ba:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
    29be:	80 e0       	ldi	r24, 0x00	; 0
    29c0:	90 e0       	ldi	r25, 0x00	; 0
    29c2:	a0 e8       	ldi	r26, 0x80	; 128
    29c4:	bf e3       	ldi	r27, 0x3F	; 63
    29c6:	8b 87       	std	Y+11, r24	; 0x0b
    29c8:	9c 87       	std	Y+12, r25	; 0x0c
    29ca:	ad 87       	std	Y+13, r26	; 0x0d
    29cc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    29ce:	6b 85       	ldd	r22, Y+11	; 0x0b
    29d0:	7c 85       	ldd	r23, Y+12	; 0x0c
    29d2:	8d 85       	ldd	r24, Y+13	; 0x0d
    29d4:	9e 85       	ldd	r25, Y+14	; 0x0e
    29d6:	20 e0       	ldi	r18, 0x00	; 0
    29d8:	30 e0       	ldi	r19, 0x00	; 0
    29da:	4a ef       	ldi	r20, 0xFA	; 250
    29dc:	54 e4       	ldi	r21, 0x44	; 68
    29de:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    29e2:	dc 01       	movw	r26, r24
    29e4:	cb 01       	movw	r24, r22
    29e6:	8f 83       	std	Y+7, r24	; 0x07
    29e8:	98 87       	std	Y+8, r25	; 0x08
    29ea:	a9 87       	std	Y+9, r26	; 0x09
    29ec:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    29ee:	6f 81       	ldd	r22, Y+7	; 0x07
    29f0:	78 85       	ldd	r23, Y+8	; 0x08
    29f2:	89 85       	ldd	r24, Y+9	; 0x09
    29f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    29f6:	20 e0       	ldi	r18, 0x00	; 0
    29f8:	30 e0       	ldi	r19, 0x00	; 0
    29fa:	40 e8       	ldi	r20, 0x80	; 128
    29fc:	5f e3       	ldi	r21, 0x3F	; 63
    29fe:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2a02:	88 23       	and	r24, r24
    2a04:	2c f4       	brge	.+10     	; 0x2a10 <CLCD_vidSendData+0x37a>
		__ticks = 1;
    2a06:	81 e0       	ldi	r24, 0x01	; 1
    2a08:	90 e0       	ldi	r25, 0x00	; 0
    2a0a:	9e 83       	std	Y+6, r25	; 0x06
    2a0c:	8d 83       	std	Y+5, r24	; 0x05
    2a0e:	3f c0       	rjmp	.+126    	; 0x2a8e <CLCD_vidSendData+0x3f8>
	else if (__tmp > 65535)
    2a10:	6f 81       	ldd	r22, Y+7	; 0x07
    2a12:	78 85       	ldd	r23, Y+8	; 0x08
    2a14:	89 85       	ldd	r24, Y+9	; 0x09
    2a16:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a18:	20 e0       	ldi	r18, 0x00	; 0
    2a1a:	3f ef       	ldi	r19, 0xFF	; 255
    2a1c:	4f e7       	ldi	r20, 0x7F	; 127
    2a1e:	57 e4       	ldi	r21, 0x47	; 71
    2a20:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2a24:	18 16       	cp	r1, r24
    2a26:	4c f5       	brge	.+82     	; 0x2a7a <CLCD_vidSendData+0x3e4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2a28:	6b 85       	ldd	r22, Y+11	; 0x0b
    2a2a:	7c 85       	ldd	r23, Y+12	; 0x0c
    2a2c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a2e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a30:	20 e0       	ldi	r18, 0x00	; 0
    2a32:	30 e0       	ldi	r19, 0x00	; 0
    2a34:	40 e2       	ldi	r20, 0x20	; 32
    2a36:	51 e4       	ldi	r21, 0x41	; 65
    2a38:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2a3c:	dc 01       	movw	r26, r24
    2a3e:	cb 01       	movw	r24, r22
    2a40:	bc 01       	movw	r22, r24
    2a42:	cd 01       	movw	r24, r26
    2a44:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a48:	dc 01       	movw	r26, r24
    2a4a:	cb 01       	movw	r24, r22
    2a4c:	9e 83       	std	Y+6, r25	; 0x06
    2a4e:	8d 83       	std	Y+5, r24	; 0x05
    2a50:	0f c0       	rjmp	.+30     	; 0x2a70 <CLCD_vidSendData+0x3da>
    2a52:	88 ec       	ldi	r24, 0xC8	; 200
    2a54:	90 e0       	ldi	r25, 0x00	; 0
    2a56:	9c 83       	std	Y+4, r25	; 0x04
    2a58:	8b 83       	std	Y+3, r24	; 0x03
    2a5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a5e:	01 97       	sbiw	r24, 0x01	; 1
    2a60:	f1 f7       	brne	.-4      	; 0x2a5e <CLCD_vidSendData+0x3c8>
    2a62:	9c 83       	std	Y+4, r25	; 0x04
    2a64:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a66:	8d 81       	ldd	r24, Y+5	; 0x05
    2a68:	9e 81       	ldd	r25, Y+6	; 0x06
    2a6a:	01 97       	sbiw	r24, 0x01	; 1
    2a6c:	9e 83       	std	Y+6, r25	; 0x06
    2a6e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a70:	8d 81       	ldd	r24, Y+5	; 0x05
    2a72:	9e 81       	ldd	r25, Y+6	; 0x06
    2a74:	00 97       	sbiw	r24, 0x00	; 0
    2a76:	69 f7       	brne	.-38     	; 0x2a52 <CLCD_vidSendData+0x3bc>
    2a78:	14 c0       	rjmp	.+40     	; 0x2aa2 <CLCD_vidSendData+0x40c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2a7a:	6f 81       	ldd	r22, Y+7	; 0x07
    2a7c:	78 85       	ldd	r23, Y+8	; 0x08
    2a7e:	89 85       	ldd	r24, Y+9	; 0x09
    2a80:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a82:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a86:	dc 01       	movw	r26, r24
    2a88:	cb 01       	movw	r24, r22
    2a8a:	9e 83       	std	Y+6, r25	; 0x06
    2a8c:	8d 83       	std	Y+5, r24	; 0x05
    2a8e:	8d 81       	ldd	r24, Y+5	; 0x05
    2a90:	9e 81       	ldd	r25, Y+6	; 0x06
    2a92:	9a 83       	std	Y+2, r25	; 0x02
    2a94:	89 83       	std	Y+1, r24	; 0x01
    2a96:	89 81       	ldd	r24, Y+1	; 0x01
    2a98:	9a 81       	ldd	r25, Y+2	; 0x02
    2a9a:	01 97       	sbiw	r24, 0x01	; 1
    2a9c:	f1 f7       	brne	.-4      	; 0x2a9a <CLCD_vidSendData+0x404>
    2a9e:	9a 83       	std	Y+2, r25	; 0x02
    2aa0:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
}
    2aa2:	e9 96       	adiw	r28, 0x39	; 57
    2aa4:	0f b6       	in	r0, 0x3f	; 63
    2aa6:	f8 94       	cli
    2aa8:	de bf       	out	0x3e, r29	; 62
    2aaa:	0f be       	out	0x3f, r0	; 63
    2aac:	cd bf       	out	0x3d, r28	; 61
    2aae:	cf 91       	pop	r28
    2ab0:	df 91       	pop	r29
    2ab2:	08 95       	ret

00002ab4 <CLCD_vidInit>:

/*function that initialize LDC to work*/
void CLCD_vidInit(void)
{
    2ab4:	df 93       	push	r29
    2ab6:	cf 93       	push	r28
    2ab8:	cd b7       	in	r28, 0x3d	; 61
    2aba:	de b7       	in	r29, 0x3e	; 62
    2abc:	2e 97       	sbiw	r28, 0x0e	; 14
    2abe:	0f b6       	in	r0, 0x3f	; 63
    2ac0:	f8 94       	cli
    2ac2:	de bf       	out	0x3e, r29	; 62
    2ac4:	0f be       	out	0x3f, r0	; 63
    2ac6:	cd bf       	out	0x3d, r28	; 61
    2ac8:	80 e0       	ldi	r24, 0x00	; 0
    2aca:	90 e0       	ldi	r25, 0x00	; 0
    2acc:	a0 e2       	ldi	r26, 0x20	; 32
    2ace:	b2 e4       	ldi	r27, 0x42	; 66
    2ad0:	8b 87       	std	Y+11, r24	; 0x0b
    2ad2:	9c 87       	std	Y+12, r25	; 0x0c
    2ad4:	ad 87       	std	Y+13, r26	; 0x0d
    2ad6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2ad8:	6b 85       	ldd	r22, Y+11	; 0x0b
    2ada:	7c 85       	ldd	r23, Y+12	; 0x0c
    2adc:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ade:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ae0:	20 e0       	ldi	r18, 0x00	; 0
    2ae2:	30 e0       	ldi	r19, 0x00	; 0
    2ae4:	4a ef       	ldi	r20, 0xFA	; 250
    2ae6:	54 e4       	ldi	r21, 0x44	; 68
    2ae8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2aec:	dc 01       	movw	r26, r24
    2aee:	cb 01       	movw	r24, r22
    2af0:	8f 83       	std	Y+7, r24	; 0x07
    2af2:	98 87       	std	Y+8, r25	; 0x08
    2af4:	a9 87       	std	Y+9, r26	; 0x09
    2af6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2af8:	6f 81       	ldd	r22, Y+7	; 0x07
    2afa:	78 85       	ldd	r23, Y+8	; 0x08
    2afc:	89 85       	ldd	r24, Y+9	; 0x09
    2afe:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b00:	20 e0       	ldi	r18, 0x00	; 0
    2b02:	30 e0       	ldi	r19, 0x00	; 0
    2b04:	40 e8       	ldi	r20, 0x80	; 128
    2b06:	5f e3       	ldi	r21, 0x3F	; 63
    2b08:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2b0c:	88 23       	and	r24, r24
    2b0e:	2c f4       	brge	.+10     	; 0x2b1a <CLCD_vidInit+0x66>
		__ticks = 1;
    2b10:	81 e0       	ldi	r24, 0x01	; 1
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	9e 83       	std	Y+6, r25	; 0x06
    2b16:	8d 83       	std	Y+5, r24	; 0x05
    2b18:	3f c0       	rjmp	.+126    	; 0x2b98 <CLCD_vidInit+0xe4>
	else if (__tmp > 65535)
    2b1a:	6f 81       	ldd	r22, Y+7	; 0x07
    2b1c:	78 85       	ldd	r23, Y+8	; 0x08
    2b1e:	89 85       	ldd	r24, Y+9	; 0x09
    2b20:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b22:	20 e0       	ldi	r18, 0x00	; 0
    2b24:	3f ef       	ldi	r19, 0xFF	; 255
    2b26:	4f e7       	ldi	r20, 0x7F	; 127
    2b28:	57 e4       	ldi	r21, 0x47	; 71
    2b2a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2b2e:	18 16       	cp	r1, r24
    2b30:	4c f5       	brge	.+82     	; 0x2b84 <CLCD_vidInit+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2b32:	6b 85       	ldd	r22, Y+11	; 0x0b
    2b34:	7c 85       	ldd	r23, Y+12	; 0x0c
    2b36:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b38:	9e 85       	ldd	r25, Y+14	; 0x0e
    2b3a:	20 e0       	ldi	r18, 0x00	; 0
    2b3c:	30 e0       	ldi	r19, 0x00	; 0
    2b3e:	40 e2       	ldi	r20, 0x20	; 32
    2b40:	51 e4       	ldi	r21, 0x41	; 65
    2b42:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2b46:	dc 01       	movw	r26, r24
    2b48:	cb 01       	movw	r24, r22
    2b4a:	bc 01       	movw	r22, r24
    2b4c:	cd 01       	movw	r24, r26
    2b4e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2b52:	dc 01       	movw	r26, r24
    2b54:	cb 01       	movw	r24, r22
    2b56:	9e 83       	std	Y+6, r25	; 0x06
    2b58:	8d 83       	std	Y+5, r24	; 0x05
    2b5a:	0f c0       	rjmp	.+30     	; 0x2b7a <CLCD_vidInit+0xc6>
    2b5c:	88 ec       	ldi	r24, 0xC8	; 200
    2b5e:	90 e0       	ldi	r25, 0x00	; 0
    2b60:	9c 83       	std	Y+4, r25	; 0x04
    2b62:	8b 83       	std	Y+3, r24	; 0x03
    2b64:	8b 81       	ldd	r24, Y+3	; 0x03
    2b66:	9c 81       	ldd	r25, Y+4	; 0x04
    2b68:	01 97       	sbiw	r24, 0x01	; 1
    2b6a:	f1 f7       	brne	.-4      	; 0x2b68 <CLCD_vidInit+0xb4>
    2b6c:	9c 83       	std	Y+4, r25	; 0x04
    2b6e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2b70:	8d 81       	ldd	r24, Y+5	; 0x05
    2b72:	9e 81       	ldd	r25, Y+6	; 0x06
    2b74:	01 97       	sbiw	r24, 0x01	; 1
    2b76:	9e 83       	std	Y+6, r25	; 0x06
    2b78:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2b7a:	8d 81       	ldd	r24, Y+5	; 0x05
    2b7c:	9e 81       	ldd	r25, Y+6	; 0x06
    2b7e:	00 97       	sbiw	r24, 0x00	; 0
    2b80:	69 f7       	brne	.-38     	; 0x2b5c <CLCD_vidInit+0xa8>
    2b82:	14 c0       	rjmp	.+40     	; 0x2bac <CLCD_vidInit+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2b84:	6f 81       	ldd	r22, Y+7	; 0x07
    2b86:	78 85       	ldd	r23, Y+8	; 0x08
    2b88:	89 85       	ldd	r24, Y+9	; 0x09
    2b8a:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b8c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2b90:	dc 01       	movw	r26, r24
    2b92:	cb 01       	movw	r24, r22
    2b94:	9e 83       	std	Y+6, r25	; 0x06
    2b96:	8d 83       	std	Y+5, r24	; 0x05
    2b98:	8d 81       	ldd	r24, Y+5	; 0x05
    2b9a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b9c:	9a 83       	std	Y+2, r25	; 0x02
    2b9e:	89 83       	std	Y+1, r24	; 0x01
    2ba0:	89 81       	ldd	r24, Y+1	; 0x01
    2ba2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ba4:	01 97       	sbiw	r24, 0x01	; 1
    2ba6:	f1 f7       	brne	.-4      	; 0x2ba4 <CLCD_vidInit+0xf0>
    2ba8:	9a 83       	std	Y+2, r25	; 0x02
    2baa:	89 83       	std	Y+1, r24	; 0x01
	/*wait for more than 30 ms */
	_delay_ms(40);
	CLCD_vidSendCommand(FOUR_BITS_DATA_MODE);
    2bac:	82 e0       	ldi	r24, 0x02	; 2
    2bae:	0e 94 3c 11 	call	0x2278	; 0x2278 <CLCD_vidSendCommand>
	/*function set command 2 lines , 5*8 for font */
	 CLCD_vidSendCommand(TWO_LINE_LCD_Four_BIT_MODE);
    2bb2:	88 e2       	ldi	r24, 0x28	; 40
    2bb4:	0e 94 3c 11 	call	0x2278	; 0x2278 <CLCD_vidSendCommand>
	 
	 /*display on of control : display enable , disable cursor , to blink cursor */
	 CLCD_vidSendCommand(CURSOR_OFF);
    2bb8:	8c e0       	ldi	r24, 0x0C	; 12
    2bba:	0e 94 3c 11 	call	0x2278	; 0x2278 <CLCD_vidSendCommand>
	 
	 /*clear display */
	 CLCD_vidSendCommand(0X01); 
    2bbe:	81 e0       	ldi	r24, 0x01	; 1
    2bc0:	0e 94 3c 11 	call	0x2278	; 0x2278 <CLCD_vidSendCommand>
	 
}
    2bc4:	2e 96       	adiw	r28, 0x0e	; 14
    2bc6:	0f b6       	in	r0, 0x3f	; 63
    2bc8:	f8 94       	cli
    2bca:	de bf       	out	0x3e, r29	; 62
    2bcc:	0f be       	out	0x3f, r0	; 63
    2bce:	cd bf       	out	0x3d, r28	; 61
    2bd0:	cf 91       	pop	r28
    2bd2:	df 91       	pop	r29
    2bd4:	08 95       	ret

00002bd6 <CLCD_vidSednString>:

void CLCD_vidSednString(const char* copy_pcString)
{
    2bd6:	df 93       	push	r29
    2bd8:	cf 93       	push	r28
    2bda:	00 d0       	rcall	.+0      	; 0x2bdc <CLCD_vidSednString+0x6>
    2bdc:	0f 92       	push	r0
    2bde:	cd b7       	in	r28, 0x3d	; 61
    2be0:	de b7       	in	r29, 0x3e	; 62
    2be2:	9b 83       	std	Y+3, r25	; 0x03
    2be4:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8StringCounter= 0 ;
    2be6:	19 82       	std	Y+1, r1	; 0x01
    2be8:	0e c0       	rjmp	.+28     	; 0x2c06 <CLCD_vidSednString+0x30>
	
	while(copy_pcString[Local_u8StringCounter]!='\0')
	{
		CLCD_vidSendData(copy_pcString[Local_u8StringCounter]);
    2bea:	89 81       	ldd	r24, Y+1	; 0x01
    2bec:	28 2f       	mov	r18, r24
    2bee:	30 e0       	ldi	r19, 0x00	; 0
    2bf0:	8a 81       	ldd	r24, Y+2	; 0x02
    2bf2:	9b 81       	ldd	r25, Y+3	; 0x03
    2bf4:	fc 01       	movw	r30, r24
    2bf6:	e2 0f       	add	r30, r18
    2bf8:	f3 1f       	adc	r31, r19
    2bfa:	80 81       	ld	r24, Z
    2bfc:	0e 94 4b 13 	call	0x2696	; 0x2696 <CLCD_vidSendData>
		
		Local_u8StringCounter++;
    2c00:	89 81       	ldd	r24, Y+1	; 0x01
    2c02:	8f 5f       	subi	r24, 0xFF	; 255
    2c04:	89 83       	std	Y+1, r24	; 0x01

void CLCD_vidSednString(const char* copy_pcString)
{
	u8 Local_u8StringCounter= 0 ;
	
	while(copy_pcString[Local_u8StringCounter]!='\0')
    2c06:	89 81       	ldd	r24, Y+1	; 0x01
    2c08:	28 2f       	mov	r18, r24
    2c0a:	30 e0       	ldi	r19, 0x00	; 0
    2c0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c0e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c10:	fc 01       	movw	r30, r24
    2c12:	e2 0f       	add	r30, r18
    2c14:	f3 1f       	adc	r31, r19
    2c16:	80 81       	ld	r24, Z
    2c18:	88 23       	and	r24, r24
    2c1a:	39 f7       	brne	.-50     	; 0x2bea <CLCD_vidSednString+0x14>
		CLCD_vidSendData(copy_pcString[Local_u8StringCounter]);
		
		Local_u8StringCounter++;
	}
	
}
    2c1c:	0f 90       	pop	r0
    2c1e:	0f 90       	pop	r0
    2c20:	0f 90       	pop	r0
    2c22:	cf 91       	pop	r28
    2c24:	df 91       	pop	r29
    2c26:	08 95       	ret

00002c28 <CLCD_vidGoToXY>:

void CLCD_vidGoToXY(u8 copy_u8Xpos , u8 copy_u8Ypos)
{
    2c28:	df 93       	push	r29
    2c2a:	cf 93       	push	r28
    2c2c:	00 d0       	rcall	.+0      	; 0x2c2e <CLCD_vidGoToXY+0x6>
    2c2e:	0f 92       	push	r0
    2c30:	cd b7       	in	r28, 0x3d	; 61
    2c32:	de b7       	in	r29, 0x3e	; 62
    2c34:	8a 83       	std	Y+2, r24	; 0x02
    2c36:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8Adress =0;
    2c38:	19 82       	std	Y+1, r1	; 0x01
	/*if location is on the first line */
	if (copy_u8Xpos== 0 )
    2c3a:	8a 81       	ldd	r24, Y+2	; 0x02
    2c3c:	88 23       	and	r24, r24
    2c3e:	19 f4       	brne	.+6      	; 0x2c46 <CLCD_vidGoToXY+0x1e>
	{
		Local_u8Adress = copy_u8Ypos ;
    2c40:	8b 81       	ldd	r24, Y+3	; 0x03
    2c42:	89 83       	std	Y+1, r24	; 0x01
    2c44:	06 c0       	rjmp	.+12     	; 0x2c52 <CLCD_vidGoToXY+0x2a>
	}
	/*if location is on the second line */
	else if (copy_u8Xpos == 1)
    2c46:	8a 81       	ldd	r24, Y+2	; 0x02
    2c48:	81 30       	cpi	r24, 0x01	; 1
    2c4a:	19 f4       	brne	.+6      	; 0x2c52 <CLCD_vidGoToXY+0x2a>
	{
		Local_u8Adress = copy_u8Ypos+0x40 ;
    2c4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c4e:	80 5c       	subi	r24, 0xC0	; 192
    2c50:	89 83       	std	Y+1, r24	; 0x01
	}
	/*add 128 to set the bit #8 by one because it must in data sheet */
	 CLCD_vidSendCommand(Local_u8Adress+128);
    2c52:	89 81       	ldd	r24, Y+1	; 0x01
    2c54:	80 58       	subi	r24, 0x80	; 128
    2c56:	0e 94 3c 11 	call	0x2278	; 0x2278 <CLCD_vidSendCommand>
	
}
    2c5a:	0f 90       	pop	r0
    2c5c:	0f 90       	pop	r0
    2c5e:	0f 90       	pop	r0
    2c60:	cf 91       	pop	r28
    2c62:	df 91       	pop	r29
    2c64:	08 95       	ret

00002c66 <CLCD_vidWriteSpecialCaracter>:

void CLCD_vidWriteSpecialCaracter(u8* copy_pu8Pattern , u8 copy_u8PatternNumber, u8 copy_u8Xpos , u8 copy_u8Ypos )
{
    2c66:	df 93       	push	r29
    2c68:	cf 93       	push	r28
    2c6a:	cd b7       	in	r28, 0x3d	; 61
    2c6c:	de b7       	in	r29, 0x3e	; 62
    2c6e:	27 97       	sbiw	r28, 0x07	; 7
    2c70:	0f b6       	in	r0, 0x3f	; 63
    2c72:	f8 94       	cli
    2c74:	de bf       	out	0x3e, r29	; 62
    2c76:	0f be       	out	0x3f, r0	; 63
    2c78:	cd bf       	out	0x3d, r28	; 61
    2c7a:	9c 83       	std	Y+4, r25	; 0x04
    2c7c:	8b 83       	std	Y+3, r24	; 0x03
    2c7e:	6d 83       	std	Y+5, r22	; 0x05
    2c80:	4e 83       	std	Y+6, r20	; 0x06
    2c82:	2f 83       	std	Y+7, r18	; 0x07
	// variable to carry CGRAM address
	u8 Local_u8CGRAM_Address = 0 ;
    2c84:	1a 82       	std	Y+2, r1	; 0x02
	u8 Local_u8Counter ;
	
	/*calculate the CGRAM address whose each block is 8 bytes*/
	Local_u8CGRAM_Address = copy_u8PatternNumber * 8 ;
    2c86:	8d 81       	ldd	r24, Y+5	; 0x05
    2c88:	88 2f       	mov	r24, r24
    2c8a:	90 e0       	ldi	r25, 0x00	; 0
    2c8c:	88 0f       	add	r24, r24
    2c8e:	99 1f       	adc	r25, r25
    2c90:	88 0f       	add	r24, r24
    2c92:	99 1f       	adc	r25, r25
    2c94:	88 0f       	add	r24, r24
    2c96:	99 1f       	adc	r25, r25
    2c98:	8a 83       	std	Y+2, r24	; 0x02
	
	/*+64 to make bit number 6 by one to active accessing CGRAM*/
	CLCD_vidSendCommand(Local_u8CGRAM_Address+64);
    2c9a:	8a 81       	ldd	r24, Y+2	; 0x02
    2c9c:	80 5c       	subi	r24, 0xC0	; 192
    2c9e:	0e 94 3c 11 	call	0x2278	; 0x2278 <CLCD_vidSendCommand>
	
	/*storing the needed pattern in CGRAM*/
	for(Local_u8Counter =0 ; Local_u8Counter < 8 ; Local_u8Counter++)
    2ca2:	19 82       	std	Y+1, r1	; 0x01
    2ca4:	0e c0       	rjmp	.+28     	; 0x2cc2 <CLCD_vidWriteSpecialCaracter+0x5c>
	{
		CLCD_vidSendData(copy_pu8Pattern[Local_u8Counter]);
    2ca6:	89 81       	ldd	r24, Y+1	; 0x01
    2ca8:	28 2f       	mov	r18, r24
    2caa:	30 e0       	ldi	r19, 0x00	; 0
    2cac:	8b 81       	ldd	r24, Y+3	; 0x03
    2cae:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb0:	fc 01       	movw	r30, r24
    2cb2:	e2 0f       	add	r30, r18
    2cb4:	f3 1f       	adc	r31, r19
    2cb6:	80 81       	ld	r24, Z
    2cb8:	0e 94 4b 13 	call	0x2696	; 0x2696 <CLCD_vidSendData>
	
	/*+64 to make bit number 6 by one to active accessing CGRAM*/
	CLCD_vidSendCommand(Local_u8CGRAM_Address+64);
	
	/*storing the needed pattern in CGRAM*/
	for(Local_u8Counter =0 ; Local_u8Counter < 8 ; Local_u8Counter++)
    2cbc:	89 81       	ldd	r24, Y+1	; 0x01
    2cbe:	8f 5f       	subi	r24, 0xFF	; 255
    2cc0:	89 83       	std	Y+1, r24	; 0x01
    2cc2:	89 81       	ldd	r24, Y+1	; 0x01
    2cc4:	88 30       	cpi	r24, 0x08	; 8
    2cc6:	78 f3       	brcs	.-34     	; 0x2ca6 <CLCD_vidWriteSpecialCaracter+0x40>
	{
		CLCD_vidSendData(copy_pu8Pattern[Local_u8Counter]);
	}
	
	/*back to DDRAM to display the pattern data on the screen */
	CLCD_vidGoToXY(copy_u8Xpos,copy_u8Ypos);
    2cc8:	8e 81       	ldd	r24, Y+6	; 0x06
    2cca:	6f 81       	ldd	r22, Y+7	; 0x07
    2ccc:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
	
	/*display the pattern written in CGRAM */
	CLCD_vidSendData(copy_u8PatternNumber);
    2cd0:	8d 81       	ldd	r24, Y+5	; 0x05
    2cd2:	0e 94 4b 13 	call	0x2696	; 0x2696 <CLCD_vidSendData>
	
}
    2cd6:	27 96       	adiw	r28, 0x07	; 7
    2cd8:	0f b6       	in	r0, 0x3f	; 63
    2cda:	f8 94       	cli
    2cdc:	de bf       	out	0x3e, r29	; 62
    2cde:	0f be       	out	0x3f, r0	; 63
    2ce0:	cd bf       	out	0x3d, r28	; 61
    2ce2:	cf 91       	pop	r28
    2ce4:	df 91       	pop	r29
    2ce6:	08 95       	ret

00002ce8 <CLCD_vidSendLargeNmber>:
// 		Local_u32Reserved/=10;
// 	} while (Local_u32Reserved!=1);
// }

void CLCD_vidSendLargeNmber(u32 Copy_u32Num)
{
    2ce8:	ef 92       	push	r14
    2cea:	ff 92       	push	r15
    2cec:	0f 93       	push	r16
    2cee:	1f 93       	push	r17
    2cf0:	df 93       	push	r29
    2cf2:	cf 93       	push	r28
    2cf4:	cd b7       	in	r28, 0x3d	; 61
    2cf6:	de b7       	in	r29, 0x3e	; 62
    2cf8:	61 97       	sbiw	r28, 0x11	; 17
    2cfa:	0f b6       	in	r0, 0x3f	; 63
    2cfc:	f8 94       	cli
    2cfe:	de bf       	out	0x3e, r29	; 62
    2d00:	0f be       	out	0x3f, r0	; 63
    2d02:	cd bf       	out	0x3d, r28	; 61
    2d04:	6e 87       	std	Y+14, r22	; 0x0e
    2d06:	7f 87       	std	Y+15, r23	; 0x0f
    2d08:	88 8b       	std	Y+16, r24	; 0x10
    2d0a:	99 8b       	std	Y+17, r25	; 0x11
	u32 Revers_num = 0;
    2d0c:	1a 86       	std	Y+10, r1	; 0x0a
    2d0e:	1b 86       	std	Y+11, r1	; 0x0b
    2d10:	1c 86       	std	Y+12, r1	; 0x0c
    2d12:	1d 86       	std	Y+13, r1	; 0x0d
	u8 displayed_num = 0;
    2d14:	19 86       	std	Y+9, r1	; 0x09
	u32 multiplier = 1, i = 0;
    2d16:	81 e0       	ldi	r24, 0x01	; 1
    2d18:	90 e0       	ldi	r25, 0x00	; 0
    2d1a:	a0 e0       	ldi	r26, 0x00	; 0
    2d1c:	b0 e0       	ldi	r27, 0x00	; 0
    2d1e:	8d 83       	std	Y+5, r24	; 0x05
    2d20:	9e 83       	std	Y+6, r25	; 0x06
    2d22:	af 83       	std	Y+7, r26	; 0x07
    2d24:	b8 87       	std	Y+8, r27	; 0x08
    2d26:	19 82       	std	Y+1, r1	; 0x01
    2d28:	1a 82       	std	Y+2, r1	; 0x02
    2d2a:	1b 82       	std	Y+3, r1	; 0x03
    2d2c:	1c 82       	std	Y+4, r1	; 0x04
	if(Copy_u32Num == 0)
    2d2e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2d30:	9f 85       	ldd	r25, Y+15	; 0x0f
    2d32:	a8 89       	ldd	r26, Y+16	; 0x10
    2d34:	b9 89       	ldd	r27, Y+17	; 0x11
    2d36:	00 97       	sbiw	r24, 0x00	; 0
    2d38:	a1 05       	cpc	r26, r1
    2d3a:	b1 05       	cpc	r27, r1
    2d3c:	09 f0       	breq	.+2      	; 0x2d40 <CLCD_vidSendLargeNmber+0x58>
    2d3e:	54 c0       	rjmp	.+168    	; 0x2de8 <CLCD_vidSendLargeNmber+0x100>
	{
		CLCD_vidSendData('0');
    2d40:	80 e3       	ldi	r24, 0x30	; 48
    2d42:	0e 94 4b 13 	call	0x2696	; 0x2696 <CLCD_vidSendData>
    2d46:	50 c0       	rjmp	.+160    	; 0x2de8 <CLCD_vidSendLargeNmber+0x100>
		Copy_u32Num *= -1;
	}
	
	while (Copy_u32Num != 0)
	{
		Revers_num = (Revers_num * 10) + Copy_u32Num % 10;
    2d48:	8a 85       	ldd	r24, Y+10	; 0x0a
    2d4a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2d4c:	ac 85       	ldd	r26, Y+12	; 0x0c
    2d4e:	bd 85       	ldd	r27, Y+13	; 0x0d
    2d50:	2a e0       	ldi	r18, 0x0A	; 10
    2d52:	30 e0       	ldi	r19, 0x00	; 0
    2d54:	40 e0       	ldi	r20, 0x00	; 0
    2d56:	50 e0       	ldi	r21, 0x00	; 0
    2d58:	bc 01       	movw	r22, r24
    2d5a:	cd 01       	movw	r24, r26
    2d5c:	0e 94 34 21 	call	0x4268	; 0x4268 <__mulsi3>
    2d60:	7b 01       	movw	r14, r22
    2d62:	8c 01       	movw	r16, r24
    2d64:	8e 85       	ldd	r24, Y+14	; 0x0e
    2d66:	9f 85       	ldd	r25, Y+15	; 0x0f
    2d68:	a8 89       	ldd	r26, Y+16	; 0x10
    2d6a:	b9 89       	ldd	r27, Y+17	; 0x11
    2d6c:	2a e0       	ldi	r18, 0x0A	; 10
    2d6e:	30 e0       	ldi	r19, 0x00	; 0
    2d70:	40 e0       	ldi	r20, 0x00	; 0
    2d72:	50 e0       	ldi	r21, 0x00	; 0
    2d74:	bc 01       	movw	r22, r24
    2d76:	cd 01       	movw	r24, r26
    2d78:	0e 94 67 21 	call	0x42ce	; 0x42ce <__udivmodsi4>
    2d7c:	dc 01       	movw	r26, r24
    2d7e:	cb 01       	movw	r24, r22
    2d80:	8e 0d       	add	r24, r14
    2d82:	9f 1d       	adc	r25, r15
    2d84:	a0 1f       	adc	r26, r16
    2d86:	b1 1f       	adc	r27, r17
    2d88:	8a 87       	std	Y+10, r24	; 0x0a
    2d8a:	9b 87       	std	Y+11, r25	; 0x0b
    2d8c:	ac 87       	std	Y+12, r26	; 0x0c
    2d8e:	bd 87       	std	Y+13, r27	; 0x0d
		if (Revers_num == 0)
    2d90:	8a 85       	ldd	r24, Y+10	; 0x0a
    2d92:	9b 85       	ldd	r25, Y+11	; 0x0b
    2d94:	ac 85       	ldd	r26, Y+12	; 0x0c
    2d96:	bd 85       	ldd	r27, Y+13	; 0x0d
    2d98:	00 97       	sbiw	r24, 0x00	; 0
    2d9a:	a1 05       	cpc	r26, r1
    2d9c:	b1 05       	cpc	r27, r1
    2d9e:	91 f4       	brne	.+36     	; 0x2dc4 <CLCD_vidSendLargeNmber+0xdc>
		multiplier *= 10;
    2da0:	8d 81       	ldd	r24, Y+5	; 0x05
    2da2:	9e 81       	ldd	r25, Y+6	; 0x06
    2da4:	af 81       	ldd	r26, Y+7	; 0x07
    2da6:	b8 85       	ldd	r27, Y+8	; 0x08
    2da8:	2a e0       	ldi	r18, 0x0A	; 10
    2daa:	30 e0       	ldi	r19, 0x00	; 0
    2dac:	40 e0       	ldi	r20, 0x00	; 0
    2dae:	50 e0       	ldi	r21, 0x00	; 0
    2db0:	bc 01       	movw	r22, r24
    2db2:	cd 01       	movw	r24, r26
    2db4:	0e 94 34 21 	call	0x4268	; 0x4268 <__mulsi3>
    2db8:	dc 01       	movw	r26, r24
    2dba:	cb 01       	movw	r24, r22
    2dbc:	8d 83       	std	Y+5, r24	; 0x05
    2dbe:	9e 83       	std	Y+6, r25	; 0x06
    2dc0:	af 83       	std	Y+7, r26	; 0x07
    2dc2:	b8 87       	std	Y+8, r27	; 0x08
		Copy_u32Num /= 10;
    2dc4:	8e 85       	ldd	r24, Y+14	; 0x0e
    2dc6:	9f 85       	ldd	r25, Y+15	; 0x0f
    2dc8:	a8 89       	ldd	r26, Y+16	; 0x10
    2dca:	b9 89       	ldd	r27, Y+17	; 0x11
    2dcc:	2a e0       	ldi	r18, 0x0A	; 10
    2dce:	30 e0       	ldi	r19, 0x00	; 0
    2dd0:	40 e0       	ldi	r20, 0x00	; 0
    2dd2:	50 e0       	ldi	r21, 0x00	; 0
    2dd4:	bc 01       	movw	r22, r24
    2dd6:	cd 01       	movw	r24, r26
    2dd8:	0e 94 67 21 	call	0x42ce	; 0x42ce <__udivmodsi4>
    2ddc:	da 01       	movw	r26, r20
    2dde:	c9 01       	movw	r24, r18
    2de0:	8e 87       	std	Y+14, r24	; 0x0e
    2de2:	9f 87       	std	Y+15, r25	; 0x0f
    2de4:	a8 8b       	std	Y+16, r26	; 0x10
    2de6:	b9 8b       	std	Y+17, r27	; 0x11
	{
		CLCD_vidSendData('-');
		Copy_u32Num *= -1;
	}
	
	while (Copy_u32Num != 0)
    2de8:	8e 85       	ldd	r24, Y+14	; 0x0e
    2dea:	9f 85       	ldd	r25, Y+15	; 0x0f
    2dec:	a8 89       	ldd	r26, Y+16	; 0x10
    2dee:	b9 89       	ldd	r27, Y+17	; 0x11
    2df0:	00 97       	sbiw	r24, 0x00	; 0
    2df2:	a1 05       	cpc	r26, r1
    2df4:	b1 05       	cpc	r27, r1
    2df6:	09 f0       	breq	.+2      	; 0x2dfa <CLCD_vidSendLargeNmber+0x112>
    2df8:	a7 cf       	rjmp	.-178    	; 0x2d48 <CLCD_vidSendLargeNmber+0x60>
    2dfa:	46 c0       	rjmp	.+140    	; 0x2e88 <CLCD_vidSendLargeNmber+0x1a0>
		multiplier *= 10;
		Copy_u32Num /= 10;
	}
	while (Revers_num != i)
	{
		displayed_num = Revers_num % 10;
    2dfc:	8a 85       	ldd	r24, Y+10	; 0x0a
    2dfe:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e00:	ac 85       	ldd	r26, Y+12	; 0x0c
    2e02:	bd 85       	ldd	r27, Y+13	; 0x0d
    2e04:	2a e0       	ldi	r18, 0x0A	; 10
    2e06:	30 e0       	ldi	r19, 0x00	; 0
    2e08:	40 e0       	ldi	r20, 0x00	; 0
    2e0a:	50 e0       	ldi	r21, 0x00	; 0
    2e0c:	bc 01       	movw	r22, r24
    2e0e:	cd 01       	movw	r24, r26
    2e10:	0e 94 67 21 	call	0x42ce	; 0x42ce <__udivmodsi4>
    2e14:	dc 01       	movw	r26, r24
    2e16:	cb 01       	movw	r24, r22
    2e18:	89 87       	std	Y+9, r24	; 0x09
		CLCD_vidSendData(displayed_num + 48);   //48 -> '0'
    2e1a:	89 85       	ldd	r24, Y+9	; 0x09
    2e1c:	80 5d       	subi	r24, 0xD0	; 208
    2e1e:	0e 94 4b 13 	call	0x2696	; 0x2696 <CLCD_vidSendData>
		Revers_num/=10;
    2e22:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e24:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e26:	ac 85       	ldd	r26, Y+12	; 0x0c
    2e28:	bd 85       	ldd	r27, Y+13	; 0x0d
    2e2a:	2a e0       	ldi	r18, 0x0A	; 10
    2e2c:	30 e0       	ldi	r19, 0x00	; 0
    2e2e:	40 e0       	ldi	r20, 0x00	; 0
    2e30:	50 e0       	ldi	r21, 0x00	; 0
    2e32:	bc 01       	movw	r22, r24
    2e34:	cd 01       	movw	r24, r26
    2e36:	0e 94 67 21 	call	0x42ce	; 0x42ce <__udivmodsi4>
    2e3a:	da 01       	movw	r26, r20
    2e3c:	c9 01       	movw	r24, r18
    2e3e:	8a 87       	std	Y+10, r24	; 0x0a
    2e40:	9b 87       	std	Y+11, r25	; 0x0b
    2e42:	ac 87       	std	Y+12, r26	; 0x0c
    2e44:	bd 87       	std	Y+13, r27	; 0x0d
		if (Revers_num == 0 && multiplier >= 10)
    2e46:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e48:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e4a:	ac 85       	ldd	r26, Y+12	; 0x0c
    2e4c:	bd 85       	ldd	r27, Y+13	; 0x0d
    2e4e:	00 97       	sbiw	r24, 0x00	; 0
    2e50:	a1 05       	cpc	r26, r1
    2e52:	b1 05       	cpc	r27, r1
    2e54:	c9 f4       	brne	.+50     	; 0x2e88 <CLCD_vidSendLargeNmber+0x1a0>
    2e56:	8d 81       	ldd	r24, Y+5	; 0x05
    2e58:	9e 81       	ldd	r25, Y+6	; 0x06
    2e5a:	af 81       	ldd	r26, Y+7	; 0x07
    2e5c:	b8 85       	ldd	r27, Y+8	; 0x08
    2e5e:	8a 30       	cpi	r24, 0x0A	; 10
    2e60:	91 05       	cpc	r25, r1
    2e62:	a1 05       	cpc	r26, r1
    2e64:	b1 05       	cpc	r27, r1
    2e66:	80 f0       	brcs	.+32     	; 0x2e88 <CLCD_vidSendLargeNmber+0x1a0>
		{
			i = 1;
    2e68:	81 e0       	ldi	r24, 0x01	; 1
    2e6a:	90 e0       	ldi	r25, 0x00	; 0
    2e6c:	a0 e0       	ldi	r26, 0x00	; 0
    2e6e:	b0 e0       	ldi	r27, 0x00	; 0
    2e70:	89 83       	std	Y+1, r24	; 0x01
    2e72:	9a 83       	std	Y+2, r25	; 0x02
    2e74:	ab 83       	std	Y+3, r26	; 0x03
    2e76:	bc 83       	std	Y+4, r27	; 0x04
			Revers_num = multiplier;
    2e78:	8d 81       	ldd	r24, Y+5	; 0x05
    2e7a:	9e 81       	ldd	r25, Y+6	; 0x06
    2e7c:	af 81       	ldd	r26, Y+7	; 0x07
    2e7e:	b8 85       	ldd	r27, Y+8	; 0x08
    2e80:	8a 87       	std	Y+10, r24	; 0x0a
    2e82:	9b 87       	std	Y+11, r25	; 0x0b
    2e84:	ac 87       	std	Y+12, r26	; 0x0c
    2e86:	bd 87       	std	Y+13, r27	; 0x0d
		Revers_num = (Revers_num * 10) + Copy_u32Num % 10;
		if (Revers_num == 0)
		multiplier *= 10;
		Copy_u32Num /= 10;
	}
	while (Revers_num != i)
    2e88:	2a 85       	ldd	r18, Y+10	; 0x0a
    2e8a:	3b 85       	ldd	r19, Y+11	; 0x0b
    2e8c:	4c 85       	ldd	r20, Y+12	; 0x0c
    2e8e:	5d 85       	ldd	r21, Y+13	; 0x0d
    2e90:	89 81       	ldd	r24, Y+1	; 0x01
    2e92:	9a 81       	ldd	r25, Y+2	; 0x02
    2e94:	ab 81       	ldd	r26, Y+3	; 0x03
    2e96:	bc 81       	ldd	r27, Y+4	; 0x04
    2e98:	28 17       	cp	r18, r24
    2e9a:	39 07       	cpc	r19, r25
    2e9c:	4a 07       	cpc	r20, r26
    2e9e:	5b 07       	cpc	r21, r27
    2ea0:	09 f0       	breq	.+2      	; 0x2ea4 <CLCD_vidSendLargeNmber+0x1bc>
    2ea2:	ac cf       	rjmp	.-168    	; 0x2dfc <CLCD_vidSendLargeNmber+0x114>
		{
			i = 1;
			Revers_num = multiplier;
		}
	}
}
    2ea4:	61 96       	adiw	r28, 0x11	; 17
    2ea6:	0f b6       	in	r0, 0x3f	; 63
    2ea8:	f8 94       	cli
    2eaa:	de bf       	out	0x3e, r29	; 62
    2eac:	0f be       	out	0x3f, r0	; 63
    2eae:	cd bf       	out	0x3d, r28	; 61
    2eb0:	cf 91       	pop	r28
    2eb2:	df 91       	pop	r29
    2eb4:	1f 91       	pop	r17
    2eb6:	0f 91       	pop	r16
    2eb8:	ff 90       	pop	r15
    2eba:	ef 90       	pop	r14
    2ebc:	08 95       	ret

00002ebe <CLCD_vidClearLcd>:

void CLCD_vidClearLcd(void)
{
    2ebe:	df 93       	push	r29
    2ec0:	cf 93       	push	r28
    2ec2:	cd b7       	in	r28, 0x3d	; 61
    2ec4:	de b7       	in	r29, 0x3e	; 62
	CLCD_vidSendCommand(CLEAR_SCREEN);
    2ec6:	81 e0       	ldi	r24, 0x01	; 1
    2ec8:	0e 94 3c 11 	call	0x2278	; 0x2278 <CLCD_vidSendCommand>
    2ecc:	cf 91       	pop	r28
    2ece:	df 91       	pop	r29
    2ed0:	08 95       	ret

00002ed2 <BUZZER_ON>:
#include "../../MCAL/DIO/DIO_interface.h"

#include "BUZZER.h"

void BUZZER_ON(void)
{
    2ed2:	df 93       	push	r29
    2ed4:	cf 93       	push	r28
    2ed6:	cd b7       	in	r28, 0x3d	; 61
    2ed8:	de b7       	in	r29, 0x3e	; 62
	DIO_u8SetPinValue(BUZEER_PORT,BUZEER_PIN,DIO_u8PIN_HIGH);
    2eda:	80 e0       	ldi	r24, 0x00	; 0
    2edc:	61 e0       	ldi	r22, 0x01	; 1
    2ede:	41 e0       	ldi	r20, 0x01	; 1
    2ee0:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
}
    2ee4:	cf 91       	pop	r28
    2ee6:	df 91       	pop	r29
    2ee8:	08 95       	ret

00002eea <BUZZER_OFF>:
void BUZZER_OFF(void)
{
    2eea:	df 93       	push	r29
    2eec:	cf 93       	push	r28
    2eee:	cd b7       	in	r28, 0x3d	; 61
    2ef0:	de b7       	in	r29, 0x3e	; 62
	DIO_u8SetPinValue(BUZEER_PORT,BUZEER_PIN,DIO_u8PIN_LOW);
    2ef2:	80 e0       	ldi	r24, 0x00	; 0
    2ef4:	61 e0       	ldi	r22, 0x01	; 1
    2ef6:	40 e0       	ldi	r20, 0x00	; 0
    2ef8:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
}
    2efc:	cf 91       	pop	r28
    2efe:	df 91       	pop	r29
    2f00:	08 95       	ret

00002f02 <BUZZER_TOGGLE>:
void BUZZER_TOGGLE(void)
{
    2f02:	df 93       	push	r29
    2f04:	cf 93       	push	r28
    2f06:	cd b7       	in	r28, 0x3d	; 61
    2f08:	de b7       	in	r29, 0x3e	; 62
	DIO_u8TogglePinValue(BUZEER_PORT,BUZEER_PIN);
    2f0a:	80 e0       	ldi	r24, 0x00	; 0
    2f0c:	61 e0       	ldi	r22, 0x01	; 1
    2f0e:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <DIO_u8TogglePinValue>
    2f12:	cf 91       	pop	r28
    2f14:	df 91       	pop	r29
    2f16:	08 95       	ret

00002f18 <TEMP_CTRL_SYSTEM_INIT>:

// volatile u8 TEMP_STORED_HIGH = EEPROM_READ(HIGH_TEMP_u8LOCATION,HIGH_TEMP_u8ADRESS);/*read value of high and low temp from EEPROm*/
//volatile u8 TEMP_STORED_LOW  = EEPROM_READ(BY_PASS_TEMP,LOW_TEMP_u8ADRESS);		 /*read value of high and low temp from EEPROm*/

void TEMP_CTRL_SYSTEM_INIT(void)
{
    2f18:	df 93       	push	r29
    2f1a:	cf 93       	push	r28
    2f1c:	cd b7       	in	r28, 0x3d	; 61
    2f1e:	de b7       	in	r29, 0x3e	; 62
	PORT_vidInit();     //ALL MC PORT INITIALIZE 
    2f20:	0e 94 fb 07 	call	0xff6	; 0xff6 <PORT_vidInit>
	
	CLCD_vidInit();     // initialize LCD
    2f24:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <CLCD_vidInit>
	
	GIE_vidEnable();    // ENABLE GENERAL INTERRUPT 
    2f28:	0e 94 bf 08 	call	0x117e	; 0x117e <GIE_vidEnable>
	 
	TIMER0_vidInit();   // INITIALIZE TIMER0
    2f2c:	0e 94 08 07 	call	0xe10	; 0xe10 <TIMER0_vidInit>
	
	EXTI_vidInt0Init(); // INITIALIZE EXTI0
    2f30:	0e 94 db 08 	call	0x11b6	; 0x11b6 <EXTI_vidInt0Init>
	
	UART_voidInit();    // INITIALIZE UART 
    2f34:	0e 94 d1 05 	call	0xba2	; 0xba2 <UART_voidInit>
	
	ADC_vidInit();      // INITIALIZE ANALOG TO DIGITAL CONVERTER
    2f38:	0e 94 26 0e 	call	0x1c4c	; 0x1c4c <ADC_vidInit>
	
	EXTI_u8Int0SetCallBack(MAIN_MENU_ISR);   // call back function of EXTI0 
    2f3c:	83 ee       	ldi	r24, 0xE3	; 227
    2f3e:	9c e1       	ldi	r25, 0x1C	; 28
    2f40:	0e 94 b0 0a 	call	0x1560	; 0x1560 <EXTI_u8Int0SetCallBack>
	
	
	
	SET_MOTOR_SPEED(MOTOR_STOP);             // start first time with motor stop
    2f44:	80 e0       	ldi	r24, 0x00	; 0
    2f46:	0e 94 bc 19 	call	0x3378	; 0x3378 <SET_MOTOR_SPEED>
	LED_u8SetLedOff(LED_PORT,LED_HIGH);      // start first time with status led off 
    2f4a:	81 e0       	ldi	r24, 0x01	; 1
    2f4c:	66 e0       	ldi	r22, 0x06	; 6
    2f4e:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <LED_u8SetLedOff>
	LED_u8SetLedOff(LED_PORT,LED_NORMAL);	 // start first time with status led off 
    2f52:	81 e0       	ldi	r24, 0x01	; 1
    2f54:	65 e0       	ldi	r22, 0x05	; 5
    2f56:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <LED_u8SetLedOff>
	LED_u8SetLedOff(LED_PORT,LED_LOW);		 // start first time with status led off 
    2f5a:	81 e0       	ldi	r24, 0x01	; 1
    2f5c:	64 e0       	ldi	r22, 0x04	; 4
    2f5e:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <LED_u8SetLedOff>
	BUZZER_OFF();							 // start first time BUZZER stop
    2f62:	0e 94 75 17 	call	0x2eea	; 0x2eea <BUZZER_OFF>
}
    2f66:	cf 91       	pop	r28
    2f68:	df 91       	pop	r29
    2f6a:	08 95       	ret

00002f6c <START_MASSAGE>:

void START_MASSAGE(void)
{
    2f6c:	df 93       	push	r29
    2f6e:	cf 93       	push	r28
    2f70:	cd b7       	in	r28, 0x3d	; 61
    2f72:	de b7       	in	r29, 0x3e	; 62
    2f74:	6c 97       	sbiw	r28, 0x1c	; 28
    2f76:	0f b6       	in	r0, 0x3f	; 63
    2f78:	f8 94       	cli
    2f7a:	de bf       	out	0x3e, r29	; 62
    2f7c:	0f be       	out	0x3f, r0	; 63
    2f7e:	cd bf       	out	0x3d, r28	; 61
	
	/*send start massage with UART*/
	UART_voidSendString("IMT_AVR_PROJECTI");
    2f80:	80 e6       	ldi	r24, 0x60	; 96
    2f82:	90 e0       	ldi	r25, 0x00	; 0
    2f84:	0e 94 45 06 	call	0xc8a	; 0xc8a <UART_voidSendString>
	UART_voidWriteNewLine(); 
    2f88:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_voidWriteNewLine>
	UART_voidSendString("TEMPERATURE CONTROL SYSTEM ");
    2f8c:	81 e7       	ldi	r24, 0x71	; 113
    2f8e:	90 e0       	ldi	r25, 0x00	; 0
    2f90:	0e 94 45 06 	call	0xc8a	; 0xc8a <UART_voidSendString>
	UART_voidWriteNewLine();
    2f94:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_voidWriteNewLine>

	CLCD_vidClearLcd(); 
    2f98:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
	CLCD_vidGoToXY(0,2); 
    2f9c:	80 e0       	ldi	r24, 0x00	; 0
    2f9e:	62 e0       	ldi	r22, 0x02	; 2
    2fa0:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
	CLCD_vidSednString("IMT_AVR_PROJECT");
    2fa4:	8d e8       	ldi	r24, 0x8D	; 141
    2fa6:	90 e0       	ldi	r25, 0x00	; 0
    2fa8:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
	CLCD_vidGoToXY(1,2);  
    2fac:	81 e0       	ldi	r24, 0x01	; 1
    2fae:	62 e0       	ldi	r22, 0x02	; 2
    2fb0:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
	CLCD_vidSednString("Abdlrhman Nasr");
    2fb4:	8d e9       	ldi	r24, 0x9D	; 157
    2fb6:	90 e0       	ldi	r25, 0x00	; 0
    2fb8:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
    2fbc:	80 e0       	ldi	r24, 0x00	; 0
    2fbe:	90 e0       	ldi	r25, 0x00	; 0
    2fc0:	a6 e9       	ldi	r26, 0x96	; 150
    2fc2:	b3 e4       	ldi	r27, 0x43	; 67
    2fc4:	89 8f       	std	Y+25, r24	; 0x19
    2fc6:	9a 8f       	std	Y+26, r25	; 0x1a
    2fc8:	ab 8f       	std	Y+27, r26	; 0x1b
    2fca:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2fcc:	69 8d       	ldd	r22, Y+25	; 0x19
    2fce:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2fd0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2fd2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2fd4:	20 e0       	ldi	r18, 0x00	; 0
    2fd6:	30 e0       	ldi	r19, 0x00	; 0
    2fd8:	48 e4       	ldi	r20, 0x48	; 72
    2fda:	53 e4       	ldi	r21, 0x43	; 67
    2fdc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2fe0:	dc 01       	movw	r26, r24
    2fe2:	cb 01       	movw	r24, r22
    2fe4:	8d 8b       	std	Y+21, r24	; 0x15
    2fe6:	9e 8b       	std	Y+22, r25	; 0x16
    2fe8:	af 8b       	std	Y+23, r26	; 0x17
    2fea:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2fec:	6d 89       	ldd	r22, Y+21	; 0x15
    2fee:	7e 89       	ldd	r23, Y+22	; 0x16
    2ff0:	8f 89       	ldd	r24, Y+23	; 0x17
    2ff2:	98 8d       	ldd	r25, Y+24	; 0x18
    2ff4:	20 e0       	ldi	r18, 0x00	; 0
    2ff6:	30 e0       	ldi	r19, 0x00	; 0
    2ff8:	40 e8       	ldi	r20, 0x80	; 128
    2ffa:	5f e3       	ldi	r21, 0x3F	; 63
    2ffc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3000:	88 23       	and	r24, r24
    3002:	2c f4       	brge	.+10     	; 0x300e <START_MASSAGE+0xa2>
		__ticks = 1;
    3004:	81 e0       	ldi	r24, 0x01	; 1
    3006:	90 e0       	ldi	r25, 0x00	; 0
    3008:	9c 8b       	std	Y+20, r25	; 0x14
    300a:	8b 8b       	std	Y+19, r24	; 0x13
    300c:	3f c0       	rjmp	.+126    	; 0x308c <START_MASSAGE+0x120>
	else if (__tmp > 65535)
    300e:	6d 89       	ldd	r22, Y+21	; 0x15
    3010:	7e 89       	ldd	r23, Y+22	; 0x16
    3012:	8f 89       	ldd	r24, Y+23	; 0x17
    3014:	98 8d       	ldd	r25, Y+24	; 0x18
    3016:	20 e0       	ldi	r18, 0x00	; 0
    3018:	3f ef       	ldi	r19, 0xFF	; 255
    301a:	4f e7       	ldi	r20, 0x7F	; 127
    301c:	57 e4       	ldi	r21, 0x47	; 71
    301e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3022:	18 16       	cp	r1, r24
    3024:	4c f5       	brge	.+82     	; 0x3078 <START_MASSAGE+0x10c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3026:	69 8d       	ldd	r22, Y+25	; 0x19
    3028:	7a 8d       	ldd	r23, Y+26	; 0x1a
    302a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    302c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    302e:	20 e0       	ldi	r18, 0x00	; 0
    3030:	30 e0       	ldi	r19, 0x00	; 0
    3032:	40 e2       	ldi	r20, 0x20	; 32
    3034:	51 e4       	ldi	r21, 0x41	; 65
    3036:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    303a:	dc 01       	movw	r26, r24
    303c:	cb 01       	movw	r24, r22
    303e:	bc 01       	movw	r22, r24
    3040:	cd 01       	movw	r24, r26
    3042:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3046:	dc 01       	movw	r26, r24
    3048:	cb 01       	movw	r24, r22
    304a:	9c 8b       	std	Y+20, r25	; 0x14
    304c:	8b 8b       	std	Y+19, r24	; 0x13
    304e:	0f c0       	rjmp	.+30     	; 0x306e <START_MASSAGE+0x102>
    3050:	84 e1       	ldi	r24, 0x14	; 20
    3052:	90 e0       	ldi	r25, 0x00	; 0
    3054:	9a 8b       	std	Y+18, r25	; 0x12
    3056:	89 8b       	std	Y+17, r24	; 0x11
    3058:	89 89       	ldd	r24, Y+17	; 0x11
    305a:	9a 89       	ldd	r25, Y+18	; 0x12
    305c:	01 97       	sbiw	r24, 0x01	; 1
    305e:	f1 f7       	brne	.-4      	; 0x305c <START_MASSAGE+0xf0>
    3060:	9a 8b       	std	Y+18, r25	; 0x12
    3062:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3064:	8b 89       	ldd	r24, Y+19	; 0x13
    3066:	9c 89       	ldd	r25, Y+20	; 0x14
    3068:	01 97       	sbiw	r24, 0x01	; 1
    306a:	9c 8b       	std	Y+20, r25	; 0x14
    306c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    306e:	8b 89       	ldd	r24, Y+19	; 0x13
    3070:	9c 89       	ldd	r25, Y+20	; 0x14
    3072:	00 97       	sbiw	r24, 0x00	; 0
    3074:	69 f7       	brne	.-38     	; 0x3050 <START_MASSAGE+0xe4>
    3076:	14 c0       	rjmp	.+40     	; 0x30a0 <START_MASSAGE+0x134>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3078:	6d 89       	ldd	r22, Y+21	; 0x15
    307a:	7e 89       	ldd	r23, Y+22	; 0x16
    307c:	8f 89       	ldd	r24, Y+23	; 0x17
    307e:	98 8d       	ldd	r25, Y+24	; 0x18
    3080:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3084:	dc 01       	movw	r26, r24
    3086:	cb 01       	movw	r24, r22
    3088:	9c 8b       	std	Y+20, r25	; 0x14
    308a:	8b 8b       	std	Y+19, r24	; 0x13
    308c:	8b 89       	ldd	r24, Y+19	; 0x13
    308e:	9c 89       	ldd	r25, Y+20	; 0x14
    3090:	98 8b       	std	Y+16, r25	; 0x10
    3092:	8f 87       	std	Y+15, r24	; 0x0f
    3094:	8f 85       	ldd	r24, Y+15	; 0x0f
    3096:	98 89       	ldd	r25, Y+16	; 0x10
    3098:	01 97       	sbiw	r24, 0x01	; 1
    309a:	f1 f7       	brne	.-4      	; 0x3098 <START_MASSAGE+0x12c>
    309c:	98 8b       	std	Y+16, r25	; 0x10
    309e:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(300);
	CLCD_vidClearLcd();
    30a0:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
	CLCD_vidGoToXY(0,2); 
    30a4:	80 e0       	ldi	r24, 0x00	; 0
    30a6:	62 e0       	ldi	r22, 0x02	; 2
    30a8:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
	CLCD_vidSednString("TEMP_CTRL_SYSTEM");
    30ac:	8c ea       	ldi	r24, 0xAC	; 172
    30ae:	90 e0       	ldi	r25, 0x00	; 0
    30b0:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
    30b4:	80 e0       	ldi	r24, 0x00	; 0
    30b6:	90 e0       	ldi	r25, 0x00	; 0
    30b8:	a6 e9       	ldi	r26, 0x96	; 150
    30ba:	b3 e4       	ldi	r27, 0x43	; 67
    30bc:	8b 87       	std	Y+11, r24	; 0x0b
    30be:	9c 87       	std	Y+12, r25	; 0x0c
    30c0:	ad 87       	std	Y+13, r26	; 0x0d
    30c2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    30c4:	6b 85       	ldd	r22, Y+11	; 0x0b
    30c6:	7c 85       	ldd	r23, Y+12	; 0x0c
    30c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    30ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    30cc:	20 e0       	ldi	r18, 0x00	; 0
    30ce:	30 e0       	ldi	r19, 0x00	; 0
    30d0:	48 e4       	ldi	r20, 0x48	; 72
    30d2:	53 e4       	ldi	r21, 0x43	; 67
    30d4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    30d8:	dc 01       	movw	r26, r24
    30da:	cb 01       	movw	r24, r22
    30dc:	8f 83       	std	Y+7, r24	; 0x07
    30de:	98 87       	std	Y+8, r25	; 0x08
    30e0:	a9 87       	std	Y+9, r26	; 0x09
    30e2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    30e4:	6f 81       	ldd	r22, Y+7	; 0x07
    30e6:	78 85       	ldd	r23, Y+8	; 0x08
    30e8:	89 85       	ldd	r24, Y+9	; 0x09
    30ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    30ec:	20 e0       	ldi	r18, 0x00	; 0
    30ee:	30 e0       	ldi	r19, 0x00	; 0
    30f0:	40 e8       	ldi	r20, 0x80	; 128
    30f2:	5f e3       	ldi	r21, 0x3F	; 63
    30f4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    30f8:	88 23       	and	r24, r24
    30fa:	2c f4       	brge	.+10     	; 0x3106 <START_MASSAGE+0x19a>
		__ticks = 1;
    30fc:	81 e0       	ldi	r24, 0x01	; 1
    30fe:	90 e0       	ldi	r25, 0x00	; 0
    3100:	9e 83       	std	Y+6, r25	; 0x06
    3102:	8d 83       	std	Y+5, r24	; 0x05
    3104:	3f c0       	rjmp	.+126    	; 0x3184 <START_MASSAGE+0x218>
	else if (__tmp > 65535)
    3106:	6f 81       	ldd	r22, Y+7	; 0x07
    3108:	78 85       	ldd	r23, Y+8	; 0x08
    310a:	89 85       	ldd	r24, Y+9	; 0x09
    310c:	9a 85       	ldd	r25, Y+10	; 0x0a
    310e:	20 e0       	ldi	r18, 0x00	; 0
    3110:	3f ef       	ldi	r19, 0xFF	; 255
    3112:	4f e7       	ldi	r20, 0x7F	; 127
    3114:	57 e4       	ldi	r21, 0x47	; 71
    3116:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    311a:	18 16       	cp	r1, r24
    311c:	4c f5       	brge	.+82     	; 0x3170 <START_MASSAGE+0x204>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    311e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3120:	7c 85       	ldd	r23, Y+12	; 0x0c
    3122:	8d 85       	ldd	r24, Y+13	; 0x0d
    3124:	9e 85       	ldd	r25, Y+14	; 0x0e
    3126:	20 e0       	ldi	r18, 0x00	; 0
    3128:	30 e0       	ldi	r19, 0x00	; 0
    312a:	40 e2       	ldi	r20, 0x20	; 32
    312c:	51 e4       	ldi	r21, 0x41	; 65
    312e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3132:	dc 01       	movw	r26, r24
    3134:	cb 01       	movw	r24, r22
    3136:	bc 01       	movw	r22, r24
    3138:	cd 01       	movw	r24, r26
    313a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    313e:	dc 01       	movw	r26, r24
    3140:	cb 01       	movw	r24, r22
    3142:	9e 83       	std	Y+6, r25	; 0x06
    3144:	8d 83       	std	Y+5, r24	; 0x05
    3146:	0f c0       	rjmp	.+30     	; 0x3166 <START_MASSAGE+0x1fa>
    3148:	84 e1       	ldi	r24, 0x14	; 20
    314a:	90 e0       	ldi	r25, 0x00	; 0
    314c:	9c 83       	std	Y+4, r25	; 0x04
    314e:	8b 83       	std	Y+3, r24	; 0x03
    3150:	8b 81       	ldd	r24, Y+3	; 0x03
    3152:	9c 81       	ldd	r25, Y+4	; 0x04
    3154:	01 97       	sbiw	r24, 0x01	; 1
    3156:	f1 f7       	brne	.-4      	; 0x3154 <START_MASSAGE+0x1e8>
    3158:	9c 83       	std	Y+4, r25	; 0x04
    315a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    315c:	8d 81       	ldd	r24, Y+5	; 0x05
    315e:	9e 81       	ldd	r25, Y+6	; 0x06
    3160:	01 97       	sbiw	r24, 0x01	; 1
    3162:	9e 83       	std	Y+6, r25	; 0x06
    3164:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3166:	8d 81       	ldd	r24, Y+5	; 0x05
    3168:	9e 81       	ldd	r25, Y+6	; 0x06
    316a:	00 97       	sbiw	r24, 0x00	; 0
    316c:	69 f7       	brne	.-38     	; 0x3148 <START_MASSAGE+0x1dc>
    316e:	14 c0       	rjmp	.+40     	; 0x3198 <START_MASSAGE+0x22c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3170:	6f 81       	ldd	r22, Y+7	; 0x07
    3172:	78 85       	ldd	r23, Y+8	; 0x08
    3174:	89 85       	ldd	r24, Y+9	; 0x09
    3176:	9a 85       	ldd	r25, Y+10	; 0x0a
    3178:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    317c:	dc 01       	movw	r26, r24
    317e:	cb 01       	movw	r24, r22
    3180:	9e 83       	std	Y+6, r25	; 0x06
    3182:	8d 83       	std	Y+5, r24	; 0x05
    3184:	8d 81       	ldd	r24, Y+5	; 0x05
    3186:	9e 81       	ldd	r25, Y+6	; 0x06
    3188:	9a 83       	std	Y+2, r25	; 0x02
    318a:	89 83       	std	Y+1, r24	; 0x01
    318c:	89 81       	ldd	r24, Y+1	; 0x01
    318e:	9a 81       	ldd	r25, Y+2	; 0x02
    3190:	01 97       	sbiw	r24, 0x01	; 1
    3192:	f1 f7       	brne	.-4      	; 0x3190 <START_MASSAGE+0x224>
    3194:	9a 83       	std	Y+2, r25	; 0x02
    3196:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(300);
	CLCD_vidClearLcd(); 
    3198:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
}
    319c:	6c 96       	adiw	r28, 0x1c	; 28
    319e:	0f b6       	in	r0, 0x3f	; 63
    31a0:	f8 94       	cli
    31a2:	de bf       	out	0x3e, r29	; 62
    31a4:	0f be       	out	0x3f, r0	; 63
    31a6:	cd bf       	out	0x3d, r28	; 61
    31a8:	cf 91       	pop	r28
    31aa:	df 91       	pop	r29
    31ac:	08 95       	ret

000031ae <MAIN_MENUE>:

void MAIN_MENUE(void)
{
    31ae:	df 93       	push	r29
    31b0:	cf 93       	push	r28
    31b2:	cd b7       	in	r28, 0x3d	; 61
    31b4:	de b7       	in	r29, 0x3e	; 62
    31b6:	2f 97       	sbiw	r28, 0x0f	; 15
    31b8:	0f b6       	in	r0, 0x3f	; 63
    31ba:	f8 94       	cli
    31bc:	de bf       	out	0x3e, r29	; 62
    31be:	0f be       	out	0x3f, r0	; 63
    31c0:	cd bf       	out	0x3d, r28	; 61
	u8 Local_u8Up_Down=0 ; /*local variable to select screen up and down moving*/
    31c2:	1f 86       	std	Y+15, r1	; 0x0f
	CLCD_vidClearLcd();
    31c4:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
		do
		{
			do
			{
				/*wait untill get key from usre */
				CLCD_vidGoToXY(0,0);
    31c8:	80 e0       	ldi	r24, 0x00	; 0
    31ca:	60 e0       	ldi	r22, 0x00	; 0
    31cc:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
				CLCD_vidSednString("1- START");
    31d0:	8d eb       	ldi	r24, 0xBD	; 189
    31d2:	90 e0       	ldi	r25, 0x00	; 0
    31d4:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
				CLCD_vidGoToXY(1,0);
    31d8:	81 e0       	ldi	r24, 0x01	; 1
    31da:	60 e0       	ldi	r22, 0x00	; 0
    31dc:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
				CLCD_vidSednString("2- ENTER_NEW_H&L_TEMP");
    31e0:	86 ec       	ldi	r24, 0xC6	; 198
    31e2:	90 e0       	ldi	r25, 0x00	; 0
    31e4:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
				Local_u8Up_Down=KPD_u8GetPressedKey();
    31e8:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <KPD_u8GetPressedKey>
    31ec:	8f 87       	std	Y+15, r24	; 0x0f
			} while (Local_u8Up_Down==0xff);
    31ee:	8f 85       	ldd	r24, Y+15	; 0x0f
    31f0:	8f 3f       	cpi	r24, 0xFF	; 255
    31f2:	51 f3       	breq	.-44     	; 0x31c8 <MAIN_MENUE+0x1a>
			
			/*check if key = '+'*/
			if ('+'== Local_u8Up_Down )
    31f4:	8f 85       	ldd	r24, Y+15	; 0x0f
    31f6:	8b 32       	cpi	r24, 0x2B	; 43
    31f8:	09 f0       	breq	.+2      	; 0x31fc <MAIN_MENUE+0x4e>
    31fa:	7c c0       	rjmp	.+248    	; 0x32f4 <MAIN_MENUE+0x146>
			{
				/*screen will scroll down */
				CLCD_vidClearLcd();
    31fc:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
				CLCD_vidSednString("3- SHOW CUREENT TEMP");
    3200:	8c ed       	ldi	r24, 0xDC	; 220
    3202:	90 e0       	ldi	r25, 0x00	; 0
    3204:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
    3208:	80 e0       	ldi	r24, 0x00	; 0
    320a:	90 e0       	ldi	r25, 0x00	; 0
    320c:	a8 ec       	ldi	r26, 0xC8	; 200
    320e:	b2 e4       	ldi	r27, 0x42	; 66
    3210:	8b 87       	std	Y+11, r24	; 0x0b
    3212:	9c 87       	std	Y+12, r25	; 0x0c
    3214:	ad 87       	std	Y+13, r26	; 0x0d
    3216:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3218:	6b 85       	ldd	r22, Y+11	; 0x0b
    321a:	7c 85       	ldd	r23, Y+12	; 0x0c
    321c:	8d 85       	ldd	r24, Y+13	; 0x0d
    321e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3220:	20 e0       	ldi	r18, 0x00	; 0
    3222:	30 e0       	ldi	r19, 0x00	; 0
    3224:	48 e4       	ldi	r20, 0x48	; 72
    3226:	53 e4       	ldi	r21, 0x43	; 67
    3228:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    322c:	dc 01       	movw	r26, r24
    322e:	cb 01       	movw	r24, r22
    3230:	8f 83       	std	Y+7, r24	; 0x07
    3232:	98 87       	std	Y+8, r25	; 0x08
    3234:	a9 87       	std	Y+9, r26	; 0x09
    3236:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3238:	6f 81       	ldd	r22, Y+7	; 0x07
    323a:	78 85       	ldd	r23, Y+8	; 0x08
    323c:	89 85       	ldd	r24, Y+9	; 0x09
    323e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3240:	20 e0       	ldi	r18, 0x00	; 0
    3242:	30 e0       	ldi	r19, 0x00	; 0
    3244:	40 e8       	ldi	r20, 0x80	; 128
    3246:	5f e3       	ldi	r21, 0x3F	; 63
    3248:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    324c:	88 23       	and	r24, r24
    324e:	2c f4       	brge	.+10     	; 0x325a <MAIN_MENUE+0xac>
		__ticks = 1;
    3250:	81 e0       	ldi	r24, 0x01	; 1
    3252:	90 e0       	ldi	r25, 0x00	; 0
    3254:	9e 83       	std	Y+6, r25	; 0x06
    3256:	8d 83       	std	Y+5, r24	; 0x05
    3258:	3f c0       	rjmp	.+126    	; 0x32d8 <MAIN_MENUE+0x12a>
	else if (__tmp > 65535)
    325a:	6f 81       	ldd	r22, Y+7	; 0x07
    325c:	78 85       	ldd	r23, Y+8	; 0x08
    325e:	89 85       	ldd	r24, Y+9	; 0x09
    3260:	9a 85       	ldd	r25, Y+10	; 0x0a
    3262:	20 e0       	ldi	r18, 0x00	; 0
    3264:	3f ef       	ldi	r19, 0xFF	; 255
    3266:	4f e7       	ldi	r20, 0x7F	; 127
    3268:	57 e4       	ldi	r21, 0x47	; 71
    326a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    326e:	18 16       	cp	r1, r24
    3270:	4c f5       	brge	.+82     	; 0x32c4 <MAIN_MENUE+0x116>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3272:	6b 85       	ldd	r22, Y+11	; 0x0b
    3274:	7c 85       	ldd	r23, Y+12	; 0x0c
    3276:	8d 85       	ldd	r24, Y+13	; 0x0d
    3278:	9e 85       	ldd	r25, Y+14	; 0x0e
    327a:	20 e0       	ldi	r18, 0x00	; 0
    327c:	30 e0       	ldi	r19, 0x00	; 0
    327e:	40 e2       	ldi	r20, 0x20	; 32
    3280:	51 e4       	ldi	r21, 0x41	; 65
    3282:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3286:	dc 01       	movw	r26, r24
    3288:	cb 01       	movw	r24, r22
    328a:	bc 01       	movw	r22, r24
    328c:	cd 01       	movw	r24, r26
    328e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3292:	dc 01       	movw	r26, r24
    3294:	cb 01       	movw	r24, r22
    3296:	9e 83       	std	Y+6, r25	; 0x06
    3298:	8d 83       	std	Y+5, r24	; 0x05
    329a:	0f c0       	rjmp	.+30     	; 0x32ba <MAIN_MENUE+0x10c>
    329c:	84 e1       	ldi	r24, 0x14	; 20
    329e:	90 e0       	ldi	r25, 0x00	; 0
    32a0:	9c 83       	std	Y+4, r25	; 0x04
    32a2:	8b 83       	std	Y+3, r24	; 0x03
    32a4:	8b 81       	ldd	r24, Y+3	; 0x03
    32a6:	9c 81       	ldd	r25, Y+4	; 0x04
    32a8:	01 97       	sbiw	r24, 0x01	; 1
    32aa:	f1 f7       	brne	.-4      	; 0x32a8 <MAIN_MENUE+0xfa>
    32ac:	9c 83       	std	Y+4, r25	; 0x04
    32ae:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    32b0:	8d 81       	ldd	r24, Y+5	; 0x05
    32b2:	9e 81       	ldd	r25, Y+6	; 0x06
    32b4:	01 97       	sbiw	r24, 0x01	; 1
    32b6:	9e 83       	std	Y+6, r25	; 0x06
    32b8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    32ba:	8d 81       	ldd	r24, Y+5	; 0x05
    32bc:	9e 81       	ldd	r25, Y+6	; 0x06
    32be:	00 97       	sbiw	r24, 0x00	; 0
    32c0:	69 f7       	brne	.-38     	; 0x329c <MAIN_MENUE+0xee>
    32c2:	14 c0       	rjmp	.+40     	; 0x32ec <MAIN_MENUE+0x13e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    32c4:	6f 81       	ldd	r22, Y+7	; 0x07
    32c6:	78 85       	ldd	r23, Y+8	; 0x08
    32c8:	89 85       	ldd	r24, Y+9	; 0x09
    32ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    32cc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    32d0:	dc 01       	movw	r26, r24
    32d2:	cb 01       	movw	r24, r22
    32d4:	9e 83       	std	Y+6, r25	; 0x06
    32d6:	8d 83       	std	Y+5, r24	; 0x05
    32d8:	8d 81       	ldd	r24, Y+5	; 0x05
    32da:	9e 81       	ldd	r25, Y+6	; 0x06
    32dc:	9a 83       	std	Y+2, r25	; 0x02
    32de:	89 83       	std	Y+1, r24	; 0x01
    32e0:	89 81       	ldd	r24, Y+1	; 0x01
    32e2:	9a 81       	ldd	r25, Y+2	; 0x02
    32e4:	01 97       	sbiw	r24, 0x01	; 1
    32e6:	f1 f7       	brne	.-4      	; 0x32e4 <MAIN_MENUE+0x136>
    32e8:	9a 83       	std	Y+2, r25	; 0x02
    32ea:	89 83       	std	Y+1, r24	; 0x01
				_delay_ms(100);
				Local_u8Up_Down=KPD_u8GetPressedKey();
    32ec:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <KPD_u8GetPressedKey>
    32f0:	8f 87       	std	Y+15, r24	; 0x0f
    32f2:	2e c0       	rjmp	.+92     	; 0x3350 <MAIN_MENUE+0x1a2>
				
			}
			/*check if key = '-'*/
			else if ('-'== Local_u8Up_Down)
    32f4:	8f 85       	ldd	r24, Y+15	; 0x0f
    32f6:	8d 32       	cpi	r24, 0x2D	; 45
    32f8:	b1 f4       	brne	.+44     	; 0x3326 <MAIN_MENUE+0x178>
			{
				/*screen will scroll up */
				CLCD_vidClearLcd();
    32fa:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
				CLCD_vidGoToXY(0,0);
    32fe:	80 e0       	ldi	r24, 0x00	; 0
    3300:	60 e0       	ldi	r22, 0x00	; 0
    3302:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
				CLCD_vidSednString("1- START");
    3306:	8d eb       	ldi	r24, 0xBD	; 189
    3308:	90 e0       	ldi	r25, 0x00	; 0
    330a:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
				CLCD_vidGoToXY(1,0);
    330e:	81 e0       	ldi	r24, 0x01	; 1
    3310:	60 e0       	ldi	r22, 0x00	; 0
    3312:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
				CLCD_vidSednString("2-ENTER_NEW_H&L_TEMP");
    3316:	81 ef       	ldi	r24, 0xF1	; 241
    3318:	90 e0       	ldi	r25, 0x00	; 0
    331a:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
				Local_u8Up_Down = KPD_u8GetPressedKey();
    331e:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <KPD_u8GetPressedKey>
    3322:	8f 87       	std	Y+15, r24	; 0x0f
    3324:	15 c0       	rjmp	.+42     	; 0x3350 <MAIN_MENUE+0x1a2>
			}
			/*check if key = '1' go start the sensor comparing and take action  */
			else if ('1'== Local_u8Up_Down)
    3326:	8f 85       	ldd	r24, Y+15	; 0x0f
    3328:	81 33       	cpi	r24, 0x31	; 49
    332a:	21 f4       	brne	.+8      	; 0x3334 <MAIN_MENUE+0x186>
			{
				GLOBAL_u8SELECTOR = '1'; 
    332c:	81 e3       	ldi	r24, 0x31	; 49
    332e:	80 93 fe 01 	sts	0x01FE, r24
    3332:	19 c0       	rjmp	.+50     	; 0x3366 <MAIN_MENUE+0x1b8>
				return; 
			}
			/*check if key = '2' go enter new high& low temperature */
			else if ('2'== Local_u8Up_Down)
    3334:	8f 85       	ldd	r24, Y+15	; 0x0f
    3336:	82 33       	cpi	r24, 0x32	; 50
    3338:	21 f4       	brne	.+8      	; 0x3342 <MAIN_MENUE+0x194>
			{
				GLOBAL_u8SELECTOR = '2';
    333a:	82 e3       	ldi	r24, 0x32	; 50
    333c:	80 93 fe 01 	sts	0x01FE, r24
    3340:	12 c0       	rjmp	.+36     	; 0x3366 <MAIN_MENUE+0x1b8>
				return;
			}
			/*check if key = '2' go show  high& low temperature */
			else if ('3'== Local_u8Up_Down)
    3342:	8f 85       	ldd	r24, Y+15	; 0x0f
    3344:	83 33       	cpi	r24, 0x33	; 51
    3346:	21 f4       	brne	.+8      	; 0x3350 <MAIN_MENUE+0x1a2>
			{
				GLOBAL_u8SELECTOR = '3';
    3348:	83 e3       	ldi	r24, 0x33	; 51
    334a:	80 93 fe 01 	sts	0x01FE, r24
    334e:	0b c0       	rjmp	.+22     	; 0x3366 <MAIN_MENUE+0x1b8>
				return;
			}
			
			do 
			{
				Local_u8Up_Down = 0 ; 
    3350:	1f 86       	std	Y+15, r1	; 0x0f
				Local_u8Up_Down = KPD_u8GetPressedKey();
    3352:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <KPD_u8GetPressedKey>
    3356:	8f 87       	std	Y+15, r24	; 0x0f
				
			} while (Local_u8Up_Down == 0xff);
    3358:	8f 85       	ldd	r24, Y+15	; 0x0f
    335a:	8f 3f       	cpi	r24, 0xFF	; 255
    335c:	c9 f3       	breq	.-14     	; 0x3350 <MAIN_MENUE+0x1a2>
			
		} while (Local_u8Up_Down!='c');		
    335e:	8f 85       	ldd	r24, Y+15	; 0x0f
    3360:	83 36       	cpi	r24, 0x63	; 99
    3362:	09 f0       	breq	.+2      	; 0x3366 <MAIN_MENUE+0x1b8>
    3364:	31 cf       	rjmp	.-414    	; 0x31c8 <MAIN_MENUE+0x1a>

}
    3366:	2f 96       	adiw	r28, 0x0f	; 15
    3368:	0f b6       	in	r0, 0x3f	; 63
    336a:	f8 94       	cli
    336c:	de bf       	out	0x3e, r29	; 62
    336e:	0f be       	out	0x3f, r0	; 63
    3370:	cd bf       	out	0x3d, r28	; 61
    3372:	cf 91       	pop	r28
    3374:	df 91       	pop	r29
    3376:	08 95       	ret

00003378 <SET_MOTOR_SPEED>:

/*set motor speed by writing on OCR0 REGISTER*/
void SET_MOTOR_SPEED(u8 Copy_u8MotorSpeed)
{
    3378:	df 93       	push	r29
    337a:	cf 93       	push	r28
    337c:	0f 92       	push	r0
    337e:	cd b7       	in	r28, 0x3d	; 61
    3380:	de b7       	in	r29, 0x3e	; 62
    3382:	89 83       	std	Y+1, r24	; 0x01
	TIMER0_vidSetCompMatchValue(Copy_u8MotorSpeed); 
    3384:	89 81       	ldd	r24, Y+1	; 0x01
    3386:	0e 94 40 07 	call	0xe80	; 0xe80 <TIMER0_vidSetCompMatchValue>
}
    338a:	0f 90       	pop	r0
    338c:	cf 91       	pop	r28
    338e:	df 91       	pop	r29
    3390:	08 95       	ret

00003392 <TEMP_VALUE>:


void TEMP_VALUE(void)
{
    3392:	0f 93       	push	r16
    3394:	1f 93       	push	r17
    3396:	df 93       	push	r29
    3398:	cf 93       	push	r28
    339a:	cd b7       	in	r28, 0x3d	; 61
    339c:	de b7       	in	r29, 0x3e	; 62
    339e:	ef 97       	sbiw	r28, 0x3f	; 63
    33a0:	0f b6       	in	r0, 0x3f	; 63
    33a2:	f8 94       	cli
    33a4:	de bf       	out	0x3e, r29	; 62
    33a6:	0f be       	out	0x3f, r0	; 63
    33a8:	cd bf       	out	0x3d, r28	; 61
	/*ADC start conversion and calculate the temperature  */
	u16 Local_u32ADCReading = 0 ;
    33aa:	1d ae       	std	Y+61, r1	; 0x3d
    33ac:	1c ae       	std	Y+60, r1	; 0x3c
	u8 TempC=0 ;
    33ae:	1b ae       	std	Y+59, r1	; 0x3b
	u16 Local_u16MilliVolt = 0 ;
    33b0:	1a ae       	std	Y+58, r1	; 0x3a
    33b2:	19 ae       	std	Y+57, r1	; 0x39
	ADC_u8StartConversionSynch(ADC_CH_0,&Local_u32ADCReading);
    33b4:	9e 01       	movw	r18, r28
    33b6:	24 5c       	subi	r18, 0xC4	; 196
    33b8:	3f 4f       	sbci	r19, 0xFF	; 255
    33ba:	80 e0       	ldi	r24, 0x00	; 0
    33bc:	b9 01       	movw	r22, r18
    33be:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <ADC_u8StartConversionSynch>
	Local_u16MilliVolt=(u16)(((u32)Local_u32ADCReading*5000Ul)/256UL); // using 8bit resolution
    33c2:	8c ad       	ldd	r24, Y+60	; 0x3c
    33c4:	9d ad       	ldd	r25, Y+61	; 0x3d
    33c6:	cc 01       	movw	r24, r24
    33c8:	a0 e0       	ldi	r26, 0x00	; 0
    33ca:	b0 e0       	ldi	r27, 0x00	; 0
    33cc:	28 e8       	ldi	r18, 0x88	; 136
    33ce:	33 e1       	ldi	r19, 0x13	; 19
    33d0:	40 e0       	ldi	r20, 0x00	; 0
    33d2:	50 e0       	ldi	r21, 0x00	; 0
    33d4:	bc 01       	movw	r22, r24
    33d6:	cd 01       	movw	r24, r26
    33d8:	0e 94 34 21 	call	0x4268	; 0x4268 <__mulsi3>
    33dc:	dc 01       	movw	r26, r24
    33de:	cb 01       	movw	r24, r22
    33e0:	89 2f       	mov	r24, r25
    33e2:	9a 2f       	mov	r25, r26
    33e4:	ab 2f       	mov	r26, r27
    33e6:	bb 27       	eor	r27, r27
    33e8:	9a af       	std	Y+58, r25	; 0x3a
    33ea:	89 af       	std	Y+57, r24	; 0x39
	TempC = Local_u16MilliVolt/10 ;
    33ec:	89 ad       	ldd	r24, Y+57	; 0x39
    33ee:	9a ad       	ldd	r25, Y+58	; 0x3a
    33f0:	2a e0       	ldi	r18, 0x0A	; 10
    33f2:	30 e0       	ldi	r19, 0x00	; 0
    33f4:	b9 01       	movw	r22, r18
    33f6:	0e 94 53 21 	call	0x42a6	; 0x42a6 <__udivmodhi4>
    33fa:	cb 01       	movw	r24, r22
    33fc:	8b af       	std	Y+59, r24	; 0x3b
	
	/*check if temperature is bigger than high temperature */
	if (TempC>TEMP_STORED_HIGH)
    33fe:	8b ad       	ldd	r24, Y+59	; 0x3b
    3400:	08 2f       	mov	r16, r24
    3402:	10 e0       	ldi	r17, 0x00	; 0
    3404:	82 e2       	ldi	r24, 0x22	; 34
    3406:	90 e0       	ldi	r25, 0x00	; 0
    3408:	60 ea       	ldi	r22, 0xA0	; 160
    340a:	70 e0       	ldi	r23, 0x00	; 0
    340c:	0e 94 18 11 	call	0x2230	; 0x2230 <EEPROM_READ>
    3410:	80 17       	cp	r24, r16
    3412:	91 07       	cpc	r25, r17
    3414:	0c f0       	brlt	.+2      	; 0x3418 <TEMP_VALUE+0x86>
    3416:	1f c1       	rjmp	.+574    	; 0x3656 <TEMP_VALUE+0x2c4>
	{
		LED_u8SetLedOff(LED_PORT,LED_LOW);     /*set other mode led off */
    3418:	81 e0       	ldi	r24, 0x01	; 1
    341a:	64 e0       	ldi	r22, 0x04	; 4
    341c:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <LED_u8SetLedOff>
		LED_u8SetLedOff(LED_PORT,LED_NORMAL);  /*set other mode led off */
    3420:	81 e0       	ldi	r24, 0x01	; 1
    3422:	65 e0       	ldi	r22, 0x05	; 5
    3424:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <LED_u8SetLedOff>
		SET_MOTOR_SPEED(MOTOR_FULL_SPEED);/*set motor speed to full speed */
    3428:	8f ef       	ldi	r24, 0xFF	; 255
    342a:	0e 94 bc 19 	call	0x3378	; 0x3378 <SET_MOTOR_SPEED>
		LED_u8SetLedOn(LED_PORT,LED_HIGH);/* set the red led high */
    342e:	81 e0       	ldi	r24, 0x01	; 1
    3430:	66 e0       	ldi	r22, 0x06	; 6
    3432:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <LED_u8SetLedOn>
		/*BUZZER_ON();*/ 
		DIO_u8SetPinValue(DIO_u8PORTA, DIO_u8PIN1,DIO_u8PIN_HIGH);
    3436:	80 e0       	ldi	r24, 0x00	; 0
    3438:	61 e0       	ldi	r22, 0x01	; 1
    343a:	41 e0       	ldi	r20, 0x01	; 1
    343c:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_u8SetPinValue>
    3440:	80 e0       	ldi	r24, 0x00	; 0
    3442:	90 e0       	ldi	r25, 0x00	; 0
    3444:	a8 e4       	ldi	r26, 0x48	; 72
    3446:	b2 e4       	ldi	r27, 0x42	; 66
    3448:	8d ab       	std	Y+53, r24	; 0x35
    344a:	9e ab       	std	Y+54, r25	; 0x36
    344c:	af ab       	std	Y+55, r26	; 0x37
    344e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3450:	6d a9       	ldd	r22, Y+53	; 0x35
    3452:	7e a9       	ldd	r23, Y+54	; 0x36
    3454:	8f a9       	ldd	r24, Y+55	; 0x37
    3456:	98 ad       	ldd	r25, Y+56	; 0x38
    3458:	20 e0       	ldi	r18, 0x00	; 0
    345a:	30 e0       	ldi	r19, 0x00	; 0
    345c:	48 e4       	ldi	r20, 0x48	; 72
    345e:	53 e4       	ldi	r21, 0x43	; 67
    3460:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3464:	dc 01       	movw	r26, r24
    3466:	cb 01       	movw	r24, r22
    3468:	89 ab       	std	Y+49, r24	; 0x31
    346a:	9a ab       	std	Y+50, r25	; 0x32
    346c:	ab ab       	std	Y+51, r26	; 0x33
    346e:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    3470:	69 a9       	ldd	r22, Y+49	; 0x31
    3472:	7a a9       	ldd	r23, Y+50	; 0x32
    3474:	8b a9       	ldd	r24, Y+51	; 0x33
    3476:	9c a9       	ldd	r25, Y+52	; 0x34
    3478:	20 e0       	ldi	r18, 0x00	; 0
    347a:	30 e0       	ldi	r19, 0x00	; 0
    347c:	40 e8       	ldi	r20, 0x80	; 128
    347e:	5f e3       	ldi	r21, 0x3F	; 63
    3480:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3484:	88 23       	and	r24, r24
    3486:	2c f4       	brge	.+10     	; 0x3492 <TEMP_VALUE+0x100>
		__ticks = 1;
    3488:	81 e0       	ldi	r24, 0x01	; 1
    348a:	90 e0       	ldi	r25, 0x00	; 0
    348c:	98 ab       	std	Y+48, r25	; 0x30
    348e:	8f a7       	std	Y+47, r24	; 0x2f
    3490:	3f c0       	rjmp	.+126    	; 0x3510 <TEMP_VALUE+0x17e>
	else if (__tmp > 65535)
    3492:	69 a9       	ldd	r22, Y+49	; 0x31
    3494:	7a a9       	ldd	r23, Y+50	; 0x32
    3496:	8b a9       	ldd	r24, Y+51	; 0x33
    3498:	9c a9       	ldd	r25, Y+52	; 0x34
    349a:	20 e0       	ldi	r18, 0x00	; 0
    349c:	3f ef       	ldi	r19, 0xFF	; 255
    349e:	4f e7       	ldi	r20, 0x7F	; 127
    34a0:	57 e4       	ldi	r21, 0x47	; 71
    34a2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    34a6:	18 16       	cp	r1, r24
    34a8:	4c f5       	brge	.+82     	; 0x34fc <TEMP_VALUE+0x16a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    34aa:	6d a9       	ldd	r22, Y+53	; 0x35
    34ac:	7e a9       	ldd	r23, Y+54	; 0x36
    34ae:	8f a9       	ldd	r24, Y+55	; 0x37
    34b0:	98 ad       	ldd	r25, Y+56	; 0x38
    34b2:	20 e0       	ldi	r18, 0x00	; 0
    34b4:	30 e0       	ldi	r19, 0x00	; 0
    34b6:	40 e2       	ldi	r20, 0x20	; 32
    34b8:	51 e4       	ldi	r21, 0x41	; 65
    34ba:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    34be:	dc 01       	movw	r26, r24
    34c0:	cb 01       	movw	r24, r22
    34c2:	bc 01       	movw	r22, r24
    34c4:	cd 01       	movw	r24, r26
    34c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    34ca:	dc 01       	movw	r26, r24
    34cc:	cb 01       	movw	r24, r22
    34ce:	98 ab       	std	Y+48, r25	; 0x30
    34d0:	8f a7       	std	Y+47, r24	; 0x2f
    34d2:	0f c0       	rjmp	.+30     	; 0x34f2 <TEMP_VALUE+0x160>
    34d4:	84 e1       	ldi	r24, 0x14	; 20
    34d6:	90 e0       	ldi	r25, 0x00	; 0
    34d8:	9e a7       	std	Y+46, r25	; 0x2e
    34da:	8d a7       	std	Y+45, r24	; 0x2d
    34dc:	8d a5       	ldd	r24, Y+45	; 0x2d
    34de:	9e a5       	ldd	r25, Y+46	; 0x2e
    34e0:	01 97       	sbiw	r24, 0x01	; 1
    34e2:	f1 f7       	brne	.-4      	; 0x34e0 <TEMP_VALUE+0x14e>
    34e4:	9e a7       	std	Y+46, r25	; 0x2e
    34e6:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    34e8:	8f a5       	ldd	r24, Y+47	; 0x2f
    34ea:	98 a9       	ldd	r25, Y+48	; 0x30
    34ec:	01 97       	sbiw	r24, 0x01	; 1
    34ee:	98 ab       	std	Y+48, r25	; 0x30
    34f0:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    34f2:	8f a5       	ldd	r24, Y+47	; 0x2f
    34f4:	98 a9       	ldd	r25, Y+48	; 0x30
    34f6:	00 97       	sbiw	r24, 0x00	; 0
    34f8:	69 f7       	brne	.-38     	; 0x34d4 <TEMP_VALUE+0x142>
    34fa:	14 c0       	rjmp	.+40     	; 0x3524 <TEMP_VALUE+0x192>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    34fc:	69 a9       	ldd	r22, Y+49	; 0x31
    34fe:	7a a9       	ldd	r23, Y+50	; 0x32
    3500:	8b a9       	ldd	r24, Y+51	; 0x33
    3502:	9c a9       	ldd	r25, Y+52	; 0x34
    3504:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3508:	dc 01       	movw	r26, r24
    350a:	cb 01       	movw	r24, r22
    350c:	98 ab       	std	Y+48, r25	; 0x30
    350e:	8f a7       	std	Y+47, r24	; 0x2f
    3510:	8f a5       	ldd	r24, Y+47	; 0x2f
    3512:	98 a9       	ldd	r25, Y+48	; 0x30
    3514:	9c a7       	std	Y+44, r25	; 0x2c
    3516:	8b a7       	std	Y+43, r24	; 0x2b
    3518:	8b a5       	ldd	r24, Y+43	; 0x2b
    351a:	9c a5       	ldd	r25, Y+44	; 0x2c
    351c:	01 97       	sbiw	r24, 0x01	; 1
    351e:	f1 f7       	brne	.-4      	; 0x351c <TEMP_VALUE+0x18a>
    3520:	9c a7       	std	Y+44, r25	; 0x2c
    3522:	8b a7       	std	Y+43, r24	; 0x2b
		_delay_ms(50);
		CLCD_vidClearLcd(); 
    3524:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
		CLCD_vidGoToXY(LCD_ROW1,LCD_COL1); 
    3528:	80 e0       	ldi	r24, 0x00	; 0
    352a:	60 e0       	ldi	r22, 0x00	; 0
    352c:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
		CLCD_vidSednString("T_*c= ");
    3530:	86 e0       	ldi	r24, 0x06	; 6
    3532:	91 e0       	ldi	r25, 0x01	; 1
    3534:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
		CLCD_vidSendLargeNmber(TempC);      /*display current temperature on screen */
    3538:	8b ad       	ldd	r24, Y+59	; 0x3b
    353a:	88 2f       	mov	r24, r24
    353c:	90 e0       	ldi	r25, 0x00	; 0
    353e:	a0 e0       	ldi	r26, 0x00	; 0
    3540:	b0 e0       	ldi	r27, 0x00	; 0
    3542:	bc 01       	movw	r22, r24
    3544:	cd 01       	movw	r24, r26
    3546:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <CLCD_vidSendLargeNmber>
		CLCD_vidGoToXY(LCD_ROW2,LCD_COL1); 
    354a:	81 e0       	ldi	r24, 0x01	; 1
    354c:	60 e0       	ldi	r22, 0x00	; 0
    354e:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
		CLCD_vidSednString("ALARM");        /*display ALARM on screen */
    3552:	8d e0       	ldi	r24, 0x0D	; 13
    3554:	91 e0       	ldi	r25, 0x01	; 1
    3556:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
		CLCD_vidGoToXY(LCD_ROW2,LCD_COL7); 
    355a:	81 e0       	ldi	r24, 0x01	; 1
    355c:	66 e0       	ldi	r22, 0x06	; 6
    355e:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
		CLCD_vidSednString("FanSpeed 100%");/*display motor speed  on screen */
    3562:	83 e1       	ldi	r24, 0x13	; 19
    3564:	91 e0       	ldi	r25, 0x01	; 1
    3566:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
    356a:	80 e0       	ldi	r24, 0x00	; 0
    356c:	90 e0       	ldi	r25, 0x00	; 0
    356e:	aa ef       	ldi	r26, 0xFA	; 250
    3570:	b3 e4       	ldi	r27, 0x43	; 67
    3572:	8f a3       	std	Y+39, r24	; 0x27
    3574:	98 a7       	std	Y+40, r25	; 0x28
    3576:	a9 a7       	std	Y+41, r26	; 0x29
    3578:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    357a:	6f a1       	ldd	r22, Y+39	; 0x27
    357c:	78 a5       	ldd	r23, Y+40	; 0x28
    357e:	89 a5       	ldd	r24, Y+41	; 0x29
    3580:	9a a5       	ldd	r25, Y+42	; 0x2a
    3582:	20 e0       	ldi	r18, 0x00	; 0
    3584:	30 e0       	ldi	r19, 0x00	; 0
    3586:	48 e4       	ldi	r20, 0x48	; 72
    3588:	53 e4       	ldi	r21, 0x43	; 67
    358a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    358e:	dc 01       	movw	r26, r24
    3590:	cb 01       	movw	r24, r22
    3592:	8b a3       	std	Y+35, r24	; 0x23
    3594:	9c a3       	std	Y+36, r25	; 0x24
    3596:	ad a3       	std	Y+37, r26	; 0x25
    3598:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    359a:	6b a1       	ldd	r22, Y+35	; 0x23
    359c:	7c a1       	ldd	r23, Y+36	; 0x24
    359e:	8d a1       	ldd	r24, Y+37	; 0x25
    35a0:	9e a1       	ldd	r25, Y+38	; 0x26
    35a2:	20 e0       	ldi	r18, 0x00	; 0
    35a4:	30 e0       	ldi	r19, 0x00	; 0
    35a6:	40 e8       	ldi	r20, 0x80	; 128
    35a8:	5f e3       	ldi	r21, 0x3F	; 63
    35aa:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    35ae:	88 23       	and	r24, r24
    35b0:	2c f4       	brge	.+10     	; 0x35bc <TEMP_VALUE+0x22a>
		__ticks = 1;
    35b2:	81 e0       	ldi	r24, 0x01	; 1
    35b4:	90 e0       	ldi	r25, 0x00	; 0
    35b6:	9a a3       	std	Y+34, r25	; 0x22
    35b8:	89 a3       	std	Y+33, r24	; 0x21
    35ba:	3f c0       	rjmp	.+126    	; 0x363a <TEMP_VALUE+0x2a8>
	else if (__tmp > 65535)
    35bc:	6b a1       	ldd	r22, Y+35	; 0x23
    35be:	7c a1       	ldd	r23, Y+36	; 0x24
    35c0:	8d a1       	ldd	r24, Y+37	; 0x25
    35c2:	9e a1       	ldd	r25, Y+38	; 0x26
    35c4:	20 e0       	ldi	r18, 0x00	; 0
    35c6:	3f ef       	ldi	r19, 0xFF	; 255
    35c8:	4f e7       	ldi	r20, 0x7F	; 127
    35ca:	57 e4       	ldi	r21, 0x47	; 71
    35cc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    35d0:	18 16       	cp	r1, r24
    35d2:	4c f5       	brge	.+82     	; 0x3626 <TEMP_VALUE+0x294>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    35d4:	6f a1       	ldd	r22, Y+39	; 0x27
    35d6:	78 a5       	ldd	r23, Y+40	; 0x28
    35d8:	89 a5       	ldd	r24, Y+41	; 0x29
    35da:	9a a5       	ldd	r25, Y+42	; 0x2a
    35dc:	20 e0       	ldi	r18, 0x00	; 0
    35de:	30 e0       	ldi	r19, 0x00	; 0
    35e0:	40 e2       	ldi	r20, 0x20	; 32
    35e2:	51 e4       	ldi	r21, 0x41	; 65
    35e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    35e8:	dc 01       	movw	r26, r24
    35ea:	cb 01       	movw	r24, r22
    35ec:	bc 01       	movw	r22, r24
    35ee:	cd 01       	movw	r24, r26
    35f0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    35f4:	dc 01       	movw	r26, r24
    35f6:	cb 01       	movw	r24, r22
    35f8:	9a a3       	std	Y+34, r25	; 0x22
    35fa:	89 a3       	std	Y+33, r24	; 0x21
    35fc:	0f c0       	rjmp	.+30     	; 0x361c <TEMP_VALUE+0x28a>
    35fe:	84 e1       	ldi	r24, 0x14	; 20
    3600:	90 e0       	ldi	r25, 0x00	; 0
    3602:	98 a3       	std	Y+32, r25	; 0x20
    3604:	8f 8f       	std	Y+31, r24	; 0x1f
    3606:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3608:	98 a1       	ldd	r25, Y+32	; 0x20
    360a:	01 97       	sbiw	r24, 0x01	; 1
    360c:	f1 f7       	brne	.-4      	; 0x360a <TEMP_VALUE+0x278>
    360e:	98 a3       	std	Y+32, r25	; 0x20
    3610:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3612:	89 a1       	ldd	r24, Y+33	; 0x21
    3614:	9a a1       	ldd	r25, Y+34	; 0x22
    3616:	01 97       	sbiw	r24, 0x01	; 1
    3618:	9a a3       	std	Y+34, r25	; 0x22
    361a:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    361c:	89 a1       	ldd	r24, Y+33	; 0x21
    361e:	9a a1       	ldd	r25, Y+34	; 0x22
    3620:	00 97       	sbiw	r24, 0x00	; 0
    3622:	69 f7       	brne	.-38     	; 0x35fe <TEMP_VALUE+0x26c>
    3624:	14 c0       	rjmp	.+40     	; 0x364e <TEMP_VALUE+0x2bc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3626:	6b a1       	ldd	r22, Y+35	; 0x23
    3628:	7c a1       	ldd	r23, Y+36	; 0x24
    362a:	8d a1       	ldd	r24, Y+37	; 0x25
    362c:	9e a1       	ldd	r25, Y+38	; 0x26
    362e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3632:	dc 01       	movw	r26, r24
    3634:	cb 01       	movw	r24, r22
    3636:	9a a3       	std	Y+34, r25	; 0x22
    3638:	89 a3       	std	Y+33, r24	; 0x21
    363a:	89 a1       	ldd	r24, Y+33	; 0x21
    363c:	9a a1       	ldd	r25, Y+34	; 0x22
    363e:	9e 8f       	std	Y+30, r25	; 0x1e
    3640:	8d 8f       	std	Y+29, r24	; 0x1d
    3642:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3644:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3646:	01 97       	sbiw	r24, 0x01	; 1
    3648:	f1 f7       	brne	.-4      	; 0x3646 <TEMP_VALUE+0x2b4>
    364a:	9e 8f       	std	Y+30, r25	; 0x1e
    364c:	8d 8f       	std	Y+29, r24	; 0x1d
		_delay_ms(500); 
		Local_Uart_state = HIG_MODE ;  
    364e:	81 e0       	ldi	r24, 0x01	; 1
    3650:	80 93 0c 02 	sts	0x020C, r24
    3654:	7a c1       	rjmp	.+756    	; 0x394a <TEMP_VALUE+0x5b8>
		 
	}
	
	/*check if temperature is on the mid range */
	else if (TempC>TEMP_STORED_LOW && TempC<=TEMP_STORED_HIGH)
    3656:	8b ad       	ldd	r24, Y+59	; 0x3b
    3658:	08 2f       	mov	r16, r24
    365a:	10 e0       	ldi	r17, 0x00	; 0
    365c:	88 e2       	ldi	r24, 0x28	; 40
    365e:	90 e0       	ldi	r25, 0x00	; 0
    3660:	60 ea       	ldi	r22, 0xA0	; 160
    3662:	70 e0       	ldi	r23, 0x00	; 0
    3664:	0e 94 18 11 	call	0x2230	; 0x2230 <EEPROM_READ>
    3668:	80 17       	cp	r24, r16
    366a:	91 07       	cpc	r25, r17
    366c:	0c f0       	brlt	.+2      	; 0x3670 <TEMP_VALUE+0x2de>
    366e:	b7 c0       	rjmp	.+366    	; 0x37de <TEMP_VALUE+0x44c>
    3670:	8b ad       	ldd	r24, Y+59	; 0x3b
    3672:	08 2f       	mov	r16, r24
    3674:	10 e0       	ldi	r17, 0x00	; 0
    3676:	82 e2       	ldi	r24, 0x22	; 34
    3678:	90 e0       	ldi	r25, 0x00	; 0
    367a:	60 ea       	ldi	r22, 0xA0	; 160
    367c:	70 e0       	ldi	r23, 0x00	; 0
    367e:	0e 94 18 11 	call	0x2230	; 0x2230 <EEPROM_READ>
    3682:	80 17       	cp	r24, r16
    3684:	91 07       	cpc	r25, r17
    3686:	0c f4       	brge	.+2      	; 0x368a <TEMP_VALUE+0x2f8>
    3688:	aa c0       	rjmp	.+340    	; 0x37de <TEMP_VALUE+0x44c>
	{
		LED_u8SetLedOff(LED_PORT,LED_LOW);     /*set other mode led off */
    368a:	81 e0       	ldi	r24, 0x01	; 1
    368c:	64 e0       	ldi	r22, 0x04	; 4
    368e:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <LED_u8SetLedOff>
		LED_u8SetLedOff(LED_PORT,LED_HIGH);	  /*set other mode led off */
    3692:	81 e0       	ldi	r24, 0x01	; 1
    3694:	66 e0       	ldi	r22, 0x06	; 6
    3696:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <LED_u8SetLedOff>
		BUZZER_OFF();                         /*Disable buzzer*/
    369a:	0e 94 75 17 	call	0x2eea	; 0x2eea <BUZZER_OFF>
		
		SET_MOTOR_SPEED(MOTOR_HALF_SPEED);    /*set motor speed to full speed */
    369e:	80 e8       	ldi	r24, 0x80	; 128
    36a0:	0e 94 bc 19 	call	0x3378	; 0x3378 <SET_MOTOR_SPEED>
		LED_u8SetLedOn(LED_PORT,LED_NORMAL);  /* set the red led mid */
    36a4:	81 e0       	ldi	r24, 0x01	; 1
    36a6:	65 e0       	ldi	r22, 0x05	; 5
    36a8:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <LED_u8SetLedOn>
		
		CLCD_vidClearLcd();
    36ac:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
		CLCD_vidGoToXY(LCD_ROW1,LCD_COL1);
    36b0:	80 e0       	ldi	r24, 0x00	; 0
    36b2:	60 e0       	ldi	r22, 0x00	; 0
    36b4:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
		CLCD_vidSednString("T_*c= ");
    36b8:	86 e0       	ldi	r24, 0x06	; 6
    36ba:	91 e0       	ldi	r25, 0x01	; 1
    36bc:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
		CLCD_vidSendLargeNmber(TempC);        /*display current temperature on screen */
    36c0:	8b ad       	ldd	r24, Y+59	; 0x3b
    36c2:	88 2f       	mov	r24, r24
    36c4:	90 e0       	ldi	r25, 0x00	; 0
    36c6:	a0 e0       	ldi	r26, 0x00	; 0
    36c8:	b0 e0       	ldi	r27, 0x00	; 0
    36ca:	bc 01       	movw	r22, r24
    36cc:	cd 01       	movw	r24, r26
    36ce:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <CLCD_vidSendLargeNmber>
		CLCD_vidGoToXY(LCD_ROW2,LCD_COL1);
    36d2:	81 e0       	ldi	r24, 0x01	; 1
    36d4:	60 e0       	ldi	r22, 0x00	; 0
    36d6:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
		CLCD_vidSednString("NORM");			  /*display ALARM on screen */
    36da:	81 e2       	ldi	r24, 0x21	; 33
    36dc:	91 e0       	ldi	r25, 0x01	; 1
    36de:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
		CLCD_vidGoToXY(LCD_ROW2,LCD_COL7);
    36e2:	81 e0       	ldi	r24, 0x01	; 1
    36e4:	66 e0       	ldi	r22, 0x06	; 6
    36e6:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
		CLCD_vidSednString("FanSpeed 50%");	  /*display motor speed  on screen */
    36ea:	86 e2       	ldi	r24, 0x26	; 38
    36ec:	91 e0       	ldi	r25, 0x01	; 1
    36ee:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
    36f2:	80 e0       	ldi	r24, 0x00	; 0
    36f4:	90 e0       	ldi	r25, 0x00	; 0
    36f6:	aa ef       	ldi	r26, 0xFA	; 250
    36f8:	b3 e4       	ldi	r27, 0x43	; 67
    36fa:	89 8f       	std	Y+25, r24	; 0x19
    36fc:	9a 8f       	std	Y+26, r25	; 0x1a
    36fe:	ab 8f       	std	Y+27, r26	; 0x1b
    3700:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3702:	69 8d       	ldd	r22, Y+25	; 0x19
    3704:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3706:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3708:	9c 8d       	ldd	r25, Y+28	; 0x1c
    370a:	20 e0       	ldi	r18, 0x00	; 0
    370c:	30 e0       	ldi	r19, 0x00	; 0
    370e:	48 e4       	ldi	r20, 0x48	; 72
    3710:	53 e4       	ldi	r21, 0x43	; 67
    3712:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3716:	dc 01       	movw	r26, r24
    3718:	cb 01       	movw	r24, r22
    371a:	8d 8b       	std	Y+21, r24	; 0x15
    371c:	9e 8b       	std	Y+22, r25	; 0x16
    371e:	af 8b       	std	Y+23, r26	; 0x17
    3720:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3722:	6d 89       	ldd	r22, Y+21	; 0x15
    3724:	7e 89       	ldd	r23, Y+22	; 0x16
    3726:	8f 89       	ldd	r24, Y+23	; 0x17
    3728:	98 8d       	ldd	r25, Y+24	; 0x18
    372a:	20 e0       	ldi	r18, 0x00	; 0
    372c:	30 e0       	ldi	r19, 0x00	; 0
    372e:	40 e8       	ldi	r20, 0x80	; 128
    3730:	5f e3       	ldi	r21, 0x3F	; 63
    3732:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3736:	88 23       	and	r24, r24
    3738:	2c f4       	brge	.+10     	; 0x3744 <TEMP_VALUE+0x3b2>
		__ticks = 1;
    373a:	81 e0       	ldi	r24, 0x01	; 1
    373c:	90 e0       	ldi	r25, 0x00	; 0
    373e:	9c 8b       	std	Y+20, r25	; 0x14
    3740:	8b 8b       	std	Y+19, r24	; 0x13
    3742:	3f c0       	rjmp	.+126    	; 0x37c2 <TEMP_VALUE+0x430>
	else if (__tmp > 65535)
    3744:	6d 89       	ldd	r22, Y+21	; 0x15
    3746:	7e 89       	ldd	r23, Y+22	; 0x16
    3748:	8f 89       	ldd	r24, Y+23	; 0x17
    374a:	98 8d       	ldd	r25, Y+24	; 0x18
    374c:	20 e0       	ldi	r18, 0x00	; 0
    374e:	3f ef       	ldi	r19, 0xFF	; 255
    3750:	4f e7       	ldi	r20, 0x7F	; 127
    3752:	57 e4       	ldi	r21, 0x47	; 71
    3754:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3758:	18 16       	cp	r1, r24
    375a:	4c f5       	brge	.+82     	; 0x37ae <TEMP_VALUE+0x41c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    375c:	69 8d       	ldd	r22, Y+25	; 0x19
    375e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3760:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3762:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3764:	20 e0       	ldi	r18, 0x00	; 0
    3766:	30 e0       	ldi	r19, 0x00	; 0
    3768:	40 e2       	ldi	r20, 0x20	; 32
    376a:	51 e4       	ldi	r21, 0x41	; 65
    376c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3770:	dc 01       	movw	r26, r24
    3772:	cb 01       	movw	r24, r22
    3774:	bc 01       	movw	r22, r24
    3776:	cd 01       	movw	r24, r26
    3778:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    377c:	dc 01       	movw	r26, r24
    377e:	cb 01       	movw	r24, r22
    3780:	9c 8b       	std	Y+20, r25	; 0x14
    3782:	8b 8b       	std	Y+19, r24	; 0x13
    3784:	0f c0       	rjmp	.+30     	; 0x37a4 <TEMP_VALUE+0x412>
    3786:	84 e1       	ldi	r24, 0x14	; 20
    3788:	90 e0       	ldi	r25, 0x00	; 0
    378a:	9a 8b       	std	Y+18, r25	; 0x12
    378c:	89 8b       	std	Y+17, r24	; 0x11
    378e:	89 89       	ldd	r24, Y+17	; 0x11
    3790:	9a 89       	ldd	r25, Y+18	; 0x12
    3792:	01 97       	sbiw	r24, 0x01	; 1
    3794:	f1 f7       	brne	.-4      	; 0x3792 <TEMP_VALUE+0x400>
    3796:	9a 8b       	std	Y+18, r25	; 0x12
    3798:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    379a:	8b 89       	ldd	r24, Y+19	; 0x13
    379c:	9c 89       	ldd	r25, Y+20	; 0x14
    379e:	01 97       	sbiw	r24, 0x01	; 1
    37a0:	9c 8b       	std	Y+20, r25	; 0x14
    37a2:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    37a4:	8b 89       	ldd	r24, Y+19	; 0x13
    37a6:	9c 89       	ldd	r25, Y+20	; 0x14
    37a8:	00 97       	sbiw	r24, 0x00	; 0
    37aa:	69 f7       	brne	.-38     	; 0x3786 <TEMP_VALUE+0x3f4>
    37ac:	14 c0       	rjmp	.+40     	; 0x37d6 <TEMP_VALUE+0x444>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    37ae:	6d 89       	ldd	r22, Y+21	; 0x15
    37b0:	7e 89       	ldd	r23, Y+22	; 0x16
    37b2:	8f 89       	ldd	r24, Y+23	; 0x17
    37b4:	98 8d       	ldd	r25, Y+24	; 0x18
    37b6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    37ba:	dc 01       	movw	r26, r24
    37bc:	cb 01       	movw	r24, r22
    37be:	9c 8b       	std	Y+20, r25	; 0x14
    37c0:	8b 8b       	std	Y+19, r24	; 0x13
    37c2:	8b 89       	ldd	r24, Y+19	; 0x13
    37c4:	9c 89       	ldd	r25, Y+20	; 0x14
    37c6:	98 8b       	std	Y+16, r25	; 0x10
    37c8:	8f 87       	std	Y+15, r24	; 0x0f
    37ca:	8f 85       	ldd	r24, Y+15	; 0x0f
    37cc:	98 89       	ldd	r25, Y+16	; 0x10
    37ce:	01 97       	sbiw	r24, 0x01	; 1
    37d0:	f1 f7       	brne	.-4      	; 0x37ce <TEMP_VALUE+0x43c>
    37d2:	98 8b       	std	Y+16, r25	; 0x10
    37d4:	8f 87       	std	Y+15, r24	; 0x0f
		_delay_ms(500);
		Local_Uart_state = NORMAL_MODE ; 
    37d6:	82 e0       	ldi	r24, 0x02	; 2
    37d8:	80 93 0c 02 	sts	0x020C, r24
    37dc:	b6 c0       	rjmp	.+364    	; 0x394a <TEMP_VALUE+0x5b8>
	}
	/*check if temperature is on the mid range */
	else if (TempC<=TEMP_STORED_LOW)
    37de:	8b ad       	ldd	r24, Y+59	; 0x3b
    37e0:	08 2f       	mov	r16, r24
    37e2:	10 e0       	ldi	r17, 0x00	; 0
    37e4:	88 e2       	ldi	r24, 0x28	; 40
    37e6:	90 e0       	ldi	r25, 0x00	; 0
    37e8:	60 ea       	ldi	r22, 0xA0	; 160
    37ea:	70 e0       	ldi	r23, 0x00	; 0
    37ec:	0e 94 18 11 	call	0x2230	; 0x2230 <EEPROM_READ>
    37f0:	80 17       	cp	r24, r16
    37f2:	91 07       	cpc	r25, r17
    37f4:	0c f4       	brge	.+2      	; 0x37f8 <TEMP_VALUE+0x466>
    37f6:	a9 c0       	rjmp	.+338    	; 0x394a <TEMP_VALUE+0x5b8>
	{
		LED_u8SetLedOff(LED_PORT,LED_HIGH);     /*set other mode led off */
    37f8:	81 e0       	ldi	r24, 0x01	; 1
    37fa:	66 e0       	ldi	r22, 0x06	; 6
    37fc:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <LED_u8SetLedOff>
		LED_u8SetLedOff(LED_PORT,LED_NORMAL);  /*set other mode led off */
    3800:	81 e0       	ldi	r24, 0x01	; 1
    3802:	65 e0       	ldi	r22, 0x05	; 5
    3804:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <LED_u8SetLedOff>
		BUZZER_OFF();                         /*Disable buzzer*/
    3808:	0e 94 75 17 	call	0x2eea	; 0x2eea <BUZZER_OFF>
		
		SET_MOTOR_SPEED(MOTOR_STOP);          /*set motor speed to full speed */
    380c:	80 e0       	ldi	r24, 0x00	; 0
    380e:	0e 94 bc 19 	call	0x3378	; 0x3378 <SET_MOTOR_SPEED>
		LED_u8SetLedOn(LED_PORT,LED_LOW);     /* set the red led low */
    3812:	81 e0       	ldi	r24, 0x01	; 1
    3814:	64 e0       	ldi	r22, 0x04	; 4
    3816:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <LED_u8SetLedOn>
		
		CLCD_vidClearLcd();
    381a:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
		CLCD_vidGoToXY(LCD_ROW1,LCD_COL1);
    381e:	80 e0       	ldi	r24, 0x00	; 0
    3820:	60 e0       	ldi	r22, 0x00	; 0
    3822:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
		CLCD_vidSednString("T_*c= ");
    3826:	86 e0       	ldi	r24, 0x06	; 6
    3828:	91 e0       	ldi	r25, 0x01	; 1
    382a:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
		CLCD_vidSendLargeNmber(TempC);        /*display current temperature on screen */
    382e:	8b ad       	ldd	r24, Y+59	; 0x3b
    3830:	88 2f       	mov	r24, r24
    3832:	90 e0       	ldi	r25, 0x00	; 0
    3834:	a0 e0       	ldi	r26, 0x00	; 0
    3836:	b0 e0       	ldi	r27, 0x00	; 0
    3838:	bc 01       	movw	r22, r24
    383a:	cd 01       	movw	r24, r26
    383c:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <CLCD_vidSendLargeNmber>
		CLCD_vidGoToXY(LCD_ROW2,LCD_COL1);
    3840:	81 e0       	ldi	r24, 0x01	; 1
    3842:	60 e0       	ldi	r22, 0x00	; 0
    3844:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
		CLCD_vidSednString("LOW");			  /*display ALARM on screen */
    3848:	83 e3       	ldi	r24, 0x33	; 51
    384a:	91 e0       	ldi	r25, 0x01	; 1
    384c:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
		CLCD_vidGoToXY(LCD_ROW2,LCD_COL5);
    3850:	81 e0       	ldi	r24, 0x01	; 1
    3852:	64 e0       	ldi	r22, 0x04	; 4
    3854:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
		CLCD_vidSednString("FanSpeed 0%");	  /*display motor speed  on screen */
    3858:	87 e3       	ldi	r24, 0x37	; 55
    385a:	91 e0       	ldi	r25, 0x01	; 1
    385c:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
    3860:	80 e0       	ldi	r24, 0x00	; 0
    3862:	90 e0       	ldi	r25, 0x00	; 0
    3864:	aa ef       	ldi	r26, 0xFA	; 250
    3866:	b3 e4       	ldi	r27, 0x43	; 67
    3868:	8b 87       	std	Y+11, r24	; 0x0b
    386a:	9c 87       	std	Y+12, r25	; 0x0c
    386c:	ad 87       	std	Y+13, r26	; 0x0d
    386e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3870:	6b 85       	ldd	r22, Y+11	; 0x0b
    3872:	7c 85       	ldd	r23, Y+12	; 0x0c
    3874:	8d 85       	ldd	r24, Y+13	; 0x0d
    3876:	9e 85       	ldd	r25, Y+14	; 0x0e
    3878:	20 e0       	ldi	r18, 0x00	; 0
    387a:	30 e0       	ldi	r19, 0x00	; 0
    387c:	48 e4       	ldi	r20, 0x48	; 72
    387e:	53 e4       	ldi	r21, 0x43	; 67
    3880:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3884:	dc 01       	movw	r26, r24
    3886:	cb 01       	movw	r24, r22
    3888:	8f 83       	std	Y+7, r24	; 0x07
    388a:	98 87       	std	Y+8, r25	; 0x08
    388c:	a9 87       	std	Y+9, r26	; 0x09
    388e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3890:	6f 81       	ldd	r22, Y+7	; 0x07
    3892:	78 85       	ldd	r23, Y+8	; 0x08
    3894:	89 85       	ldd	r24, Y+9	; 0x09
    3896:	9a 85       	ldd	r25, Y+10	; 0x0a
    3898:	20 e0       	ldi	r18, 0x00	; 0
    389a:	30 e0       	ldi	r19, 0x00	; 0
    389c:	40 e8       	ldi	r20, 0x80	; 128
    389e:	5f e3       	ldi	r21, 0x3F	; 63
    38a0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    38a4:	88 23       	and	r24, r24
    38a6:	2c f4       	brge	.+10     	; 0x38b2 <TEMP_VALUE+0x520>
		__ticks = 1;
    38a8:	81 e0       	ldi	r24, 0x01	; 1
    38aa:	90 e0       	ldi	r25, 0x00	; 0
    38ac:	9e 83       	std	Y+6, r25	; 0x06
    38ae:	8d 83       	std	Y+5, r24	; 0x05
    38b0:	3f c0       	rjmp	.+126    	; 0x3930 <TEMP_VALUE+0x59e>
	else if (__tmp > 65535)
    38b2:	6f 81       	ldd	r22, Y+7	; 0x07
    38b4:	78 85       	ldd	r23, Y+8	; 0x08
    38b6:	89 85       	ldd	r24, Y+9	; 0x09
    38b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    38ba:	20 e0       	ldi	r18, 0x00	; 0
    38bc:	3f ef       	ldi	r19, 0xFF	; 255
    38be:	4f e7       	ldi	r20, 0x7F	; 127
    38c0:	57 e4       	ldi	r21, 0x47	; 71
    38c2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    38c6:	18 16       	cp	r1, r24
    38c8:	4c f5       	brge	.+82     	; 0x391c <TEMP_VALUE+0x58a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    38ca:	6b 85       	ldd	r22, Y+11	; 0x0b
    38cc:	7c 85       	ldd	r23, Y+12	; 0x0c
    38ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    38d0:	9e 85       	ldd	r25, Y+14	; 0x0e
    38d2:	20 e0       	ldi	r18, 0x00	; 0
    38d4:	30 e0       	ldi	r19, 0x00	; 0
    38d6:	40 e2       	ldi	r20, 0x20	; 32
    38d8:	51 e4       	ldi	r21, 0x41	; 65
    38da:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    38de:	dc 01       	movw	r26, r24
    38e0:	cb 01       	movw	r24, r22
    38e2:	bc 01       	movw	r22, r24
    38e4:	cd 01       	movw	r24, r26
    38e6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    38ea:	dc 01       	movw	r26, r24
    38ec:	cb 01       	movw	r24, r22
    38ee:	9e 83       	std	Y+6, r25	; 0x06
    38f0:	8d 83       	std	Y+5, r24	; 0x05
    38f2:	0f c0       	rjmp	.+30     	; 0x3912 <TEMP_VALUE+0x580>
    38f4:	84 e1       	ldi	r24, 0x14	; 20
    38f6:	90 e0       	ldi	r25, 0x00	; 0
    38f8:	9c 83       	std	Y+4, r25	; 0x04
    38fa:	8b 83       	std	Y+3, r24	; 0x03
    38fc:	8b 81       	ldd	r24, Y+3	; 0x03
    38fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3900:	01 97       	sbiw	r24, 0x01	; 1
    3902:	f1 f7       	brne	.-4      	; 0x3900 <TEMP_VALUE+0x56e>
    3904:	9c 83       	std	Y+4, r25	; 0x04
    3906:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3908:	8d 81       	ldd	r24, Y+5	; 0x05
    390a:	9e 81       	ldd	r25, Y+6	; 0x06
    390c:	01 97       	sbiw	r24, 0x01	; 1
    390e:	9e 83       	std	Y+6, r25	; 0x06
    3910:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3912:	8d 81       	ldd	r24, Y+5	; 0x05
    3914:	9e 81       	ldd	r25, Y+6	; 0x06
    3916:	00 97       	sbiw	r24, 0x00	; 0
    3918:	69 f7       	brne	.-38     	; 0x38f4 <TEMP_VALUE+0x562>
    391a:	14 c0       	rjmp	.+40     	; 0x3944 <TEMP_VALUE+0x5b2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    391c:	6f 81       	ldd	r22, Y+7	; 0x07
    391e:	78 85       	ldd	r23, Y+8	; 0x08
    3920:	89 85       	ldd	r24, Y+9	; 0x09
    3922:	9a 85       	ldd	r25, Y+10	; 0x0a
    3924:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3928:	dc 01       	movw	r26, r24
    392a:	cb 01       	movw	r24, r22
    392c:	9e 83       	std	Y+6, r25	; 0x06
    392e:	8d 83       	std	Y+5, r24	; 0x05
    3930:	8d 81       	ldd	r24, Y+5	; 0x05
    3932:	9e 81       	ldd	r25, Y+6	; 0x06
    3934:	9a 83       	std	Y+2, r25	; 0x02
    3936:	89 83       	std	Y+1, r24	; 0x01
    3938:	89 81       	ldd	r24, Y+1	; 0x01
    393a:	9a 81       	ldd	r25, Y+2	; 0x02
    393c:	01 97       	sbiw	r24, 0x01	; 1
    393e:	f1 f7       	brne	.-4      	; 0x393c <TEMP_VALUE+0x5aa>
    3940:	9a 83       	std	Y+2, r25	; 0x02
    3942:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(500);
		Local_Uart_state = LOW_MODE ; 
    3944:	83 e0       	ldi	r24, 0x03	; 3
    3946:	80 93 0c 02 	sts	0x020C, r24
	}
	
	/*check if operating mode is not changed */
	 if (Local_Uart_check != Local_Uart_state ) 
    394a:	90 91 0d 02 	lds	r25, 0x020D
    394e:	80 91 0c 02 	lds	r24, 0x020C
    3952:	98 17       	cp	r25, r24
    3954:	49 f1       	breq	.+82     	; 0x39a8 <TEMP_VALUE+0x616>
	 {
		switch(Local_Uart_state)
    3956:	80 91 0c 02 	lds	r24, 0x020C
    395a:	28 2f       	mov	r18, r24
    395c:	30 e0       	ldi	r19, 0x00	; 0
    395e:	3f af       	std	Y+63, r19	; 0x3f
    3960:	2e af       	std	Y+62, r18	; 0x3e
    3962:	8e ad       	ldd	r24, Y+62	; 0x3e
    3964:	9f ad       	ldd	r25, Y+63	; 0x3f
    3966:	82 30       	cpi	r24, 0x02	; 2
    3968:	91 05       	cpc	r25, r1
    396a:	89 f0       	breq	.+34     	; 0x398e <TEMP_VALUE+0x5fc>
    396c:	2e ad       	ldd	r18, Y+62	; 0x3e
    396e:	3f ad       	ldd	r19, Y+63	; 0x3f
    3970:	23 30       	cpi	r18, 0x03	; 3
    3972:	31 05       	cpc	r19, r1
    3974:	99 f0       	breq	.+38     	; 0x399c <TEMP_VALUE+0x60a>
    3976:	8e ad       	ldd	r24, Y+62	; 0x3e
    3978:	9f ad       	ldd	r25, Y+63	; 0x3f
    397a:	81 30       	cpi	r24, 0x01	; 1
    397c:	91 05       	cpc	r25, r1
    397e:	a1 f4       	brne	.+40     	; 0x39a8 <TEMP_VALUE+0x616>
			{
				case HIG_MODE : 
				UART_voidWriteNewLine(); 
    3980:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_voidWriteNewLine>
				UART_voidSendString("FIRE_ALARM"); 
    3984:	83 e4       	ldi	r24, 0x43	; 67
    3986:	91 e0       	ldi	r25, 0x01	; 1
    3988:	0e 94 45 06 	call	0xc8a	; 0xc8a <UART_voidSendString>
    398c:	0d c0       	rjmp	.+26     	; 0x39a8 <TEMP_VALUE+0x616>
				break;
				case NORMAL_MODE : 
				UART_voidWriteNewLine(); 
    398e:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_voidWriteNewLine>
				UART_voidSendString("NORAML_MODE") ; 
    3992:	8e e4       	ldi	r24, 0x4E	; 78
    3994:	91 e0       	ldi	r25, 0x01	; 1
    3996:	0e 94 45 06 	call	0xc8a	; 0xc8a <UART_voidSendString>
    399a:	06 c0       	rjmp	.+12     	; 0x39a8 <TEMP_VALUE+0x616>
				break; 
				case LOW_MODE :
				UART_voidWriteNewLine();
    399c:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_voidWriteNewLine>
				UART_voidSendString("LOW_TEMPRATURE") ;
    39a0:	8a e5       	ldi	r24, 0x5A	; 90
    39a2:	91 e0       	ldi	r25, 0x01	; 1
    39a4:	0e 94 45 06 	call	0xc8a	; 0xc8a <UART_voidSendString>
				break;
				
				}
	 }
	 
	 Local_Uart_check = Local_Uart_state ; 
    39a8:	80 91 0c 02 	lds	r24, 0x020C
    39ac:	80 93 0d 02 	sts	0x020D, r24
	
	
	
}
    39b0:	ef 96       	adiw	r28, 0x3f	; 63
    39b2:	0f b6       	in	r0, 0x3f	; 63
    39b4:	f8 94       	cli
    39b6:	de bf       	out	0x3e, r29	; 62
    39b8:	0f be       	out	0x3f, r0	; 63
    39ba:	cd bf       	out	0x3d, r28	; 61
    39bc:	cf 91       	pop	r28
    39be:	df 91       	pop	r29
    39c0:	1f 91       	pop	r17
    39c2:	0f 91       	pop	r16
    39c4:	08 95       	ret

000039c6 <MAIN_MENU_ISR>:


// interrupt service routine function to retun to main menu 
void MAIN_MENU_ISR(void)
{
    39c6:	df 93       	push	r29
    39c8:	cf 93       	push	r28
    39ca:	cd b7       	in	r28, 0x3d	; 61
    39cc:	de b7       	in	r29, 0x3e	; 62
	GLOBAL_u8SELECTOR='0'; 
    39ce:	80 e3       	ldi	r24, 0x30	; 48
    39d0:	80 93 fe 01 	sts	0x01FE, r24
}
    39d4:	cf 91       	pop	r28
    39d6:	df 91       	pop	r29
    39d8:	08 95       	ret

000039da <STORE_voidTEMPRATURE>:
#include <util/delay.h>
extern u8 GLOBAL_u8SELECTOR ; 


void STORE_voidTEMPRATURE(void)
{
    39da:	df 93       	push	r29
    39dc:	cf 93       	push	r28
    39de:	cd b7       	in	r28, 0x3d	; 61
    39e0:	de b7       	in	r29, 0x3e	; 62
    39e2:	e8 97       	sbiw	r28, 0x38	; 56
    39e4:	0f b6       	in	r0, 0x3f	; 63
    39e6:	f8 94       	cli
    39e8:	de bf       	out	0x3e, r29	; 62
    39ea:	0f be       	out	0x3f, r0	; 63
    39ec:	cd bf       	out	0x3d, r28	; 61
     static volatile u8 copy_TempHigh=0, copy_TempLow=0,tempr;

	do
	{
		CLCD_vidClearLcd();
    39ee:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
		
		CLCD_vidSednString("ENTER HIGH TEMP");  // LCD display string
    39f2:	89 e6       	ldi	r24, 0x69	; 105
    39f4:	91 e0       	ldi	r25, 0x01	; 1
    39f6:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
		copy_TempHigh= KEYPAD_u8GetValue();     // key pad get value from user
    39fa:	0e 94 33 10 	call	0x2066	; 0x2066 <KEYPAD_u8GetValue>
    39fe:	80 93 10 02 	sts	0x0210, r24
		CLCD_vidGoToXY(LCD_ROW2,LCD_COL1);
    3a02:	81 e0       	ldi	r24, 0x01	; 1
    3a04:	60 e0       	ldi	r22, 0x00	; 0
    3a06:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
		CLCD_vidSednString("ENTER LOW TEMP");
    3a0a:	89 e7       	ldi	r24, 0x79	; 121
    3a0c:	91 e0       	ldi	r25, 0x01	; 1
    3a0e:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
		copy_TempLow= KEYPAD_u8GetValue();
    3a12:	0e 94 33 10 	call	0x2066	; 0x2066 <KEYPAD_u8GetValue>
    3a16:	80 93 0f 02 	sts	0x020F, r24
	    CLCD_vidSendLargeNmber(copy_TempLow); 
    3a1a:	80 91 0f 02 	lds	r24, 0x020F
    3a1e:	88 2f       	mov	r24, r24
    3a20:	90 e0       	ldi	r25, 0x00	; 0
    3a22:	a0 e0       	ldi	r26, 0x00	; 0
    3a24:	b0 e0       	ldi	r27, 0x00	; 0
    3a26:	bc 01       	movw	r22, r24
    3a28:	cd 01       	movw	r24, r26
    3a2a:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <CLCD_vidSendLargeNmber>
		EEPROM_write(BY_PASS_TEMP,EEPROM_ADRESS,copy_TempLow);
    3a2e:	90 91 0f 02 	lds	r25, 0x020F
    3a32:	88 e2       	ldi	r24, 0x28	; 40
    3a34:	60 ea       	ldi	r22, 0xA0	; 160
    3a36:	49 2f       	mov	r20, r25
    3a38:	0e 94 81 10 	call	0x2102	; 0x2102 <EEPROM_write>
		
		if (GLOBAL_u8SELECTOR=='0')             /*check if interrupt has done */
    3a3c:	80 91 fe 01 	lds	r24, 0x01FE
    3a40:	80 33       	cpi	r24, 0x30	; 48
    3a42:	21 f4       	brne	.+8      	; 0x3a4c <STORE_voidTEMPRATURE+0x72>
		{
			GLOBAL_u8SELECTOR='1';              /*return to the main_menu*/
    3a44:	81 e3       	ldi	r24, 0x31	; 49
    3a46:	80 93 fe 01 	sts	0x01FE, r24
    3a4a:	21 c2       	rjmp	.+1090   	; 0x3e8e <STORE_voidTEMPRATURE+0x4b4>
			break;
		}
		
       /*display the given high,low temp on  screen */
		CLCD_vidClearLcd();
    3a4c:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
		CLCD_vidSednString("HIGH_TEMP= ");
    3a50:	88 e8       	ldi	r24, 0x88	; 136
    3a52:	91 e0       	ldi	r25, 0x01	; 1
    3a54:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
		CLCD_vidSendLargeNmber(copy_TempHigh);
    3a58:	80 91 10 02 	lds	r24, 0x0210
    3a5c:	88 2f       	mov	r24, r24
    3a5e:	90 e0       	ldi	r25, 0x00	; 0
    3a60:	a0 e0       	ldi	r26, 0x00	; 0
    3a62:	b0 e0       	ldi	r27, 0x00	; 0
    3a64:	bc 01       	movw	r22, r24
    3a66:	cd 01       	movw	r24, r26
    3a68:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <CLCD_vidSendLargeNmber>
		CLCD_vidGoToXY(LCD_ROW2,LCD_COL1);
    3a6c:	81 e0       	ldi	r24, 0x01	; 1
    3a6e:	60 e0       	ldi	r22, 0x00	; 0
    3a70:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
		CLCD_vidSednString("LOW_TEMP= ");
    3a74:	84 e9       	ldi	r24, 0x94	; 148
    3a76:	91 e0       	ldi	r25, 0x01	; 1
    3a78:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
		CLCD_vidSendLargeNmber(copy_TempLow);
    3a7c:	80 91 0f 02 	lds	r24, 0x020F
    3a80:	88 2f       	mov	r24, r24
    3a82:	90 e0       	ldi	r25, 0x00	; 0
    3a84:	a0 e0       	ldi	r26, 0x00	; 0
    3a86:	b0 e0       	ldi	r27, 0x00	; 0
    3a88:	bc 01       	movw	r22, r24
    3a8a:	cd 01       	movw	r24, r26
    3a8c:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <CLCD_vidSendLargeNmber>
    3a90:	80 e0       	ldi	r24, 0x00	; 0
    3a92:	90 e0       	ldi	r25, 0x00	; 0
    3a94:	aa ef       	ldi	r26, 0xFA	; 250
    3a96:	b3 e4       	ldi	r27, 0x43	; 67
    3a98:	8d ab       	std	Y+53, r24	; 0x35
    3a9a:	9e ab       	std	Y+54, r25	; 0x36
    3a9c:	af ab       	std	Y+55, r26	; 0x37
    3a9e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3aa0:	6d a9       	ldd	r22, Y+53	; 0x35
    3aa2:	7e a9       	ldd	r23, Y+54	; 0x36
    3aa4:	8f a9       	ldd	r24, Y+55	; 0x37
    3aa6:	98 ad       	ldd	r25, Y+56	; 0x38
    3aa8:	20 e0       	ldi	r18, 0x00	; 0
    3aaa:	30 e0       	ldi	r19, 0x00	; 0
    3aac:	4a ef       	ldi	r20, 0xFA	; 250
    3aae:	54 e4       	ldi	r21, 0x44	; 68
    3ab0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3ab4:	dc 01       	movw	r26, r24
    3ab6:	cb 01       	movw	r24, r22
    3ab8:	89 ab       	std	Y+49, r24	; 0x31
    3aba:	9a ab       	std	Y+50, r25	; 0x32
    3abc:	ab ab       	std	Y+51, r26	; 0x33
    3abe:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    3ac0:	69 a9       	ldd	r22, Y+49	; 0x31
    3ac2:	7a a9       	ldd	r23, Y+50	; 0x32
    3ac4:	8b a9       	ldd	r24, Y+51	; 0x33
    3ac6:	9c a9       	ldd	r25, Y+52	; 0x34
    3ac8:	20 e0       	ldi	r18, 0x00	; 0
    3aca:	30 e0       	ldi	r19, 0x00	; 0
    3acc:	40 e8       	ldi	r20, 0x80	; 128
    3ace:	5f e3       	ldi	r21, 0x3F	; 63
    3ad0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3ad4:	88 23       	and	r24, r24
    3ad6:	2c f4       	brge	.+10     	; 0x3ae2 <STORE_voidTEMPRATURE+0x108>
		__ticks = 1;
    3ad8:	81 e0       	ldi	r24, 0x01	; 1
    3ada:	90 e0       	ldi	r25, 0x00	; 0
    3adc:	98 ab       	std	Y+48, r25	; 0x30
    3ade:	8f a7       	std	Y+47, r24	; 0x2f
    3ae0:	3f c0       	rjmp	.+126    	; 0x3b60 <STORE_voidTEMPRATURE+0x186>
	else if (__tmp > 65535)
    3ae2:	69 a9       	ldd	r22, Y+49	; 0x31
    3ae4:	7a a9       	ldd	r23, Y+50	; 0x32
    3ae6:	8b a9       	ldd	r24, Y+51	; 0x33
    3ae8:	9c a9       	ldd	r25, Y+52	; 0x34
    3aea:	20 e0       	ldi	r18, 0x00	; 0
    3aec:	3f ef       	ldi	r19, 0xFF	; 255
    3aee:	4f e7       	ldi	r20, 0x7F	; 127
    3af0:	57 e4       	ldi	r21, 0x47	; 71
    3af2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3af6:	18 16       	cp	r1, r24
    3af8:	4c f5       	brge	.+82     	; 0x3b4c <STORE_voidTEMPRATURE+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3afa:	6d a9       	ldd	r22, Y+53	; 0x35
    3afc:	7e a9       	ldd	r23, Y+54	; 0x36
    3afe:	8f a9       	ldd	r24, Y+55	; 0x37
    3b00:	98 ad       	ldd	r25, Y+56	; 0x38
    3b02:	20 e0       	ldi	r18, 0x00	; 0
    3b04:	30 e0       	ldi	r19, 0x00	; 0
    3b06:	40 e2       	ldi	r20, 0x20	; 32
    3b08:	51 e4       	ldi	r21, 0x41	; 65
    3b0a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3b0e:	dc 01       	movw	r26, r24
    3b10:	cb 01       	movw	r24, r22
    3b12:	bc 01       	movw	r22, r24
    3b14:	cd 01       	movw	r24, r26
    3b16:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3b1a:	dc 01       	movw	r26, r24
    3b1c:	cb 01       	movw	r24, r22
    3b1e:	98 ab       	std	Y+48, r25	; 0x30
    3b20:	8f a7       	std	Y+47, r24	; 0x2f
    3b22:	0f c0       	rjmp	.+30     	; 0x3b42 <STORE_voidTEMPRATURE+0x168>
    3b24:	88 ec       	ldi	r24, 0xC8	; 200
    3b26:	90 e0       	ldi	r25, 0x00	; 0
    3b28:	9e a7       	std	Y+46, r25	; 0x2e
    3b2a:	8d a7       	std	Y+45, r24	; 0x2d
    3b2c:	8d a5       	ldd	r24, Y+45	; 0x2d
    3b2e:	9e a5       	ldd	r25, Y+46	; 0x2e
    3b30:	01 97       	sbiw	r24, 0x01	; 1
    3b32:	f1 f7       	brne	.-4      	; 0x3b30 <STORE_voidTEMPRATURE+0x156>
    3b34:	9e a7       	std	Y+46, r25	; 0x2e
    3b36:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3b38:	8f a5       	ldd	r24, Y+47	; 0x2f
    3b3a:	98 a9       	ldd	r25, Y+48	; 0x30
    3b3c:	01 97       	sbiw	r24, 0x01	; 1
    3b3e:	98 ab       	std	Y+48, r25	; 0x30
    3b40:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3b42:	8f a5       	ldd	r24, Y+47	; 0x2f
    3b44:	98 a9       	ldd	r25, Y+48	; 0x30
    3b46:	00 97       	sbiw	r24, 0x00	; 0
    3b48:	69 f7       	brne	.-38     	; 0x3b24 <STORE_voidTEMPRATURE+0x14a>
    3b4a:	14 c0       	rjmp	.+40     	; 0x3b74 <STORE_voidTEMPRATURE+0x19a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3b4c:	69 a9       	ldd	r22, Y+49	; 0x31
    3b4e:	7a a9       	ldd	r23, Y+50	; 0x32
    3b50:	8b a9       	ldd	r24, Y+51	; 0x33
    3b52:	9c a9       	ldd	r25, Y+52	; 0x34
    3b54:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3b58:	dc 01       	movw	r26, r24
    3b5a:	cb 01       	movw	r24, r22
    3b5c:	98 ab       	std	Y+48, r25	; 0x30
    3b5e:	8f a7       	std	Y+47, r24	; 0x2f
    3b60:	8f a5       	ldd	r24, Y+47	; 0x2f
    3b62:	98 a9       	ldd	r25, Y+48	; 0x30
    3b64:	9c a7       	std	Y+44, r25	; 0x2c
    3b66:	8b a7       	std	Y+43, r24	; 0x2b
    3b68:	8b a5       	ldd	r24, Y+43	; 0x2b
    3b6a:	9c a5       	ldd	r25, Y+44	; 0x2c
    3b6c:	01 97       	sbiw	r24, 0x01	; 1
    3b6e:	f1 f7       	brne	.-4      	; 0x3b6c <STORE_voidTEMPRATURE+0x192>
    3b70:	9c a7       	std	Y+44, r25	; 0x2c
    3b72:	8b a7       	std	Y+43, r24	; 0x2b
		_delay_ms(500); 
		
     	/*check if low > high that will not accept the opertaion */
		if (copy_TempHigh<=copy_TempLow)
    3b74:	90 91 10 02 	lds	r25, 0x0210
    3b78:	80 91 0f 02 	lds	r24, 0x020F
    3b7c:	89 17       	cp	r24, r25
    3b7e:	08 f4       	brcc	.+2      	; 0x3b82 <STORE_voidTEMPRATURE+0x1a8>
    3b80:	85 c0       	rjmp	.+266    	; 0x3c8c <STORE_voidTEMPRATURE+0x2b2>
		{
			CLCD_vidClearLcd(); 
    3b82:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
			CLCD_vidGoToXY(LCD_ROW1,LCD_COL8);
    3b86:	80 e0       	ldi	r24, 0x00	; 0
    3b88:	67 e0       	ldi	r22, 0x07	; 7
    3b8a:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
			CLCD_vidSednString(" WRONG! ");
    3b8e:	8f e9       	ldi	r24, 0x9F	; 159
    3b90:	91 e0       	ldi	r25, 0x01	; 1
    3b92:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
			CLCD_vidGoToXY(LCD_ROW2,LCD_COL1);
    3b96:	81 e0       	ldi	r24, 0x01	; 1
    3b98:	60 e0       	ldi	r22, 0x00	; 0
    3b9a:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
			CLCD_vidSednString("ENTER T_H > T_L");
    3b9e:	88 ea       	ldi	r24, 0xA8	; 168
    3ba0:	91 e0       	ldi	r25, 0x01	; 1
    3ba2:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
    3ba6:	80 e0       	ldi	r24, 0x00	; 0
    3ba8:	90 e0       	ldi	r25, 0x00	; 0
    3baa:	aa ef       	ldi	r26, 0xFA	; 250
    3bac:	b3 e4       	ldi	r27, 0x43	; 67
    3bae:	8f a3       	std	Y+39, r24	; 0x27
    3bb0:	98 a7       	std	Y+40, r25	; 0x28
    3bb2:	a9 a7       	std	Y+41, r26	; 0x29
    3bb4:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3bb6:	6f a1       	ldd	r22, Y+39	; 0x27
    3bb8:	78 a5       	ldd	r23, Y+40	; 0x28
    3bba:	89 a5       	ldd	r24, Y+41	; 0x29
    3bbc:	9a a5       	ldd	r25, Y+42	; 0x2a
    3bbe:	20 e0       	ldi	r18, 0x00	; 0
    3bc0:	30 e0       	ldi	r19, 0x00	; 0
    3bc2:	4a ef       	ldi	r20, 0xFA	; 250
    3bc4:	54 e4       	ldi	r21, 0x44	; 68
    3bc6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3bca:	dc 01       	movw	r26, r24
    3bcc:	cb 01       	movw	r24, r22
    3bce:	8b a3       	std	Y+35, r24	; 0x23
    3bd0:	9c a3       	std	Y+36, r25	; 0x24
    3bd2:	ad a3       	std	Y+37, r26	; 0x25
    3bd4:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    3bd6:	6b a1       	ldd	r22, Y+35	; 0x23
    3bd8:	7c a1       	ldd	r23, Y+36	; 0x24
    3bda:	8d a1       	ldd	r24, Y+37	; 0x25
    3bdc:	9e a1       	ldd	r25, Y+38	; 0x26
    3bde:	20 e0       	ldi	r18, 0x00	; 0
    3be0:	30 e0       	ldi	r19, 0x00	; 0
    3be2:	40 e8       	ldi	r20, 0x80	; 128
    3be4:	5f e3       	ldi	r21, 0x3F	; 63
    3be6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3bea:	88 23       	and	r24, r24
    3bec:	2c f4       	brge	.+10     	; 0x3bf8 <STORE_voidTEMPRATURE+0x21e>
		__ticks = 1;
    3bee:	81 e0       	ldi	r24, 0x01	; 1
    3bf0:	90 e0       	ldi	r25, 0x00	; 0
    3bf2:	9a a3       	std	Y+34, r25	; 0x22
    3bf4:	89 a3       	std	Y+33, r24	; 0x21
    3bf6:	3f c0       	rjmp	.+126    	; 0x3c76 <STORE_voidTEMPRATURE+0x29c>
	else if (__tmp > 65535)
    3bf8:	6b a1       	ldd	r22, Y+35	; 0x23
    3bfa:	7c a1       	ldd	r23, Y+36	; 0x24
    3bfc:	8d a1       	ldd	r24, Y+37	; 0x25
    3bfe:	9e a1       	ldd	r25, Y+38	; 0x26
    3c00:	20 e0       	ldi	r18, 0x00	; 0
    3c02:	3f ef       	ldi	r19, 0xFF	; 255
    3c04:	4f e7       	ldi	r20, 0x7F	; 127
    3c06:	57 e4       	ldi	r21, 0x47	; 71
    3c08:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3c0c:	18 16       	cp	r1, r24
    3c0e:	4c f5       	brge	.+82     	; 0x3c62 <STORE_voidTEMPRATURE+0x288>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3c10:	6f a1       	ldd	r22, Y+39	; 0x27
    3c12:	78 a5       	ldd	r23, Y+40	; 0x28
    3c14:	89 a5       	ldd	r24, Y+41	; 0x29
    3c16:	9a a5       	ldd	r25, Y+42	; 0x2a
    3c18:	20 e0       	ldi	r18, 0x00	; 0
    3c1a:	30 e0       	ldi	r19, 0x00	; 0
    3c1c:	40 e2       	ldi	r20, 0x20	; 32
    3c1e:	51 e4       	ldi	r21, 0x41	; 65
    3c20:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3c24:	dc 01       	movw	r26, r24
    3c26:	cb 01       	movw	r24, r22
    3c28:	bc 01       	movw	r22, r24
    3c2a:	cd 01       	movw	r24, r26
    3c2c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3c30:	dc 01       	movw	r26, r24
    3c32:	cb 01       	movw	r24, r22
    3c34:	9a a3       	std	Y+34, r25	; 0x22
    3c36:	89 a3       	std	Y+33, r24	; 0x21
    3c38:	0f c0       	rjmp	.+30     	; 0x3c58 <STORE_voidTEMPRATURE+0x27e>
    3c3a:	88 ec       	ldi	r24, 0xC8	; 200
    3c3c:	90 e0       	ldi	r25, 0x00	; 0
    3c3e:	98 a3       	std	Y+32, r25	; 0x20
    3c40:	8f 8f       	std	Y+31, r24	; 0x1f
    3c42:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3c44:	98 a1       	ldd	r25, Y+32	; 0x20
    3c46:	01 97       	sbiw	r24, 0x01	; 1
    3c48:	f1 f7       	brne	.-4      	; 0x3c46 <STORE_voidTEMPRATURE+0x26c>
    3c4a:	98 a3       	std	Y+32, r25	; 0x20
    3c4c:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3c4e:	89 a1       	ldd	r24, Y+33	; 0x21
    3c50:	9a a1       	ldd	r25, Y+34	; 0x22
    3c52:	01 97       	sbiw	r24, 0x01	; 1
    3c54:	9a a3       	std	Y+34, r25	; 0x22
    3c56:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3c58:	89 a1       	ldd	r24, Y+33	; 0x21
    3c5a:	9a a1       	ldd	r25, Y+34	; 0x22
    3c5c:	00 97       	sbiw	r24, 0x00	; 0
    3c5e:	69 f7       	brne	.-38     	; 0x3c3a <STORE_voidTEMPRATURE+0x260>
    3c60:	0f c1       	rjmp	.+542    	; 0x3e80 <STORE_voidTEMPRATURE+0x4a6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3c62:	6b a1       	ldd	r22, Y+35	; 0x23
    3c64:	7c a1       	ldd	r23, Y+36	; 0x24
    3c66:	8d a1       	ldd	r24, Y+37	; 0x25
    3c68:	9e a1       	ldd	r25, Y+38	; 0x26
    3c6a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3c6e:	dc 01       	movw	r26, r24
    3c70:	cb 01       	movw	r24, r22
    3c72:	9a a3       	std	Y+34, r25	; 0x22
    3c74:	89 a3       	std	Y+33, r24	; 0x21
    3c76:	89 a1       	ldd	r24, Y+33	; 0x21
    3c78:	9a a1       	ldd	r25, Y+34	; 0x22
    3c7a:	9e 8f       	std	Y+30, r25	; 0x1e
    3c7c:	8d 8f       	std	Y+29, r24	; 0x1d
    3c7e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3c80:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3c82:	01 97       	sbiw	r24, 0x01	; 1
    3c84:	f1 f7       	brne	.-4      	; 0x3c82 <STORE_voidTEMPRATURE+0x2a8>
    3c86:	9e 8f       	std	Y+30, r25	; 0x1e
    3c88:	8d 8f       	std	Y+29, r24	; 0x1d
    3c8a:	fa c0       	rjmp	.+500    	; 0x3e80 <STORE_voidTEMPRATURE+0x4a6>
		}
	   /*check if low <high that will  accept the opertaion */
		else
		{
			
			EEPROM_write( HIGH_TEMP_u8LOCATION,HIGH_TEMP_u8ADRESS,copy_TempHigh);
    3c8c:	90 91 10 02 	lds	r25, 0x0210
    3c90:	82 e2       	ldi	r24, 0x22	; 34
    3c92:	60 ea       	ldi	r22, 0xA0	; 160
    3c94:	49 2f       	mov	r20, r25
    3c96:	0e 94 81 10 	call	0x2102	; 0x2102 <EEPROM_write>
    3c9a:	80 e0       	ldi	r24, 0x00	; 0
    3c9c:	90 e0       	ldi	r25, 0x00	; 0
    3c9e:	a8 ec       	ldi	r26, 0xC8	; 200
    3ca0:	b2 e4       	ldi	r27, 0x42	; 66
    3ca2:	89 8f       	std	Y+25, r24	; 0x19
    3ca4:	9a 8f       	std	Y+26, r25	; 0x1a
    3ca6:	ab 8f       	std	Y+27, r26	; 0x1b
    3ca8:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3caa:	69 8d       	ldd	r22, Y+25	; 0x19
    3cac:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3cae:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3cb0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3cb2:	20 e0       	ldi	r18, 0x00	; 0
    3cb4:	30 e0       	ldi	r19, 0x00	; 0
    3cb6:	4a ef       	ldi	r20, 0xFA	; 250
    3cb8:	54 e4       	ldi	r21, 0x44	; 68
    3cba:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3cbe:	dc 01       	movw	r26, r24
    3cc0:	cb 01       	movw	r24, r22
    3cc2:	8d 8b       	std	Y+21, r24	; 0x15
    3cc4:	9e 8b       	std	Y+22, r25	; 0x16
    3cc6:	af 8b       	std	Y+23, r26	; 0x17
    3cc8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3cca:	6d 89       	ldd	r22, Y+21	; 0x15
    3ccc:	7e 89       	ldd	r23, Y+22	; 0x16
    3cce:	8f 89       	ldd	r24, Y+23	; 0x17
    3cd0:	98 8d       	ldd	r25, Y+24	; 0x18
    3cd2:	20 e0       	ldi	r18, 0x00	; 0
    3cd4:	30 e0       	ldi	r19, 0x00	; 0
    3cd6:	40 e8       	ldi	r20, 0x80	; 128
    3cd8:	5f e3       	ldi	r21, 0x3F	; 63
    3cda:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3cde:	88 23       	and	r24, r24
    3ce0:	2c f4       	brge	.+10     	; 0x3cec <STORE_voidTEMPRATURE+0x312>
		__ticks = 1;
    3ce2:	81 e0       	ldi	r24, 0x01	; 1
    3ce4:	90 e0       	ldi	r25, 0x00	; 0
    3ce6:	9c 8b       	std	Y+20, r25	; 0x14
    3ce8:	8b 8b       	std	Y+19, r24	; 0x13
    3cea:	3f c0       	rjmp	.+126    	; 0x3d6a <STORE_voidTEMPRATURE+0x390>
	else if (__tmp > 65535)
    3cec:	6d 89       	ldd	r22, Y+21	; 0x15
    3cee:	7e 89       	ldd	r23, Y+22	; 0x16
    3cf0:	8f 89       	ldd	r24, Y+23	; 0x17
    3cf2:	98 8d       	ldd	r25, Y+24	; 0x18
    3cf4:	20 e0       	ldi	r18, 0x00	; 0
    3cf6:	3f ef       	ldi	r19, 0xFF	; 255
    3cf8:	4f e7       	ldi	r20, 0x7F	; 127
    3cfa:	57 e4       	ldi	r21, 0x47	; 71
    3cfc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3d00:	18 16       	cp	r1, r24
    3d02:	4c f5       	brge	.+82     	; 0x3d56 <STORE_voidTEMPRATURE+0x37c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3d04:	69 8d       	ldd	r22, Y+25	; 0x19
    3d06:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3d08:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3d0a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3d0c:	20 e0       	ldi	r18, 0x00	; 0
    3d0e:	30 e0       	ldi	r19, 0x00	; 0
    3d10:	40 e2       	ldi	r20, 0x20	; 32
    3d12:	51 e4       	ldi	r21, 0x41	; 65
    3d14:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3d18:	dc 01       	movw	r26, r24
    3d1a:	cb 01       	movw	r24, r22
    3d1c:	bc 01       	movw	r22, r24
    3d1e:	cd 01       	movw	r24, r26
    3d20:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d24:	dc 01       	movw	r26, r24
    3d26:	cb 01       	movw	r24, r22
    3d28:	9c 8b       	std	Y+20, r25	; 0x14
    3d2a:	8b 8b       	std	Y+19, r24	; 0x13
    3d2c:	0f c0       	rjmp	.+30     	; 0x3d4c <STORE_voidTEMPRATURE+0x372>
    3d2e:	88 ec       	ldi	r24, 0xC8	; 200
    3d30:	90 e0       	ldi	r25, 0x00	; 0
    3d32:	9a 8b       	std	Y+18, r25	; 0x12
    3d34:	89 8b       	std	Y+17, r24	; 0x11
    3d36:	89 89       	ldd	r24, Y+17	; 0x11
    3d38:	9a 89       	ldd	r25, Y+18	; 0x12
    3d3a:	01 97       	sbiw	r24, 0x01	; 1
    3d3c:	f1 f7       	brne	.-4      	; 0x3d3a <STORE_voidTEMPRATURE+0x360>
    3d3e:	9a 8b       	std	Y+18, r25	; 0x12
    3d40:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3d42:	8b 89       	ldd	r24, Y+19	; 0x13
    3d44:	9c 89       	ldd	r25, Y+20	; 0x14
    3d46:	01 97       	sbiw	r24, 0x01	; 1
    3d48:	9c 8b       	std	Y+20, r25	; 0x14
    3d4a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3d4c:	8b 89       	ldd	r24, Y+19	; 0x13
    3d4e:	9c 89       	ldd	r25, Y+20	; 0x14
    3d50:	00 97       	sbiw	r24, 0x00	; 0
    3d52:	69 f7       	brne	.-38     	; 0x3d2e <STORE_voidTEMPRATURE+0x354>
    3d54:	14 c0       	rjmp	.+40     	; 0x3d7e <STORE_voidTEMPRATURE+0x3a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3d56:	6d 89       	ldd	r22, Y+21	; 0x15
    3d58:	7e 89       	ldd	r23, Y+22	; 0x16
    3d5a:	8f 89       	ldd	r24, Y+23	; 0x17
    3d5c:	98 8d       	ldd	r25, Y+24	; 0x18
    3d5e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d62:	dc 01       	movw	r26, r24
    3d64:	cb 01       	movw	r24, r22
    3d66:	9c 8b       	std	Y+20, r25	; 0x14
    3d68:	8b 8b       	std	Y+19, r24	; 0x13
    3d6a:	8b 89       	ldd	r24, Y+19	; 0x13
    3d6c:	9c 89       	ldd	r25, Y+20	; 0x14
    3d6e:	98 8b       	std	Y+16, r25	; 0x10
    3d70:	8f 87       	std	Y+15, r24	; 0x0f
    3d72:	8f 85       	ldd	r24, Y+15	; 0x0f
    3d74:	98 89       	ldd	r25, Y+16	; 0x10
    3d76:	01 97       	sbiw	r24, 0x01	; 1
    3d78:	f1 f7       	brne	.-4      	; 0x3d76 <STORE_voidTEMPRATURE+0x39c>
    3d7a:	98 8b       	std	Y+16, r25	; 0x10
    3d7c:	8f 87       	std	Y+15, r24	; 0x0f
			_delay_ms(100);
			EEPROM_write( LOW_TEMP_u8LOCATION, LOW_TEMP_u8ADRESS,copy_TempLow);
    3d7e:	90 91 0f 02 	lds	r25, 0x020F
    3d82:	80 e1       	ldi	r24, 0x10	; 16
    3d84:	60 ea       	ldi	r22, 0xA0	; 160
    3d86:	49 2f       	mov	r20, r25
    3d88:	0e 94 81 10 	call	0x2102	; 0x2102 <EEPROM_write>
			CLCD_vidClearLcd();
    3d8c:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
			CLCD_vidSednString("STORE SUCCSSES");
    3d90:	88 eb       	ldi	r24, 0xB8	; 184
    3d92:	91 e0       	ldi	r25, 0x01	; 1
    3d94:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
    3d98:	80 e0       	ldi	r24, 0x00	; 0
    3d9a:	90 e0       	ldi	r25, 0x00	; 0
    3d9c:	aa ef       	ldi	r26, 0xFA	; 250
    3d9e:	b3 e4       	ldi	r27, 0x43	; 67
    3da0:	8b 87       	std	Y+11, r24	; 0x0b
    3da2:	9c 87       	std	Y+12, r25	; 0x0c
    3da4:	ad 87       	std	Y+13, r26	; 0x0d
    3da6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3da8:	6b 85       	ldd	r22, Y+11	; 0x0b
    3daa:	7c 85       	ldd	r23, Y+12	; 0x0c
    3dac:	8d 85       	ldd	r24, Y+13	; 0x0d
    3dae:	9e 85       	ldd	r25, Y+14	; 0x0e
    3db0:	20 e0       	ldi	r18, 0x00	; 0
    3db2:	30 e0       	ldi	r19, 0x00	; 0
    3db4:	4a ef       	ldi	r20, 0xFA	; 250
    3db6:	54 e4       	ldi	r21, 0x44	; 68
    3db8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3dbc:	dc 01       	movw	r26, r24
    3dbe:	cb 01       	movw	r24, r22
    3dc0:	8f 83       	std	Y+7, r24	; 0x07
    3dc2:	98 87       	std	Y+8, r25	; 0x08
    3dc4:	a9 87       	std	Y+9, r26	; 0x09
    3dc6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3dc8:	6f 81       	ldd	r22, Y+7	; 0x07
    3dca:	78 85       	ldd	r23, Y+8	; 0x08
    3dcc:	89 85       	ldd	r24, Y+9	; 0x09
    3dce:	9a 85       	ldd	r25, Y+10	; 0x0a
    3dd0:	20 e0       	ldi	r18, 0x00	; 0
    3dd2:	30 e0       	ldi	r19, 0x00	; 0
    3dd4:	40 e8       	ldi	r20, 0x80	; 128
    3dd6:	5f e3       	ldi	r21, 0x3F	; 63
    3dd8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3ddc:	88 23       	and	r24, r24
    3dde:	2c f4       	brge	.+10     	; 0x3dea <STORE_voidTEMPRATURE+0x410>
		__ticks = 1;
    3de0:	81 e0       	ldi	r24, 0x01	; 1
    3de2:	90 e0       	ldi	r25, 0x00	; 0
    3de4:	9e 83       	std	Y+6, r25	; 0x06
    3de6:	8d 83       	std	Y+5, r24	; 0x05
    3de8:	3f c0       	rjmp	.+126    	; 0x3e68 <STORE_voidTEMPRATURE+0x48e>
	else if (__tmp > 65535)
    3dea:	6f 81       	ldd	r22, Y+7	; 0x07
    3dec:	78 85       	ldd	r23, Y+8	; 0x08
    3dee:	89 85       	ldd	r24, Y+9	; 0x09
    3df0:	9a 85       	ldd	r25, Y+10	; 0x0a
    3df2:	20 e0       	ldi	r18, 0x00	; 0
    3df4:	3f ef       	ldi	r19, 0xFF	; 255
    3df6:	4f e7       	ldi	r20, 0x7F	; 127
    3df8:	57 e4       	ldi	r21, 0x47	; 71
    3dfa:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3dfe:	18 16       	cp	r1, r24
    3e00:	4c f5       	brge	.+82     	; 0x3e54 <STORE_voidTEMPRATURE+0x47a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3e02:	6b 85       	ldd	r22, Y+11	; 0x0b
    3e04:	7c 85       	ldd	r23, Y+12	; 0x0c
    3e06:	8d 85       	ldd	r24, Y+13	; 0x0d
    3e08:	9e 85       	ldd	r25, Y+14	; 0x0e
    3e0a:	20 e0       	ldi	r18, 0x00	; 0
    3e0c:	30 e0       	ldi	r19, 0x00	; 0
    3e0e:	40 e2       	ldi	r20, 0x20	; 32
    3e10:	51 e4       	ldi	r21, 0x41	; 65
    3e12:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3e16:	dc 01       	movw	r26, r24
    3e18:	cb 01       	movw	r24, r22
    3e1a:	bc 01       	movw	r22, r24
    3e1c:	cd 01       	movw	r24, r26
    3e1e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3e22:	dc 01       	movw	r26, r24
    3e24:	cb 01       	movw	r24, r22
    3e26:	9e 83       	std	Y+6, r25	; 0x06
    3e28:	8d 83       	std	Y+5, r24	; 0x05
    3e2a:	0f c0       	rjmp	.+30     	; 0x3e4a <STORE_voidTEMPRATURE+0x470>
    3e2c:	88 ec       	ldi	r24, 0xC8	; 200
    3e2e:	90 e0       	ldi	r25, 0x00	; 0
    3e30:	9c 83       	std	Y+4, r25	; 0x04
    3e32:	8b 83       	std	Y+3, r24	; 0x03
    3e34:	8b 81       	ldd	r24, Y+3	; 0x03
    3e36:	9c 81       	ldd	r25, Y+4	; 0x04
    3e38:	01 97       	sbiw	r24, 0x01	; 1
    3e3a:	f1 f7       	brne	.-4      	; 0x3e38 <STORE_voidTEMPRATURE+0x45e>
    3e3c:	9c 83       	std	Y+4, r25	; 0x04
    3e3e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3e40:	8d 81       	ldd	r24, Y+5	; 0x05
    3e42:	9e 81       	ldd	r25, Y+6	; 0x06
    3e44:	01 97       	sbiw	r24, 0x01	; 1
    3e46:	9e 83       	std	Y+6, r25	; 0x06
    3e48:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3e4a:	8d 81       	ldd	r24, Y+5	; 0x05
    3e4c:	9e 81       	ldd	r25, Y+6	; 0x06
    3e4e:	00 97       	sbiw	r24, 0x00	; 0
    3e50:	69 f7       	brne	.-38     	; 0x3e2c <STORE_voidTEMPRATURE+0x452>
    3e52:	14 c0       	rjmp	.+40     	; 0x3e7c <STORE_voidTEMPRATURE+0x4a2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3e54:	6f 81       	ldd	r22, Y+7	; 0x07
    3e56:	78 85       	ldd	r23, Y+8	; 0x08
    3e58:	89 85       	ldd	r24, Y+9	; 0x09
    3e5a:	9a 85       	ldd	r25, Y+10	; 0x0a
    3e5c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3e60:	dc 01       	movw	r26, r24
    3e62:	cb 01       	movw	r24, r22
    3e64:	9e 83       	std	Y+6, r25	; 0x06
    3e66:	8d 83       	std	Y+5, r24	; 0x05
    3e68:	8d 81       	ldd	r24, Y+5	; 0x05
    3e6a:	9e 81       	ldd	r25, Y+6	; 0x06
    3e6c:	9a 83       	std	Y+2, r25	; 0x02
    3e6e:	89 83       	std	Y+1, r24	; 0x01
    3e70:	89 81       	ldd	r24, Y+1	; 0x01
    3e72:	9a 81       	ldd	r25, Y+2	; 0x02
    3e74:	01 97       	sbiw	r24, 0x01	; 1
    3e76:	f1 f7       	brne	.-4      	; 0x3e74 <STORE_voidTEMPRATURE+0x49a>
    3e78:	9a 83       	std	Y+2, r25	; 0x02
    3e7a:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(500);
			CLCD_vidClearLcd();
    3e7c:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
		}
		
	} while (copy_TempHigh<=copy_TempLow);
    3e80:	90 91 10 02 	lds	r25, 0x0210
    3e84:	80 91 0f 02 	lds	r24, 0x020F
    3e88:	89 17       	cp	r24, r25
    3e8a:	08 f0       	brcs	.+2      	; 0x3e8e <STORE_voidTEMPRATURE+0x4b4>
    3e8c:	b0 cd       	rjmp	.-1184   	; 0x39ee <STORE_voidTEMPRATURE+0x14>

}
    3e8e:	e8 96       	adiw	r28, 0x38	; 56
    3e90:	0f b6       	in	r0, 0x3f	; 63
    3e92:	f8 94       	cli
    3e94:	de bf       	out	0x3e, r29	; 62
    3e96:	0f be       	out	0x3f, r0	; 63
    3e98:	cd bf       	out	0x3d, r28	; 61
    3e9a:	cf 91       	pop	r28
    3e9c:	df 91       	pop	r29
    3e9e:	08 95       	ret

00003ea0 <READ_STOR_voidTEMPARTURE>:


void READ_STOR_voidTEMPARTURE(void)
{
    3ea0:	df 93       	push	r29
    3ea2:	cf 93       	push	r28
    3ea4:	cd b7       	in	r28, 0x3d	; 61
    3ea6:	de b7       	in	r29, 0x3e	; 62
    3ea8:	6f 97       	sbiw	r28, 0x1f	; 31
    3eaa:	0f b6       	in	r0, 0x3f	; 63
    3eac:	f8 94       	cli
    3eae:	de bf       	out	0x3e, r29	; 62
    3eb0:	0f be       	out	0x3f, r0	; 63
    3eb2:	cd bf       	out	0x3d, r28	; 61
	/*local variables to store value from EEPROM */
	 u8 Local_High , Local_LOW , tempr ; 
	
	/*GET the value stored on EEPORM AND SAVE it ON variable*/
	Local_High = EEPROM_READ(HIGH_TEMP_u8LOCATION,HIGH_TEMP_u8ADRESS);
    3eb4:	82 e2       	ldi	r24, 0x22	; 34
    3eb6:	60 ea       	ldi	r22, 0xA0	; 160
    3eb8:	0e 94 18 11 	call	0x2230	; 0x2230 <EEPROM_READ>
    3ebc:	8f 8f       	std	Y+31, r24	; 0x1f
	Local_LOW = EEPROM_READ(BY_PASS_TEMP,LOW_TEMP_u8ADRESS);
    3ebe:	88 e2       	ldi	r24, 0x28	; 40
    3ec0:	60 ea       	ldi	r22, 0xA0	; 160
    3ec2:	0e 94 18 11 	call	0x2230	; 0x2230 <EEPROM_READ>
    3ec6:	8e 8f       	std	Y+30, r24	; 0x1e
	
	/*Display the stored VALUES on screen */
	CLCD_vidClearLcd();
    3ec8:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
	CLCD_vidSednString("TEMP_HIGH= "); 
    3ecc:	87 ec       	ldi	r24, 0xC7	; 199
    3ece:	91 e0       	ldi	r25, 0x01	; 1
    3ed0:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
	CLCD_vidSendLargeNmber(Local_High);
    3ed4:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3ed6:	88 2f       	mov	r24, r24
    3ed8:	90 e0       	ldi	r25, 0x00	; 0
    3eda:	a0 e0       	ldi	r26, 0x00	; 0
    3edc:	b0 e0       	ldi	r27, 0x00	; 0
    3ede:	bc 01       	movw	r22, r24
    3ee0:	cd 01       	movw	r24, r26
    3ee2:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <CLCD_vidSendLargeNmber>
    3ee6:	80 e0       	ldi	r24, 0x00	; 0
    3ee8:	90 e0       	ldi	r25, 0x00	; 0
    3eea:	a8 e4       	ldi	r26, 0x48	; 72
    3eec:	b2 e4       	ldi	r27, 0x42	; 66
    3eee:	89 8f       	std	Y+25, r24	; 0x19
    3ef0:	9a 8f       	std	Y+26, r25	; 0x1a
    3ef2:	ab 8f       	std	Y+27, r26	; 0x1b
    3ef4:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3ef6:	69 8d       	ldd	r22, Y+25	; 0x19
    3ef8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3efa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3efc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3efe:	20 e0       	ldi	r18, 0x00	; 0
    3f00:	30 e0       	ldi	r19, 0x00	; 0
    3f02:	4a ef       	ldi	r20, 0xFA	; 250
    3f04:	54 e4       	ldi	r21, 0x44	; 68
    3f06:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3f0a:	dc 01       	movw	r26, r24
    3f0c:	cb 01       	movw	r24, r22
    3f0e:	8d 8b       	std	Y+21, r24	; 0x15
    3f10:	9e 8b       	std	Y+22, r25	; 0x16
    3f12:	af 8b       	std	Y+23, r26	; 0x17
    3f14:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3f16:	6d 89       	ldd	r22, Y+21	; 0x15
    3f18:	7e 89       	ldd	r23, Y+22	; 0x16
    3f1a:	8f 89       	ldd	r24, Y+23	; 0x17
    3f1c:	98 8d       	ldd	r25, Y+24	; 0x18
    3f1e:	20 e0       	ldi	r18, 0x00	; 0
    3f20:	30 e0       	ldi	r19, 0x00	; 0
    3f22:	40 e8       	ldi	r20, 0x80	; 128
    3f24:	5f e3       	ldi	r21, 0x3F	; 63
    3f26:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3f2a:	88 23       	and	r24, r24
    3f2c:	2c f4       	brge	.+10     	; 0x3f38 <READ_STOR_voidTEMPARTURE+0x98>
		__ticks = 1;
    3f2e:	81 e0       	ldi	r24, 0x01	; 1
    3f30:	90 e0       	ldi	r25, 0x00	; 0
    3f32:	9c 8b       	std	Y+20, r25	; 0x14
    3f34:	8b 8b       	std	Y+19, r24	; 0x13
    3f36:	3f c0       	rjmp	.+126    	; 0x3fb6 <READ_STOR_voidTEMPARTURE+0x116>
	else if (__tmp > 65535)
    3f38:	6d 89       	ldd	r22, Y+21	; 0x15
    3f3a:	7e 89       	ldd	r23, Y+22	; 0x16
    3f3c:	8f 89       	ldd	r24, Y+23	; 0x17
    3f3e:	98 8d       	ldd	r25, Y+24	; 0x18
    3f40:	20 e0       	ldi	r18, 0x00	; 0
    3f42:	3f ef       	ldi	r19, 0xFF	; 255
    3f44:	4f e7       	ldi	r20, 0x7F	; 127
    3f46:	57 e4       	ldi	r21, 0x47	; 71
    3f48:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3f4c:	18 16       	cp	r1, r24
    3f4e:	4c f5       	brge	.+82     	; 0x3fa2 <READ_STOR_voidTEMPARTURE+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3f50:	69 8d       	ldd	r22, Y+25	; 0x19
    3f52:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3f54:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3f56:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3f58:	20 e0       	ldi	r18, 0x00	; 0
    3f5a:	30 e0       	ldi	r19, 0x00	; 0
    3f5c:	40 e2       	ldi	r20, 0x20	; 32
    3f5e:	51 e4       	ldi	r21, 0x41	; 65
    3f60:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3f64:	dc 01       	movw	r26, r24
    3f66:	cb 01       	movw	r24, r22
    3f68:	bc 01       	movw	r22, r24
    3f6a:	cd 01       	movw	r24, r26
    3f6c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3f70:	dc 01       	movw	r26, r24
    3f72:	cb 01       	movw	r24, r22
    3f74:	9c 8b       	std	Y+20, r25	; 0x14
    3f76:	8b 8b       	std	Y+19, r24	; 0x13
    3f78:	0f c0       	rjmp	.+30     	; 0x3f98 <READ_STOR_voidTEMPARTURE+0xf8>
    3f7a:	88 ec       	ldi	r24, 0xC8	; 200
    3f7c:	90 e0       	ldi	r25, 0x00	; 0
    3f7e:	9a 8b       	std	Y+18, r25	; 0x12
    3f80:	89 8b       	std	Y+17, r24	; 0x11
    3f82:	89 89       	ldd	r24, Y+17	; 0x11
    3f84:	9a 89       	ldd	r25, Y+18	; 0x12
    3f86:	01 97       	sbiw	r24, 0x01	; 1
    3f88:	f1 f7       	brne	.-4      	; 0x3f86 <READ_STOR_voidTEMPARTURE+0xe6>
    3f8a:	9a 8b       	std	Y+18, r25	; 0x12
    3f8c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3f8e:	8b 89       	ldd	r24, Y+19	; 0x13
    3f90:	9c 89       	ldd	r25, Y+20	; 0x14
    3f92:	01 97       	sbiw	r24, 0x01	; 1
    3f94:	9c 8b       	std	Y+20, r25	; 0x14
    3f96:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3f98:	8b 89       	ldd	r24, Y+19	; 0x13
    3f9a:	9c 89       	ldd	r25, Y+20	; 0x14
    3f9c:	00 97       	sbiw	r24, 0x00	; 0
    3f9e:	69 f7       	brne	.-38     	; 0x3f7a <READ_STOR_voidTEMPARTURE+0xda>
    3fa0:	14 c0       	rjmp	.+40     	; 0x3fca <READ_STOR_voidTEMPARTURE+0x12a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3fa2:	6d 89       	ldd	r22, Y+21	; 0x15
    3fa4:	7e 89       	ldd	r23, Y+22	; 0x16
    3fa6:	8f 89       	ldd	r24, Y+23	; 0x17
    3fa8:	98 8d       	ldd	r25, Y+24	; 0x18
    3faa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3fae:	dc 01       	movw	r26, r24
    3fb0:	cb 01       	movw	r24, r22
    3fb2:	9c 8b       	std	Y+20, r25	; 0x14
    3fb4:	8b 8b       	std	Y+19, r24	; 0x13
    3fb6:	8b 89       	ldd	r24, Y+19	; 0x13
    3fb8:	9c 89       	ldd	r25, Y+20	; 0x14
    3fba:	98 8b       	std	Y+16, r25	; 0x10
    3fbc:	8f 87       	std	Y+15, r24	; 0x0f
    3fbe:	8f 85       	ldd	r24, Y+15	; 0x0f
    3fc0:	98 89       	ldd	r25, Y+16	; 0x10
    3fc2:	01 97       	sbiw	r24, 0x01	; 1
    3fc4:	f1 f7       	brne	.-4      	; 0x3fc2 <READ_STOR_voidTEMPARTURE+0x122>
    3fc6:	98 8b       	std	Y+16, r25	; 0x10
    3fc8:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(50);
	CLCD_vidGoToXY(LCD_ROW2,LCD_COL1); 
    3fca:	81 e0       	ldi	r24, 0x01	; 1
    3fcc:	60 e0       	ldi	r22, 0x00	; 0
    3fce:	0e 94 14 16 	call	0x2c28	; 0x2c28 <CLCD_vidGoToXY>
	CLCD_vidSednString("TEMP_LOW= "); 
    3fd2:	83 ed       	ldi	r24, 0xD3	; 211
    3fd4:	91 e0       	ldi	r25, 0x01	; 1
    3fd6:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <CLCD_vidSednString>
	CLCD_vidSendLargeNmber(Local_LOW);
    3fda:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3fdc:	88 2f       	mov	r24, r24
    3fde:	90 e0       	ldi	r25, 0x00	; 0
    3fe0:	a0 e0       	ldi	r26, 0x00	; 0
    3fe2:	b0 e0       	ldi	r27, 0x00	; 0
    3fe4:	bc 01       	movw	r22, r24
    3fe6:	cd 01       	movw	r24, r26
    3fe8:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <CLCD_vidSendLargeNmber>
    3fec:	80 e0       	ldi	r24, 0x00	; 0
    3fee:	90 e0       	ldi	r25, 0x00	; 0
    3ff0:	aa e7       	ldi	r26, 0x7A	; 122
    3ff2:	b4 e4       	ldi	r27, 0x44	; 68
    3ff4:	8b 87       	std	Y+11, r24	; 0x0b
    3ff6:	9c 87       	std	Y+12, r25	; 0x0c
    3ff8:	ad 87       	std	Y+13, r26	; 0x0d
    3ffa:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3ffc:	6b 85       	ldd	r22, Y+11	; 0x0b
    3ffe:	7c 85       	ldd	r23, Y+12	; 0x0c
    4000:	8d 85       	ldd	r24, Y+13	; 0x0d
    4002:	9e 85       	ldd	r25, Y+14	; 0x0e
    4004:	20 e0       	ldi	r18, 0x00	; 0
    4006:	30 e0       	ldi	r19, 0x00	; 0
    4008:	4a ef       	ldi	r20, 0xFA	; 250
    400a:	54 e4       	ldi	r21, 0x44	; 68
    400c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4010:	dc 01       	movw	r26, r24
    4012:	cb 01       	movw	r24, r22
    4014:	8f 83       	std	Y+7, r24	; 0x07
    4016:	98 87       	std	Y+8, r25	; 0x08
    4018:	a9 87       	std	Y+9, r26	; 0x09
    401a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    401c:	6f 81       	ldd	r22, Y+7	; 0x07
    401e:	78 85       	ldd	r23, Y+8	; 0x08
    4020:	89 85       	ldd	r24, Y+9	; 0x09
    4022:	9a 85       	ldd	r25, Y+10	; 0x0a
    4024:	20 e0       	ldi	r18, 0x00	; 0
    4026:	30 e0       	ldi	r19, 0x00	; 0
    4028:	40 e8       	ldi	r20, 0x80	; 128
    402a:	5f e3       	ldi	r21, 0x3F	; 63
    402c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4030:	88 23       	and	r24, r24
    4032:	2c f4       	brge	.+10     	; 0x403e <READ_STOR_voidTEMPARTURE+0x19e>
		__ticks = 1;
    4034:	81 e0       	ldi	r24, 0x01	; 1
    4036:	90 e0       	ldi	r25, 0x00	; 0
    4038:	9e 83       	std	Y+6, r25	; 0x06
    403a:	8d 83       	std	Y+5, r24	; 0x05
    403c:	3f c0       	rjmp	.+126    	; 0x40bc <READ_STOR_voidTEMPARTURE+0x21c>
	else if (__tmp > 65535)
    403e:	6f 81       	ldd	r22, Y+7	; 0x07
    4040:	78 85       	ldd	r23, Y+8	; 0x08
    4042:	89 85       	ldd	r24, Y+9	; 0x09
    4044:	9a 85       	ldd	r25, Y+10	; 0x0a
    4046:	20 e0       	ldi	r18, 0x00	; 0
    4048:	3f ef       	ldi	r19, 0xFF	; 255
    404a:	4f e7       	ldi	r20, 0x7F	; 127
    404c:	57 e4       	ldi	r21, 0x47	; 71
    404e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4052:	18 16       	cp	r1, r24
    4054:	4c f5       	brge	.+82     	; 0x40a8 <READ_STOR_voidTEMPARTURE+0x208>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4056:	6b 85       	ldd	r22, Y+11	; 0x0b
    4058:	7c 85       	ldd	r23, Y+12	; 0x0c
    405a:	8d 85       	ldd	r24, Y+13	; 0x0d
    405c:	9e 85       	ldd	r25, Y+14	; 0x0e
    405e:	20 e0       	ldi	r18, 0x00	; 0
    4060:	30 e0       	ldi	r19, 0x00	; 0
    4062:	40 e2       	ldi	r20, 0x20	; 32
    4064:	51 e4       	ldi	r21, 0x41	; 65
    4066:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    406a:	dc 01       	movw	r26, r24
    406c:	cb 01       	movw	r24, r22
    406e:	bc 01       	movw	r22, r24
    4070:	cd 01       	movw	r24, r26
    4072:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4076:	dc 01       	movw	r26, r24
    4078:	cb 01       	movw	r24, r22
    407a:	9e 83       	std	Y+6, r25	; 0x06
    407c:	8d 83       	std	Y+5, r24	; 0x05
    407e:	0f c0       	rjmp	.+30     	; 0x409e <READ_STOR_voidTEMPARTURE+0x1fe>
    4080:	88 ec       	ldi	r24, 0xC8	; 200
    4082:	90 e0       	ldi	r25, 0x00	; 0
    4084:	9c 83       	std	Y+4, r25	; 0x04
    4086:	8b 83       	std	Y+3, r24	; 0x03
    4088:	8b 81       	ldd	r24, Y+3	; 0x03
    408a:	9c 81       	ldd	r25, Y+4	; 0x04
    408c:	01 97       	sbiw	r24, 0x01	; 1
    408e:	f1 f7       	brne	.-4      	; 0x408c <READ_STOR_voidTEMPARTURE+0x1ec>
    4090:	9c 83       	std	Y+4, r25	; 0x04
    4092:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4094:	8d 81       	ldd	r24, Y+5	; 0x05
    4096:	9e 81       	ldd	r25, Y+6	; 0x06
    4098:	01 97       	sbiw	r24, 0x01	; 1
    409a:	9e 83       	std	Y+6, r25	; 0x06
    409c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    409e:	8d 81       	ldd	r24, Y+5	; 0x05
    40a0:	9e 81       	ldd	r25, Y+6	; 0x06
    40a2:	00 97       	sbiw	r24, 0x00	; 0
    40a4:	69 f7       	brne	.-38     	; 0x4080 <READ_STOR_voidTEMPARTURE+0x1e0>
    40a6:	14 c0       	rjmp	.+40     	; 0x40d0 <READ_STOR_voidTEMPARTURE+0x230>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    40a8:	6f 81       	ldd	r22, Y+7	; 0x07
    40aa:	78 85       	ldd	r23, Y+8	; 0x08
    40ac:	89 85       	ldd	r24, Y+9	; 0x09
    40ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    40b0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    40b4:	dc 01       	movw	r26, r24
    40b6:	cb 01       	movw	r24, r22
    40b8:	9e 83       	std	Y+6, r25	; 0x06
    40ba:	8d 83       	std	Y+5, r24	; 0x05
    40bc:	8d 81       	ldd	r24, Y+5	; 0x05
    40be:	9e 81       	ldd	r25, Y+6	; 0x06
    40c0:	9a 83       	std	Y+2, r25	; 0x02
    40c2:	89 83       	std	Y+1, r24	; 0x01
    40c4:	89 81       	ldd	r24, Y+1	; 0x01
    40c6:	9a 81       	ldd	r25, Y+2	; 0x02
    40c8:	01 97       	sbiw	r24, 0x01	; 1
    40ca:	f1 f7       	brne	.-4      	; 0x40c8 <READ_STOR_voidTEMPARTURE+0x228>
    40cc:	9a 83       	std	Y+2, r25	; 0x02
    40ce:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1000);
	CLCD_vidClearLcd();
    40d0:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <CLCD_vidClearLcd>
}
    40d4:	6f 96       	adiw	r28, 0x1f	; 31
    40d6:	0f b6       	in	r0, 0x3f	; 63
    40d8:	f8 94       	cli
    40da:	de bf       	out	0x3e, r29	; 62
    40dc:	0f be       	out	0x3f, r0	; 63
    40de:	cd bf       	out	0x3d, r28	; 61
    40e0:	cf 91       	pop	r28
    40e2:	df 91       	pop	r29
    40e4:	08 95       	ret

000040e6 <main>:
#define F_CPU 8000000UL          // MICRO_CONFIG
#include "util/delay.h"			 // MICRO_CONFIG

extern u8 GLOBAL_u8SELECTOR ; 
int main(void)
{
    40e6:	df 93       	push	r29
    40e8:	cf 93       	push	r28
    40ea:	cd b7       	in	r28, 0x3d	; 61
    40ec:	de b7       	in	r29, 0x3e	; 62
    40ee:	60 97       	sbiw	r28, 0x10	; 16
    40f0:	0f b6       	in	r0, 0x3f	; 63
    40f2:	f8 94       	cli
    40f4:	de bf       	out	0x3e, r29	; 62
    40f6:	0f be       	out	0x3f, r0	; 63
    40f8:	cd bf       	out	0x3d, r28	; 61
	
	
	TEMP_CTRL_SYSTEM_INIT(); /*initialize all system component */
    40fa:	0e 94 8c 17 	call	0x2f18	; 0x2f18 <TEMP_CTRL_SYSTEM_INIT>
	
	
	START_MASSAGE();         /*send the welcome massage */
    40fe:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <START_MASSAGE>
  
    while (1) 
    {
		/*choose which operation selected by user */
		
		switch(GLOBAL_u8SELECTOR)
    4102:	80 91 fe 01 	lds	r24, 0x01FE
    4106:	28 2f       	mov	r18, r24
    4108:	30 e0       	ldi	r19, 0x00	; 0
    410a:	38 8b       	std	Y+16, r19	; 0x10
    410c:	2f 87       	std	Y+15, r18	; 0x0f
    410e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4110:	98 89       	ldd	r25, Y+16	; 0x10
    4112:	81 33       	cpi	r24, 0x31	; 49
    4114:	91 05       	cpc	r25, r1
    4116:	e1 f0       	breq	.+56     	; 0x4150 <main+0x6a>
    4118:	2f 85       	ldd	r18, Y+15	; 0x0f
    411a:	38 89       	ldd	r19, Y+16	; 0x10
    411c:	22 33       	cpi	r18, 0x32	; 50
    411e:	31 05       	cpc	r19, r1
    4120:	34 f4       	brge	.+12     	; 0x412e <main+0x48>
    4122:	8f 85       	ldd	r24, Y+15	; 0x0f
    4124:	98 89       	ldd	r25, Y+16	; 0x10
    4126:	80 33       	cpi	r24, 0x30	; 48
    4128:	91 05       	cpc	r25, r1
    412a:	69 f0       	breq	.+26     	; 0x4146 <main+0x60>
    412c:	ea cf       	rjmp	.-44     	; 0x4102 <main+0x1c>
    412e:	2f 85       	ldd	r18, Y+15	; 0x0f
    4130:	38 89       	ldd	r19, Y+16	; 0x10
    4132:	22 33       	cpi	r18, 0x32	; 50
    4134:	31 05       	cpc	r19, r1
    4136:	b1 f0       	breq	.+44     	; 0x4164 <main+0x7e>
    4138:	8f 85       	ldd	r24, Y+15	; 0x0f
    413a:	98 89       	ldd	r25, Y+16	; 0x10
    413c:	83 33       	cpi	r24, 0x33	; 51
    413e:	91 05       	cpc	r25, r1
    4140:	09 f4       	brne	.+2      	; 0x4144 <main+0x5e>
    4142:	8c c0       	rjmp	.+280    	; 0x425c <main+0x176>
    4144:	de cf       	rjmp	.-68     	; 0x4102 <main+0x1c>
		{
			case '0':
			
				 MAIN_MENUE();  /*display to the user the whole option that  program  perform */
    4146:	0e 94 d7 18 	call	0x31ae	; 0x31ae <MAIN_MENUE>
    414a:	db cf       	rjmp	.-74     	; 0x4102 <main+0x1c>
			  break;
			
			case '1': while('1' == GLOBAL_u8SELECTOR)
					  {
					  	   TEMP_VALUE();  /*start the programe */  
    414c:	0e 94 c9 19 	call	0x3392	; 0x3392 <TEMP_VALUE>
			case '0':
			
				 MAIN_MENUE();  /*display to the user the whole option that  program  perform */
			  break;
			
			case '1': while('1' == GLOBAL_u8SELECTOR)
    4150:	80 91 fe 01 	lds	r24, 0x01FE
    4154:	81 33       	cpi	r24, 0x31	; 49
    4156:	d1 f3       	breq	.-12     	; 0x414c <main+0x66>
    4158:	d4 cf       	rjmp	.-88     	; 0x4102 <main+0x1c>
					  }
			break;
			
			case '2': while('2' == GLOBAL_u8SELECTOR)
						{
							 STORE_voidTEMPRATURE(); /*store high an low temp on EXT EEPROM  */
    415a:	0e 94 ed 1c 	call	0x39da	; 0x39da <STORE_voidTEMPRATURE>
							 GLOBAL_u8SELECTOR='0'; 
    415e:	80 e3       	ldi	r24, 0x30	; 48
    4160:	80 93 fe 01 	sts	0x01FE, r24
					  {
					  	   TEMP_VALUE();  /*start the programe */  
					  }
			break;
			
			case '2': while('2' == GLOBAL_u8SELECTOR)
    4164:	80 91 fe 01 	lds	r24, 0x01FE
    4168:	82 33       	cpi	r24, 0x32	; 50
    416a:	b9 f3       	breq	.-18     	; 0x415a <main+0x74>
    416c:	ca cf       	rjmp	.-108    	; 0x4102 <main+0x1c>
			break;
			 
			
			case '3': while('3' == GLOBAL_u8SELECTOR)/*function to display EEPROM values*/
					  {
					  	READ_STOR_voidTEMPARTURE();  /*read the value stored on EEPROM*/
    416e:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <READ_STOR_voidTEMPARTURE>
    4172:	80 e0       	ldi	r24, 0x00	; 0
    4174:	90 e0       	ldi	r25, 0x00	; 0
    4176:	a8 ec       	ldi	r26, 0xC8	; 200
    4178:	b2 e4       	ldi	r27, 0x42	; 66
    417a:	8b 87       	std	Y+11, r24	; 0x0b
    417c:	9c 87       	std	Y+12, r25	; 0x0c
    417e:	ad 87       	std	Y+13, r26	; 0x0d
    4180:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4182:	6b 85       	ldd	r22, Y+11	; 0x0b
    4184:	7c 85       	ldd	r23, Y+12	; 0x0c
    4186:	8d 85       	ldd	r24, Y+13	; 0x0d
    4188:	9e 85       	ldd	r25, Y+14	; 0x0e
    418a:	20 e0       	ldi	r18, 0x00	; 0
    418c:	30 e0       	ldi	r19, 0x00	; 0
    418e:	4a ef       	ldi	r20, 0xFA	; 250
    4190:	54 e4       	ldi	r21, 0x44	; 68
    4192:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4196:	dc 01       	movw	r26, r24
    4198:	cb 01       	movw	r24, r22
    419a:	8f 83       	std	Y+7, r24	; 0x07
    419c:	98 87       	std	Y+8, r25	; 0x08
    419e:	a9 87       	std	Y+9, r26	; 0x09
    41a0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    41a2:	6f 81       	ldd	r22, Y+7	; 0x07
    41a4:	78 85       	ldd	r23, Y+8	; 0x08
    41a6:	89 85       	ldd	r24, Y+9	; 0x09
    41a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    41aa:	20 e0       	ldi	r18, 0x00	; 0
    41ac:	30 e0       	ldi	r19, 0x00	; 0
    41ae:	40 e8       	ldi	r20, 0x80	; 128
    41b0:	5f e3       	ldi	r21, 0x3F	; 63
    41b2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    41b6:	88 23       	and	r24, r24
    41b8:	2c f4       	brge	.+10     	; 0x41c4 <main+0xde>
		__ticks = 1;
    41ba:	81 e0       	ldi	r24, 0x01	; 1
    41bc:	90 e0       	ldi	r25, 0x00	; 0
    41be:	9e 83       	std	Y+6, r25	; 0x06
    41c0:	8d 83       	std	Y+5, r24	; 0x05
    41c2:	3f c0       	rjmp	.+126    	; 0x4242 <main+0x15c>
	else if (__tmp > 65535)
    41c4:	6f 81       	ldd	r22, Y+7	; 0x07
    41c6:	78 85       	ldd	r23, Y+8	; 0x08
    41c8:	89 85       	ldd	r24, Y+9	; 0x09
    41ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    41cc:	20 e0       	ldi	r18, 0x00	; 0
    41ce:	3f ef       	ldi	r19, 0xFF	; 255
    41d0:	4f e7       	ldi	r20, 0x7F	; 127
    41d2:	57 e4       	ldi	r21, 0x47	; 71
    41d4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    41d8:	18 16       	cp	r1, r24
    41da:	4c f5       	brge	.+82     	; 0x422e <main+0x148>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    41dc:	6b 85       	ldd	r22, Y+11	; 0x0b
    41de:	7c 85       	ldd	r23, Y+12	; 0x0c
    41e0:	8d 85       	ldd	r24, Y+13	; 0x0d
    41e2:	9e 85       	ldd	r25, Y+14	; 0x0e
    41e4:	20 e0       	ldi	r18, 0x00	; 0
    41e6:	30 e0       	ldi	r19, 0x00	; 0
    41e8:	40 e2       	ldi	r20, 0x20	; 32
    41ea:	51 e4       	ldi	r21, 0x41	; 65
    41ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    41f0:	dc 01       	movw	r26, r24
    41f2:	cb 01       	movw	r24, r22
    41f4:	bc 01       	movw	r22, r24
    41f6:	cd 01       	movw	r24, r26
    41f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    41fc:	dc 01       	movw	r26, r24
    41fe:	cb 01       	movw	r24, r22
    4200:	9e 83       	std	Y+6, r25	; 0x06
    4202:	8d 83       	std	Y+5, r24	; 0x05
    4204:	0f c0       	rjmp	.+30     	; 0x4224 <main+0x13e>
    4206:	88 ec       	ldi	r24, 0xC8	; 200
    4208:	90 e0       	ldi	r25, 0x00	; 0
    420a:	9c 83       	std	Y+4, r25	; 0x04
    420c:	8b 83       	std	Y+3, r24	; 0x03
    420e:	8b 81       	ldd	r24, Y+3	; 0x03
    4210:	9c 81       	ldd	r25, Y+4	; 0x04
    4212:	01 97       	sbiw	r24, 0x01	; 1
    4214:	f1 f7       	brne	.-4      	; 0x4212 <main+0x12c>
    4216:	9c 83       	std	Y+4, r25	; 0x04
    4218:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    421a:	8d 81       	ldd	r24, Y+5	; 0x05
    421c:	9e 81       	ldd	r25, Y+6	; 0x06
    421e:	01 97       	sbiw	r24, 0x01	; 1
    4220:	9e 83       	std	Y+6, r25	; 0x06
    4222:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4224:	8d 81       	ldd	r24, Y+5	; 0x05
    4226:	9e 81       	ldd	r25, Y+6	; 0x06
    4228:	00 97       	sbiw	r24, 0x00	; 0
    422a:	69 f7       	brne	.-38     	; 0x4206 <main+0x120>
    422c:	14 c0       	rjmp	.+40     	; 0x4256 <main+0x170>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    422e:	6f 81       	ldd	r22, Y+7	; 0x07
    4230:	78 85       	ldd	r23, Y+8	; 0x08
    4232:	89 85       	ldd	r24, Y+9	; 0x09
    4234:	9a 85       	ldd	r25, Y+10	; 0x0a
    4236:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    423a:	dc 01       	movw	r26, r24
    423c:	cb 01       	movw	r24, r22
    423e:	9e 83       	std	Y+6, r25	; 0x06
    4240:	8d 83       	std	Y+5, r24	; 0x05
    4242:	8d 81       	ldd	r24, Y+5	; 0x05
    4244:	9e 81       	ldd	r25, Y+6	; 0x06
    4246:	9a 83       	std	Y+2, r25	; 0x02
    4248:	89 83       	std	Y+1, r24	; 0x01
    424a:	89 81       	ldd	r24, Y+1	; 0x01
    424c:	9a 81       	ldd	r25, Y+2	; 0x02
    424e:	01 97       	sbiw	r24, 0x01	; 1
    4250:	f1 f7       	brne	.-4      	; 0x424e <main+0x168>
    4252:	9a 83       	std	Y+2, r25	; 0x02
    4254:	89 83       	std	Y+1, r24	; 0x01
						  _delay_ms(100);
						GLOBAL_u8SELECTOR='0'; 
    4256:	80 e3       	ldi	r24, 0x30	; 48
    4258:	80 93 fe 01 	sts	0x01FE, r24
							 GLOBAL_u8SELECTOR='0'; 
						}
			break;
			 
			
			case '3': while('3' == GLOBAL_u8SELECTOR)/*function to display EEPROM values*/
    425c:	80 91 fe 01 	lds	r24, 0x01FE
    4260:	83 33       	cpi	r24, 0x33	; 51
    4262:	09 f4       	brne	.+2      	; 0x4266 <main+0x180>
    4264:	84 cf       	rjmp	.-248    	; 0x416e <main+0x88>
    4266:	4d cf       	rjmp	.-358    	; 0x4102 <main+0x1c>

00004268 <__mulsi3>:
    4268:	62 9f       	mul	r22, r18
    426a:	d0 01       	movw	r26, r0
    426c:	73 9f       	mul	r23, r19
    426e:	f0 01       	movw	r30, r0
    4270:	82 9f       	mul	r24, r18
    4272:	e0 0d       	add	r30, r0
    4274:	f1 1d       	adc	r31, r1
    4276:	64 9f       	mul	r22, r20
    4278:	e0 0d       	add	r30, r0
    427a:	f1 1d       	adc	r31, r1
    427c:	92 9f       	mul	r25, r18
    427e:	f0 0d       	add	r31, r0
    4280:	83 9f       	mul	r24, r19
    4282:	f0 0d       	add	r31, r0
    4284:	74 9f       	mul	r23, r20
    4286:	f0 0d       	add	r31, r0
    4288:	65 9f       	mul	r22, r21
    428a:	f0 0d       	add	r31, r0
    428c:	99 27       	eor	r25, r25
    428e:	72 9f       	mul	r23, r18
    4290:	b0 0d       	add	r27, r0
    4292:	e1 1d       	adc	r30, r1
    4294:	f9 1f       	adc	r31, r25
    4296:	63 9f       	mul	r22, r19
    4298:	b0 0d       	add	r27, r0
    429a:	e1 1d       	adc	r30, r1
    429c:	f9 1f       	adc	r31, r25
    429e:	bd 01       	movw	r22, r26
    42a0:	cf 01       	movw	r24, r30
    42a2:	11 24       	eor	r1, r1
    42a4:	08 95       	ret

000042a6 <__udivmodhi4>:
    42a6:	aa 1b       	sub	r26, r26
    42a8:	bb 1b       	sub	r27, r27
    42aa:	51 e1       	ldi	r21, 0x11	; 17
    42ac:	07 c0       	rjmp	.+14     	; 0x42bc <__udivmodhi4_ep>

000042ae <__udivmodhi4_loop>:
    42ae:	aa 1f       	adc	r26, r26
    42b0:	bb 1f       	adc	r27, r27
    42b2:	a6 17       	cp	r26, r22
    42b4:	b7 07       	cpc	r27, r23
    42b6:	10 f0       	brcs	.+4      	; 0x42bc <__udivmodhi4_ep>
    42b8:	a6 1b       	sub	r26, r22
    42ba:	b7 0b       	sbc	r27, r23

000042bc <__udivmodhi4_ep>:
    42bc:	88 1f       	adc	r24, r24
    42be:	99 1f       	adc	r25, r25
    42c0:	5a 95       	dec	r21
    42c2:	a9 f7       	brne	.-22     	; 0x42ae <__udivmodhi4_loop>
    42c4:	80 95       	com	r24
    42c6:	90 95       	com	r25
    42c8:	bc 01       	movw	r22, r24
    42ca:	cd 01       	movw	r24, r26
    42cc:	08 95       	ret

000042ce <__udivmodsi4>:
    42ce:	a1 e2       	ldi	r26, 0x21	; 33
    42d0:	1a 2e       	mov	r1, r26
    42d2:	aa 1b       	sub	r26, r26
    42d4:	bb 1b       	sub	r27, r27
    42d6:	fd 01       	movw	r30, r26
    42d8:	0d c0       	rjmp	.+26     	; 0x42f4 <__udivmodsi4_ep>

000042da <__udivmodsi4_loop>:
    42da:	aa 1f       	adc	r26, r26
    42dc:	bb 1f       	adc	r27, r27
    42de:	ee 1f       	adc	r30, r30
    42e0:	ff 1f       	adc	r31, r31
    42e2:	a2 17       	cp	r26, r18
    42e4:	b3 07       	cpc	r27, r19
    42e6:	e4 07       	cpc	r30, r20
    42e8:	f5 07       	cpc	r31, r21
    42ea:	20 f0       	brcs	.+8      	; 0x42f4 <__udivmodsi4_ep>
    42ec:	a2 1b       	sub	r26, r18
    42ee:	b3 0b       	sbc	r27, r19
    42f0:	e4 0b       	sbc	r30, r20
    42f2:	f5 0b       	sbc	r31, r21

000042f4 <__udivmodsi4_ep>:
    42f4:	66 1f       	adc	r22, r22
    42f6:	77 1f       	adc	r23, r23
    42f8:	88 1f       	adc	r24, r24
    42fa:	99 1f       	adc	r25, r25
    42fc:	1a 94       	dec	r1
    42fe:	69 f7       	brne	.-38     	; 0x42da <__udivmodsi4_loop>
    4300:	60 95       	com	r22
    4302:	70 95       	com	r23
    4304:	80 95       	com	r24
    4306:	90 95       	com	r25
    4308:	9b 01       	movw	r18, r22
    430a:	ac 01       	movw	r20, r24
    430c:	bd 01       	movw	r22, r26
    430e:	cf 01       	movw	r24, r30
    4310:	08 95       	ret

00004312 <__prologue_saves__>:
    4312:	2f 92       	push	r2
    4314:	3f 92       	push	r3
    4316:	4f 92       	push	r4
    4318:	5f 92       	push	r5
    431a:	6f 92       	push	r6
    431c:	7f 92       	push	r7
    431e:	8f 92       	push	r8
    4320:	9f 92       	push	r9
    4322:	af 92       	push	r10
    4324:	bf 92       	push	r11
    4326:	cf 92       	push	r12
    4328:	df 92       	push	r13
    432a:	ef 92       	push	r14
    432c:	ff 92       	push	r15
    432e:	0f 93       	push	r16
    4330:	1f 93       	push	r17
    4332:	cf 93       	push	r28
    4334:	df 93       	push	r29
    4336:	cd b7       	in	r28, 0x3d	; 61
    4338:	de b7       	in	r29, 0x3e	; 62
    433a:	ca 1b       	sub	r28, r26
    433c:	db 0b       	sbc	r29, r27
    433e:	0f b6       	in	r0, 0x3f	; 63
    4340:	f8 94       	cli
    4342:	de bf       	out	0x3e, r29	; 62
    4344:	0f be       	out	0x3f, r0	; 63
    4346:	cd bf       	out	0x3d, r28	; 61
    4348:	09 94       	ijmp

0000434a <__epilogue_restores__>:
    434a:	2a 88       	ldd	r2, Y+18	; 0x12
    434c:	39 88       	ldd	r3, Y+17	; 0x11
    434e:	48 88       	ldd	r4, Y+16	; 0x10
    4350:	5f 84       	ldd	r5, Y+15	; 0x0f
    4352:	6e 84       	ldd	r6, Y+14	; 0x0e
    4354:	7d 84       	ldd	r7, Y+13	; 0x0d
    4356:	8c 84       	ldd	r8, Y+12	; 0x0c
    4358:	9b 84       	ldd	r9, Y+11	; 0x0b
    435a:	aa 84       	ldd	r10, Y+10	; 0x0a
    435c:	b9 84       	ldd	r11, Y+9	; 0x09
    435e:	c8 84       	ldd	r12, Y+8	; 0x08
    4360:	df 80       	ldd	r13, Y+7	; 0x07
    4362:	ee 80       	ldd	r14, Y+6	; 0x06
    4364:	fd 80       	ldd	r15, Y+5	; 0x05
    4366:	0c 81       	ldd	r16, Y+4	; 0x04
    4368:	1b 81       	ldd	r17, Y+3	; 0x03
    436a:	aa 81       	ldd	r26, Y+2	; 0x02
    436c:	b9 81       	ldd	r27, Y+1	; 0x01
    436e:	ce 0f       	add	r28, r30
    4370:	d1 1d       	adc	r29, r1
    4372:	0f b6       	in	r0, 0x3f	; 63
    4374:	f8 94       	cli
    4376:	de bf       	out	0x3e, r29	; 62
    4378:	0f be       	out	0x3f, r0	; 63
    437a:	cd bf       	out	0x3d, r28	; 61
    437c:	ed 01       	movw	r28, r26
    437e:	08 95       	ret

00004380 <_exit>:
    4380:	f8 94       	cli

00004382 <__stop_program>:
    4382:	ff cf       	rjmp	.-2      	; 0x4382 <__stop_program>
